{"buggy_code": ["Couldn't find the requested file /db/post_migrate/20221025153038_deactivate_unverified_email_patreon_accounts.rb in discourse/discourse-patreon.", "Couldn't find the requested file /db/post_migrate/20221026043851_delete_unverified_patreon_user_info.rb in discourse/discourse-patreon.", "# frozen_string_literal: true\n\n# name: discourse-patreon\n# about: Integration features between Patreon and Discourse\n# version: 2.0\n# author: Rafael dos Santos Silva <xfalcox@gmail.com>\n# url: https://github.com/discourse/discourse-patreon\n# transpile_js: true\n\nrequire 'omniauth-oauth2'\n\nenabled_site_setting :patreon_enabled\n\nPLUGIN_NAME = 'discourse-patreon'\n\nregister_asset 'stylesheets/patreon.scss'\n\nregister_svg_icon \"fab-patreon\"\n\n# Site setting validators must be loaded before initialize\nrequire_relative 'lib/validators/patreon_login_enabled_validator'\n\nafter_initialize do\n\n  require_dependency 'admin_constraint'\n\n  module ::Patreon\n    PLUGIN_NAME = 'discourse-patreon'.freeze\n    USER_DETAIL_FIELDS = [\"id\", \"amount_cents\", \"rewards\", \"declined_since\"].freeze\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace Patreon\n    end\n\n    def self.store\n      @store ||= PluginStore.new(PLUGIN_NAME)\n    end\n\n    def self.get(key)\n      store.get(key)\n    end\n\n    def self.set(key, value)\n      store.set(key, value)\n    end\n\n    def self.show_donation_prompt_to_user?(user)\n      return false unless SiteSetting.patreon_donation_prompt_enabled?\n\n      filters = get('filters') || {}\n      filters = filters.keys.map(&:to_i)\n\n      (user.visible_groups.pluck(:id) & filters).size <= 0\n    end\n\n    class Reward\n\n      def self.all\n        Patreon.get(\"rewards\") || {}\n      end\n\n    end\n\n    class RewardUser\n\n      def self.all\n        Patreon.get(\"reward-users\") || {}\n      end\n\n    end\n  end\n\n  [\n    '../app/controllers/patreon_admin_controller.rb',\n    '../app/controllers/patreon_webhook_controller.rb',\n    '../app/jobs/regular/sync_patron_groups.rb',\n    '../app/jobs/scheduled/patreon_sync_patrons_to_groups.rb',\n    '../app/jobs/scheduled/patreon_update_tokens.rb',\n    '../lib/api.rb',\n    '../lib/seed.rb',\n    '../lib/campaign.rb',\n    '../lib/pledge.rb',\n    '../lib/patron.rb',\n    '../lib/tokens.rb'\n  ].each { |path| load File.expand_path(path, __FILE__) }\n\n  AdminDashboardData.problem_messages << ::Patreon::Api::ACCESS_TOKEN_INVALID\n\n  Patreon::Engine.routes.draw do\n    get '/rewards' => 'patreon_admin#rewards', constraints: AdminConstraint.new\n    get '/list' => 'patreon_admin#list', constraints: AdminConstraint.new\n    post '/list' => 'patreon_admin#edit', constraints: AdminConstraint.new\n    delete '/list' => 'patreon_admin#delete', constraints: AdminConstraint.new\n    post '/sync_groups' => 'patreon_admin#sync_groups', constraints: AdminConstraint.new\n    post '/update_data' => 'patreon_admin#update_data', constraints: AdminConstraint.new\n    post '/webhook' => 'patreon_webhook#index'\n  end\n\n  Discourse::Application.routes.prepend do\n    mount ::Patreon::Engine, at: '/patreon'\n  end\n\n  add_admin_route 'patreon.title', 'patreon'\n\n  Discourse::Application.routes.append do\n    get '/admin/plugins/patreon' => 'admin/plugins#index', constraints: AdminConstraint.new\n    get '/admin/plugins/patreon/list' => 'patreon/patreon_admin#list', constraints: AdminConstraint.new\n    get '/u/:username/patreon_email' => 'patreon/patreon_admin#email', constraints: { username: RouteFormat.username }\n  end\n\n  on(:user_created) do |user|\n    filters = PluginStore.get(PLUGIN_NAME, 'filters')\n    patreon_id = Patreon::Patron.all.key(user.email)\n\n    if filters.present? && patreon_id.present?\n      begin\n        reward_id = Patreon::RewardUser.all.except('0').detect { |_k, v| v.include? patreon_id }&.first\n\n        group_ids = filters.select { |_k, v| v.include?(reward_id) || v.include?('0') }.keys\n\n        Group.where(id: group_ids).each { |group| group.add user }\n\n        Patreon::Patron.update_local_user(user, patreon_id, true)\n      rescue => e\n        Rails.logger.warn(\"Patreon group membership callback failed for new user #{self.id} with error: #{e}.\\n\\n #{e.backtrace.join(\"\\n\")}\")\n      end\n    end\n  end\n\n  ::Patreon::USER_DETAIL_FIELDS.each do |attribute|\n    add_to_serializer(:admin_detailed_user, \"patreon_#{attribute}\".to_sym, false) do\n      ::Patreon::Patron.attr(attribute, object)\n    end\n\n    add_to_serializer(:admin_detailed_user, \"include_patreon_#{attribute}?\".to_sym) do\n      ::Patreon::Patron.attr(attribute, object).present? &&\n      (attribute != \"amount_cents\" || scope.is_admin?)\n    end\n  end\n\n  add_to_serializer(:admin_detailed_user, :patreon_email_exists, false) do\n    ::Patreon::Patron.attr(\"email\", object).present?\n  end\n\n  add_to_serializer(:admin_detailed_user, \"include_patreon_email_exists?\".to_sym) do\n    ::Patreon::Patron.attr(\"email\", object).present?\n  end\n\n  add_to_serializer(:current_user, :show_donation_prompt?) {\n    Patreon.show_donation_prompt_to_user?(object)\n  }\n\nend\n\n# Authentication with Patreon\nclass ::OmniAuth::Strategies::Patreon < ::OmniAuth::Strategies::OAuth2\n  option :name, 'patreon'\n\n  option :client_options,\n    site: 'https://www.patreon.com',\n    authorize_url: 'https://www.patreon.com/oauth2/authorize',\n    token_url: 'https://api.patreon.com/oauth2/token'\n\n  option :authorize_params, response_type: 'code'\n\n  def custom_build_access_token\n    verifier = request.params['code']\n    client.auth_code.get_token(verifier, redirect_uri: options.redirect_uri)\n  end\n\n  alias_method :build_access_token, :custom_build_access_token\n\n  uid {\n    raw_info['data']['id'].to_s\n  }\n\n  info do\n    {\n      email: raw_info['data']['attributes']['email'],\n      name: raw_info['data']['attributes']['full_name']\n    }\n  end\n\n  extra do\n    {\n      raw_info: raw_info\n    }\n  end\n\n  def raw_info\n    @raw_info ||= begin\n      response = client.request(:get, \"https://api.patreon.com/oauth2/api/current_user\", headers: {\n          'Authorization' => \"Bearer #{access_token.token}\"\n      }, parse: :json)\n      response.parsed\n    end\n  end\n\n  def callback_url\n    full_host + script_name + callback_path\n  end\nend\n\nclass Auth::PatreonAuthenticator < Auth::ManagedAuthenticator\n  def name\n    \"patreon\"\n  end\n\n  def register_middleware(omniauth)\n    omniauth.provider :patreon,\n                      setup: lambda { |env|\n                        strategy = env['omniauth.strategy']\n                        strategy.options[:client_id] = SiteSetting.patreon_client_id\n                        strategy.options[:client_secret] = SiteSetting.patreon_client_secret\n                        strategy.options[:redirect_uri] = \"#{Discourse.base_url}/auth/patreon/callback\"\n                        strategy.options[:provider_ignores_state] = SiteSetting.patreon_login_ignore_state\n                      }\n  end\n\n  def after_authenticate(auth_token, existing_account: nil)\n    result = super\n\n    user = result.user\n    discourse_username = SiteSetting.patreon_creator_discourse_username\n    if discourse_username.present? && user && user.username == discourse_username\n      SiteSetting.patreon_creator_access_token = auth_token.credentials[\"access_token\"]\n      SiteSetting.patreon_creator_refresh_token = auth_token.credentials[\"refresh_token\"]\n    end\n\n    result\n  end\n\n  def enabled?\n    SiteSetting.patreon_login_enabled\n  end\nend\n\nauth_provider authenticator: Auth::PatreonAuthenticator.new\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass DeactivateUnverifiedEmailPatreonAccounts < ActiveRecord::Migration[6.1]\n  def up\n    execute <<~SQL\n      UPDATE users SET active = false\n      WHERE users.id IN (\n        SELECT user_id FROM user_associated_accounts\n        WHERE provider_name = 'patreon'\n        AND extra -> 'raw_info' -> 'data' -> 'attributes' ->> 'is_email_verified' = 'false'\n      )\n    SQL\n  end\n\n  def down\n    # noop\n  end\nend\n", "# frozen_string_literal: true\n\nclass DeleteUnverifiedPatreonUserInfo < ActiveRecord::Migration[6.1]\n  def up\n    execute <<~SQL\n      DELETE FROM user_auth_tokens\n      WHERE user_id IN (\n        SELECT user_id\n        FROM user_associated_accounts\n        WHERE provider_name = 'patreon'\n        AND COALESCE(JSON_EXTRACT_PATH(extra::json, 'raw_info', 'data', 'attributes', 'is_email_verified')::text, 'false') <> 'true'\n      )\n    SQL\n\n    execute <<~SQL\n      UPDATE user_api_keys\n      SET revoked_at = NOW()\n      WHERE user_id IN (\n        SELECT user_id\n        FROM user_associated_accounts\n        WHERE provider_name = 'patreon'\n        AND COALESCE(JSON_EXTRACT_PATH(extra::json, 'raw_info', 'data', 'attributes', 'is_email_verified')::text, 'false') <> 'true'\n      )\n    SQL\n\n    execute <<~SQL\n      UPDATE api_keys\n      SET revoked_at = NOW()\n      WHERE created_by_id IN (\n        SELECT user_id\n        FROM user_associated_accounts\n        WHERE provider_name = 'patreon'\n        AND COALESCE(JSON_EXTRACT_PATH(extra::json, 'raw_info', 'data', 'attributes', 'is_email_verified')::text, 'false') <> 'true'\n      )\n    SQL\n\n    execute <<~SQL\n      DELETE FROM user_associated_accounts\n      WHERE provider_name = 'patreon'\n      AND COALESCE(JSON_EXTRACT_PATH(extra::json, 'raw_info', 'data', 'attributes', 'is_email_verified')::text, 'false') <> 'true'\n    SQL\n  end\n\n  def down\n    # noop\n  end\nend\n", "# frozen_string_literal: true\n\n# name: discourse-patreon\n# about: Integration features between Patreon and Discourse\n# version: 2.0\n# author: Rafael dos Santos Silva <xfalcox@gmail.com>\n# url: https://github.com/discourse/discourse-patreon\n# transpile_js: true\n\nrequire 'omniauth-oauth2'\n\nenabled_site_setting :patreon_enabled\n\nPLUGIN_NAME = 'discourse-patreon'\n\nregister_asset 'stylesheets/patreon.scss'\n\nregister_svg_icon \"fab-patreon\"\n\n# Site setting validators must be loaded before initialize\nrequire_relative 'lib/validators/patreon_login_enabled_validator'\n\nafter_initialize do\n\n  require_dependency 'admin_constraint'\n\n  module ::Patreon\n    PLUGIN_NAME = 'discourse-patreon'.freeze\n    USER_DETAIL_FIELDS = [\"id\", \"amount_cents\", \"rewards\", \"declined_since\"].freeze\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace Patreon\n    end\n\n    def self.store\n      @store ||= PluginStore.new(PLUGIN_NAME)\n    end\n\n    def self.get(key)\n      store.get(key)\n    end\n\n    def self.set(key, value)\n      store.set(key, value)\n    end\n\n    def self.show_donation_prompt_to_user?(user)\n      return false unless SiteSetting.patreon_donation_prompt_enabled?\n\n      filters = get('filters') || {}\n      filters = filters.keys.map(&:to_i)\n\n      (user.visible_groups.pluck(:id) & filters).size <= 0\n    end\n\n    class Reward\n\n      def self.all\n        Patreon.get(\"rewards\") || {}\n      end\n\n    end\n\n    class RewardUser\n\n      def self.all\n        Patreon.get(\"reward-users\") || {}\n      end\n\n    end\n  end\n\n  [\n    '../app/controllers/patreon_admin_controller.rb',\n    '../app/controllers/patreon_webhook_controller.rb',\n    '../app/jobs/regular/sync_patron_groups.rb',\n    '../app/jobs/scheduled/patreon_sync_patrons_to_groups.rb',\n    '../app/jobs/scheduled/patreon_update_tokens.rb',\n    '../lib/api.rb',\n    '../lib/seed.rb',\n    '../lib/campaign.rb',\n    '../lib/pledge.rb',\n    '../lib/patron.rb',\n    '../lib/tokens.rb'\n  ].each { |path| load File.expand_path(path, __FILE__) }\n\n  AdminDashboardData.problem_messages << ::Patreon::Api::ACCESS_TOKEN_INVALID\n\n  Patreon::Engine.routes.draw do\n    get '/rewards' => 'patreon_admin#rewards', constraints: AdminConstraint.new\n    get '/list' => 'patreon_admin#list', constraints: AdminConstraint.new\n    post '/list' => 'patreon_admin#edit', constraints: AdminConstraint.new\n    delete '/list' => 'patreon_admin#delete', constraints: AdminConstraint.new\n    post '/sync_groups' => 'patreon_admin#sync_groups', constraints: AdminConstraint.new\n    post '/update_data' => 'patreon_admin#update_data', constraints: AdminConstraint.new\n    post '/webhook' => 'patreon_webhook#index'\n  end\n\n  Discourse::Application.routes.prepend do\n    mount ::Patreon::Engine, at: '/patreon'\n  end\n\n  add_admin_route 'patreon.title', 'patreon'\n\n  Discourse::Application.routes.append do\n    get '/admin/plugins/patreon' => 'admin/plugins#index', constraints: AdminConstraint.new\n    get '/admin/plugins/patreon/list' => 'patreon/patreon_admin#list', constraints: AdminConstraint.new\n    get '/u/:username/patreon_email' => 'patreon/patreon_admin#email', constraints: { username: RouteFormat.username }\n  end\n\n  on(:user_created) do |user|\n    filters = PluginStore.get(PLUGIN_NAME, 'filters')\n    patreon_id = Patreon::Patron.all.key(user.email)\n\n    if filters.present? && patreon_id.present?\n      begin\n        reward_id = Patreon::RewardUser.all.except('0').detect { |_k, v| v.include? patreon_id }&.first\n\n        group_ids = filters.select { |_k, v| v.include?(reward_id) || v.include?('0') }.keys\n\n        Group.where(id: group_ids).each { |group| group.add user }\n\n        Patreon::Patron.update_local_user(user, patreon_id, true)\n      rescue => e\n        Rails.logger.warn(\"Patreon group membership callback failed for new user #{self.id} with error: #{e}.\\n\\n #{e.backtrace.join(\"\\n\")}\")\n      end\n    end\n  end\n\n  ::Patreon::USER_DETAIL_FIELDS.each do |attribute|\n    add_to_serializer(:admin_detailed_user, \"patreon_#{attribute}\".to_sym, false) do\n      ::Patreon::Patron.attr(attribute, object)\n    end\n\n    add_to_serializer(:admin_detailed_user, \"include_patreon_#{attribute}?\".to_sym) do\n      ::Patreon::Patron.attr(attribute, object).present? &&\n      (attribute != \"amount_cents\" || scope.is_admin?)\n    end\n  end\n\n  add_to_serializer(:admin_detailed_user, :patreon_email_exists, false) do\n    ::Patreon::Patron.attr(\"email\", object).present?\n  end\n\n  add_to_serializer(:admin_detailed_user, \"include_patreon_email_exists?\".to_sym) do\n    ::Patreon::Patron.attr(\"email\", object).present?\n  end\n\n  add_to_serializer(:current_user, :show_donation_prompt?) {\n    Patreon.show_donation_prompt_to_user?(object)\n  }\n\nend\n\n# Authentication with Patreon\nclass ::OmniAuth::Strategies::Patreon < ::OmniAuth::Strategies::OAuth2\n  option :name, 'patreon'\n\n  option :client_options,\n    site: 'https://www.patreon.com',\n    authorize_url: 'https://www.patreon.com/oauth2/authorize',\n    token_url: 'https://api.patreon.com/oauth2/token'\n\n  option :authorize_params, response_type: 'code'\n\n  def custom_build_access_token\n    verifier = request.params['code']\n    client.auth_code.get_token(verifier, redirect_uri: options.redirect_uri)\n  end\n\n  alias_method :build_access_token, :custom_build_access_token\n\n  uid {\n    raw_info['data']['id'].to_s\n  }\n\n  info do\n    {\n      email: raw_info['data']['attributes']['email'],\n      email_verified: raw_info['data']['attributes']['is_email_verified'],\n      name: raw_info['data']['attributes']['full_name']\n    }\n  end\n\n  extra do\n    {\n      raw_info: raw_info\n    }\n  end\n\n  def raw_info\n    @raw_info ||= begin\n      response = client.request(:get, \"https://api.patreon.com/oauth2/api/current_user\", headers: {\n          'Authorization' => \"Bearer #{access_token.token}\"\n      }, parse: :json)\n      response.parsed\n    end\n  end\n\n  def callback_url\n    full_host + script_name + callback_path\n  end\nend\n\nclass Auth::PatreonAuthenticator < Auth::ManagedAuthenticator\n  def name\n    \"patreon\"\n  end\n\n  def register_middleware(omniauth)\n    omniauth.provider :patreon,\n                      setup: lambda { |env|\n                        strategy = env['omniauth.strategy']\n                        strategy.options[:client_id] = SiteSetting.patreon_client_id\n                        strategy.options[:client_secret] = SiteSetting.patreon_client_secret\n                        strategy.options[:redirect_uri] = \"#{Discourse.base_url}/auth/patreon/callback\"\n                        strategy.options[:provider_ignores_state] = SiteSetting.patreon_login_ignore_state\n                      }\n  end\n\n  def after_authenticate(auth_token, existing_account: nil)\n    result = super\n\n    user = result.user\n    discourse_username = SiteSetting.patreon_creator_discourse_username\n    if discourse_username.present? && user && user.username == discourse_username\n      SiteSetting.patreon_creator_access_token = auth_token.credentials[\"access_token\"]\n      SiteSetting.patreon_creator_refresh_token = auth_token.credentials[\"refresh_token\"]\n    end\n\n    result\n  end\n\n  def enabled?\n    SiteSetting.patreon_login_enabled\n  end\n\n  def primary_email_verified?(auth_token)\n    auth_token[:info][:email_verified]\n  end\nend\n\nauth_provider authenticator: Auth::PatreonAuthenticator.new\n"], "buggy_code_start_loc": [1, 1, 180], "buggy_code_end_loc": [2, 2, 236], "fixing_code_start_loc": [1, 1, 181], "fixing_code_end_loc": [19, 48, 242], "type": "CWE-287", "message": "Discourse Patreon enables syncronization between Discourse Groups and Patreon rewards. On sites with Patreon login enabled, an improper authentication vulnerability could be used to take control of a victim's forum account. This vulnerability is patched in commit number 846d012151514b35ce42a1636c7d70f6dcee879e of the discourse-patreon plugin. Out of an abundance of caution, any Discourse accounts which have logged in with an unverified-email Patreon account will be logged out and asked to verify their email address on their next login. As a workaround, disable the patreon integration and log out all users with associated Patreon accounts.", "other": {"cve": {"id": "CVE-2022-39355", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-26T20:15:10.660", "lastModified": "2022-10-28T19:39:56.920", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse Patreon enables syncronization between Discourse Groups and Patreon rewards. On sites with Patreon login enabled, an improper authentication vulnerability could be used to take control of a victim's forum account. This vulnerability is patched in commit number 846d012151514b35ce42a1636c7d70f6dcee879e of the discourse-patreon plugin. Out of an abundance of caution, any Discourse accounts which have logged in with an unverified-email Patreon account will be logged out and asked to verify their email address on their next login. As a workaround, disable the patreon integration and log out all users with associated Patreon accounts."}, {"lang": "es", "value": "Discourse Patreon permite la sincronizaci\u00f3n entre los grupos de Discourse y las recompensas de Patreon. En los sitios con el inicio de sesi\u00f3n de Patreon habilitado, una vulnerabilidad de autenticaci\u00f3n inapropiada podr\u00eda usarse para tomar el control de la cuenta del foro de la v\u00edctima. Esta vulnerabilidad est\u00e1 parcheada en el commit n\u00famero 846d0121514b35ce42a1636c7d70f6dcee879e del plugin discourse-patreon. Por precauci\u00f3n, cualquier cuenta de Discourse que haya iniciado sesi\u00f3n con una cuenta de Patreon con correo electr\u00f3nico no verificado ser\u00e1 cerrada y le pedir\u00e1 que verifique su direcci\u00f3n de correo electr\u00f3nico en su pr\u00f3ximo inicio de sesi\u00f3n. Como mitigaci\u00f3n, deshabilite la integraci\u00f3n de Patreon y cierre la sesi\u00f3n de todos los usuarios con cuentas de Patreon asociadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:patreon:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-10-26", "matchCriteriaId": "BF479D9A-B469-4D2B-9EFA-2AED58EA19E2"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-patreon/commit/846d012151514b35ce42a1636c7d70f6dcee879e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-patreon/security/advisories/GHSA-fvj9-f67v-qpr4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-patreon/commit/846d012151514b35ce42a1636c7d70f6dcee879e"}}