{"buggy_code": ["<template>\n  <v-container class=\"text-center\">\n    <v-row align=\"center\">\n      <v-col class=\"col-md-8 offset-md-2\">\n        <v-tabs\n          v-model=\"tabs1.tab\"\n          background-color=\"\"\n          class=\"elevation-2\"\n        >\n          <v-tabs-slider />\n\n          <v-tab\n            v-for=\"(t,i) in tabs1.tabs\"\n            :key=\"i\"\n            :href=\"`#tab-${i}`\"\n          >\n            <span class=\"caption text-capitalize\">{{ t.title }}</span>\n          </v-tab>\n\n          <v-tab-item\n            v-for=\"(t,i) in tabs1.tabs\"\n            :key=\"i\"\n            :value=\"'tab-' + i\"\n          >\n            <v-card\n              v-if=\"t.type==='password'\"\n              class=\"py-10 \"\n              flat\n              tile\n            >\n              <br>\n              <div v-if=\"isAdmin\">\n                <h1>You are an Admin too!</h1>\n                <h2 class=\"title is-2\">\n                  You are admin as well\n                </h2>\n                <router-link to=\"/user/admin\">\n                  User list\n                </router-link>\n              </div>\n\n              <v-row align=\"center\">\n                <v-col md=\"8\" offset-md=\"2\">\n                  <!--                  <p class=\"title\">\n                    Change Password\n                  </p>-->\n\n                  <div>\n                    <v-alert v-model=\"formUtil.formErr\" type=\"error\" dismissible>\n                      {{ formUtil.formErrMsg }}\n                    </v-alert>\n                  </div>\n\n                  <v-card class=\"pa-5 elevation-10\" color=\"\">\n                    <v-form ref=\"formType\" v-model=\"valid\" lazy-validation>\n                      <v-text-field\n                        v-model=\"passwordDetails.currentPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"Currrent password\"\n                        :append-icon=\"e3 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[0]\"\n                        :type=\"e3 ? 'password' : 'text'\"\n                        @click:append=\"() => (e3 = !e3)\"\n                      />\n\n                      <v-text-field\n                        v-model=\"passwordDetails.newPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"New password\"\n                        :append-icon=\"e4 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[1]\"\n                        :type=\"e4 ? 'password' : 'text'\"\n                        @click:append=\"() => (e4 = !e4)\"\n                      />\n\n                      <v-text-field\n                        v-model=\"passwordDetails.verifyPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"Confirm new password\"\n                        :append-icon=\"e5 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[2]\"\n                        :type=\"e5 ? 'password' : 'text'\"\n                        @click:append=\"() => (e5 = !e5)\"\n                      />\n\n                      <v-btn\n                        class=\"caption\"\n                        color=\"primary\"\n                        :disabled=\"!valid\"\n                        @click=\"resetUserPassword\"\n                      >\n                        SAVE PASSWORD\n                      </v-btn>\n                    </v-form>\n                  </v-card>\n                </v-col>\n              </v-row>\n            </v-card>\n          </v-tab-item>\n        </v-tabs>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script>\nimport { isEmail } from '@/helpers'\n\nexport default {\n  directives: {},\n  components: {},\n  validate({ params }) {\n    return true\n  },\n  props: {},\n  data() {\n    return {\n      user: {\n        provider: 'local'\n      },\n      tabs: 3,\n      tabs1: {\n        tab: null,\n        tabs: [{\n          type: 'password',\n          title: 'Change Password'\n        }\n        ]\n      },\n\n      subscriptions: [],\n\n      passwordDetails: {\n        newPassword: null,\n        verifyPassword: null,\n        currentPassword: null\n      },\n      formUtil: {\n        formErr: false,\n        formErrMsg: ''\n      },\n      e3: true,\n      e4: true,\n      e5: true,\n      valid: true,\n      formRules: {\n        email: [\n          // E-mail is required\n          v => !!v || this.$t('msg.error.signUpRules.emailReqd'),\n          // E-mail must be valid\n          v => isEmail(v) ||\n            this.$t('msg.error.signUpRules.emailInvalid')\n        ],\n        password: [\n          // Current Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired')\n          ],\n          // New Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired'),\n            // You password must be atleast 8 characters\n            v => (v && v.length >= 8) || this.$t('msg.error.signUpRules.passwdLength')\n          ],\n          // Confirm Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired'),\n            // TODO: i18n\n            v => v === this.passwordDetails.newPassword || 'Confirm password should match',\n            // You password must be atleast 8 characters\n            v => (v && v.length >= 8) || this.$t('msg.error.signUpRules.passwdLength')\n          ]\n        ]\n      }\n    }\n  },\n  head() {\n    return {}\n  },\n  computed: {\n    isAdmin() {\n      if (this.$store.state.users.user) {\n        // console.log(this.$store.state.users.user.roles.indexOf('creator'));\n        return 'creator' in this.$store.state.users.user.roles\n      }\n      return false\n    },\n\n    isEmailAuth() {\n      if (this.$store.state.users.user) {\n        // console.log(this.$store.state.users.user.roles.indexOf('creator'));\n        return (this.$store.state.users.user.provider === 'local')\n      }\n      return false\n    }\n\n  },\n  watch: {},\n  created() {\n  },\n  mounted() {\n    this.getSubscriptions()\n  },\n  beforeDestroy() {\n  },\n  methods: {\n    test() {\n      // console.log('test method');\n    },\n\n    async resetUserPassword(e) {\n      e.preventDefault()\n      if (this.$refs.formType[0].validate()) {\n        try {\n          await this.$api.auth.passwordChange(\n            {\n              currentPassword: this.passwordDetails.currentPassword,\n              newPassword: this.passwordDetails.newPassword\n            }\n          )\n          this.$toast.success('Password changed successfully.').goAway(3000)\n          this.$refs.formType[0].reset()\n        } catch (e) {\n          this.$toast\n            .error(await this._extractSdkResponseErrorMsg(e))\n            .goAway(3000);\n          return;\n        }\n      }\n    },\n\n    async getSubscriptions(e) {\n    }\n  },\n  beforeCreated() {\n  },\n  destroy() {\n  }\n}\n</script>\n\n<style scoped>\n\n</style>\n<!--\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n-->\n", "// import axios from 'axios';\n//\n// if (!window.axios) {\n//   window.axios = axios.create({\n//     baseURL: 'http://localhost:8080',\n//   });\n// }\n\nexport default ({ store, $axios, redirect, $toast, route, app }) => {\n  // Add a request interceptor\n  $axios.interceptors.request.use(function(config) {\n    config.headers['xc-gui'] = 'true'\n    if (store.state.users.token) {\n      config.headers['xc-auth'] = store.state.users.token\n    }\n    if (!config.url.endsWith('/user/me') && !config.url.endsWith('/admin/roles') && store.state.users.previewAs) {\n      config.headers['xc-preview'] = store.state.users.previewAs\n    }\n\n    if (!config.url.endsWith('/user/me') && !config.url.endsWith('/admin/roles')) {\n      if (app.context && app.context.route && app.context.route.params && app.context.route.params.shared_base_id) {\n        config.headers['xc-shared-base-id'] = app.context.route.params.shared_base_id\n      }\n    }\n\n    return config\n  })\n\n  // $axios.setBaseURL('http://localhost:8080')\n\n  $axios.interceptors.response.use((response) => {\n    // Return a successful response back to the calling service\n    return response\n  }, (error) => {\n    if (error.response && error.response.data && error.response.data.msg === 'Database config not found') {\n      redirect('/project/0')\n      return\n    }\n\n    // Return any error which is not due to authentication back to the calling service\n    if (!error.response || error.response.status !== 401) {\n      return new Promise((resolve, reject) => {\n        reject(error)\n      })\n    }\n\n    // Logout user if token refresh didn't work or user is disabled\n    if (error.config.url === '/auth/refresh-token') {\n      store.dispatch('users/ActSignOut')\n\n      return new Promise((resolve, reject) => {\n        reject(error)\n      })\n    }\n\n    // Try request again with new token\n    return $axios.post('/auth/refresh-token', null, {\n      withCredentials: true\n    })\n      .then((token) => {\n        // New request with new token\n        const config = error.config\n        config.headers['xc-auth'] = token.data.token\n        store.commit('users/MutSetToken', token.data.token)\n\n        return new Promise((resolve, reject) => {\n          $axios.request(config).then((response) => {\n            resolve(response)\n          }).catch((error) => {\n            reject(error)\n          })\n        })\n      })\n      .catch(async(error) => {\n        await store.dispatch('users/ActSignOut')\n        if (store.state.project.appInfo.firstUser) {\n          redirect('/')\n        } else {\n          $toast.clear()\n          $toast.info('Token expired please login to continue', {\n            position: 'bottom-center'\n          }).goAway(5000)\n          redirect('/user/authentication/signin')\n        }\n        Promise.reject(error)\n      })\n  })\n}\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import User from '../../../models/User';\nimport ProjectUser from '../../../models/ProjectUser';\nimport { promisify } from 'util';\nimport { Strategy as CustomStrategy } from 'passport-custom';\n\nimport { Strategy } from 'passport-jwt';\nimport passport from 'passport';\nimport { ExtractJwt } from 'passport-jwt';\nimport { Strategy as AuthTokenStrategy } from 'passport-auth-token';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\n\nconst PassportLocalStrategy = require('passport-local').Strategy;\n\nconst jwtOptions = {\n  expiresIn: process.env.NC_JWT_EXPIRES_IN ?? '10h',\n  jwtFromRequest: ExtractJwt.fromHeader('xc-auth')\n};\n\nimport bcrypt from 'bcryptjs';\nimport Project from '../../../models/Project';\nimport NocoCache from '../../../cache/NocoCache';\nimport { CacheGetType, CacheScope } from '../../../utils/globals';\nimport ApiToken from '../../../models/ApiToken';\nimport Noco from '../../../Noco';\nimport Plugin from '../../../models/Plugin';\n\nexport function initStrategies(router): void {\n  passport.use(\n    'authtoken',\n    new AuthTokenStrategy({ headerFields: ['xc-token'] }, (token, done) => {\n      ApiToken.getByToken(token)\n        .then(apiToken => {\n          if (apiToken) {\n            done(null, { roles: 'editor' });\n          } else {\n            return done({ msg: 'Invalid tok' });\n          }\n        })\n        .catch(e => {\n          console.log(e);\n          done({ msg: 'Invalid tok' });\n        });\n    })\n  );\n\n  passport.serializeUser(function(\n    {\n      id,\n      email,\n      email_verified,\n      roles: _roles,\n      provider,\n      firstname,\n      lastname,\n      isAuthorized,\n      isPublicBase\n    },\n    done\n  ) {\n    const roles = (_roles || '')\n      .split(',')\n      .reduce((obj, role) => Object.assign(obj, { [role]: true }), {});\n    if (roles.owner) {\n      roles.creator = true;\n    }\n    done(null, {\n      isAuthorized,\n      isPublicBase,\n      id,\n      email,\n      email_verified,\n      provider,\n      firstname,\n      lastname,\n      roles\n    });\n  });\n\n  passport.deserializeUser(function(user, done) {\n    done(null, user);\n  });\n\n  passport.use(\n    new Strategy(\n      {\n        secretOrKey: Noco.getConfig().auth.jwt.secret,\n        ...jwtOptions,\n        passReqToCallback: true,\n        ...Noco.getConfig().auth.jwt.options\n      },\n      async (req, jwtPayload, done) => {\n        const keyVals = [jwtPayload?.email];\n        if (req.ncProjectId) {\n          keyVals.push(req.ncProjectId);\n        }\n        const key = keyVals.join('___');\n        const cachedVal = await NocoCache.get(\n          `${CacheScope.USER}:${key}`,\n          CacheGetType.TYPE_OBJECT\n        );\n\n        if (cachedVal) {\n          return done(null, cachedVal);\n        }\n\n        User.getByEmail(jwtPayload?.email)\n          .then(async user => {\n            if (req.ncProjectId) {\n              // this.xcMeta\n              //   .metaGet(req.ncProjectId, null, 'nc_projects_users', {\n              //     user_id: user?.id\n              //   })\n\n              ProjectUser.get(req.ncProjectId, user.id)\n                .then(async projectUser => {\n                  user.roles = projectUser?.roles || 'user';\n                  user.roles =\n                    user.roles === 'owner' ? 'owner,creator' : user.roles;\n                  // + (user.roles ? `,${user.roles}` : '');\n\n                  await NocoCache.set(`${CacheScope.USER}:${key}`, user);\n                  done(null, user);\n                })\n                .catch(e => done(e));\n            } else {\n              // const roles = projectUser?.roles ? JSON.parse(projectUser.roles) : {guest: true};\n              if (user) {\n                await NocoCache.set(`${CacheScope.USER}:${key}`, user);\n                return done(null, user);\n              } else {\n                return done(new Error('User not found'));\n              }\n            }\n          })\n          .catch(err => {\n            return done(err);\n          });\n      }\n    )\n  );\n\n  passport.use(\n    new PassportLocalStrategy(\n      {\n        usernameField: 'email',\n        session: false\n      },\n      async (email, password, done) => {\n        try {\n          const user = await User.getByEmail(email);\n          if (!user) {\n            return done({ msg: `Email ${email} is not registered!` });\n          }\n          const hashedPassword = await promisify(bcrypt.hash)(\n            password,\n            user.salt\n          );\n          if (user.password !== hashedPassword) {\n            return done({ msg: `Password not valid!` });\n          } else {\n            return done(null, user);\n          }\n        } catch (e) {\n          done(e);\n        }\n      }\n    )\n  );\n\n  passport.use(\n    'baseView',\n    new CustomStrategy(async (req: any, callback) => {\n      let user;\n      if (req.headers['xc-shared-base-id']) {\n        // const cacheKey = `nc_shared_bases||${req.headers['xc-shared-base-id']}`;\n\n        let sharedProject = null;\n\n        if (!sharedProject) {\n          sharedProject = await Project.getByUuid(\n            req.headers['xc-shared-base-id']\n          );\n        }\n        user = {\n          roles: sharedProject?.roles\n        };\n      }\n\n      callback(null, user);\n    })\n  );\n\n  // mostly copied from older code\n  Plugin.getPluginByTitle('Google').then(googlePlugin => {\n    if (googlePlugin && googlePlugin.input) {\n      const settings = JSON.parse(googlePlugin.input);\n      process.env.NC_GOOGLE_CLIENT_ID = settings.client_id;\n      process.env.NC_GOOGLE_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GOOGLE_CLIENT_ID &&\n      process.env.NC_GOOGLE_CLIENT_SECRET\n    ) {\n      const googleAuthParamsOrig = GoogleStrategy.prototype.authorizationParams;\n      GoogleStrategy.prototype.authorizationParams = (options: any) => {\n        const params = googleAuthParamsOrig.call(this, options);\n\n        if (options.state) {\n          params.state = options.state;\n        }\n\n        return params;\n      };\n\n      const clientConfig = {\n        clientID: process.env.NC_GOOGLE_CLIENT_ID,\n        clientSecret: process.env.NC_GOOGLE_CLIENT_SECRET,\n        // todo: update url\n        callbackURL: 'http://localhost:3000',\n        passReqToCallback: true\n      };\n\n      const googleStrategy = new GoogleStrategy(\n        clientConfig,\n        async (req, _accessToken, _refreshToken, profile, done) => {\n          const email = profile.emails[0].value;\n\n          User.getByEmail(email)\n            .then(async user => {\n              if (req.ncProjectId) {\n                ProjectUser.get(req.ncProjectId, user.id)\n                  .then(async projectUser => {\n                    user.roles = projectUser?.roles || 'user';\n                    user.roles =\n                      user.roles === 'owner' ? 'owner,creator' : user.roles;\n                    // + (user.roles ? `,${user.roles}` : '');\n\n                    done(null, user);\n                  })\n                  .catch(e => done(e));\n              } else {\n                // const roles = projectUser?.roles ? JSON.parse(projectUser.roles) : {guest: true};\n                if (user) {\n                  return done(null, user);\n                } else {\n                  let roles = 'editor';\n\n                  if (!(await User.isFirst())) {\n                    roles = 'owner';\n                  }\n                  if (roles === 'editor') {\n                    return done(new Error('User not found'));\n                  }\n                  const salt = await promisify(bcrypt.genSalt)(10);\n                  user = await await User.insert({\n                    email: profile.emails[0].value,\n                    password: '',\n                    salt,\n                    roles,\n                    email_verified: true\n                  });\n                  return done(null, user);\n                }\n              }\n            })\n            .catch(err => {\n              return done(err);\n            });\n        }\n      );\n\n      passport.use(googleStrategy);\n    }\n  });\n\n  router.use(passport.initialize());\n}\n", "import { Request, Response } from 'express';\nimport { TableType } from 'nocodb-sdk';\nimport catchError, { NcError } from '../../helpers/catchError';\nconst { isEmail } = require('validator');\nimport * as ejs from 'ejs';\n\nimport bcrypt from 'bcryptjs';\nimport { promisify } from 'util';\nimport User from '../../../models/User';\nimport { Tele } from 'nc-help';\n\nconst { v4: uuidv4 } = require('uuid');\nimport * as jwt from 'jsonwebtoken';\nimport Audit from '../../../models/Audit';\nimport crypto from 'crypto';\nimport NcPluginMgrv2 from '../../helpers/NcPluginMgrv2';\n\nimport passport from 'passport';\nimport extractProjectIdAndAuthenticate from '../../helpers/extractProjectIdAndAuthenticate';\nimport ncMetaAclMw from '../../helpers/ncMetaAclMw';\nimport { MetaTable } from '../../../utils/globals';\nimport Noco from '../../../Noco';\n\nexport async function signup(req: Request, res: Response<TableType>) {\n  const {\n    email: _email,\n    firstname,\n    lastname,\n    token,\n    ignore_subscribe\n  } = req.body;\n  let { password } = req.body;\n\n  if (!isEmail(_email)) {\n    NcError.badRequest(`Invalid email`);\n  }\n\n  const email = _email.toLowerCase();\n\n  let user = await User.getByEmail(email);\n\n  if (user) {\n    if (token) {\n      if (token !== user.invite_token) {\n        NcError.badRequest(`Invalid invite url`);\n      } else if (user.invite_token_expires < new Date()) {\n        NcError.badRequest(\n          'Expired invite url, Please contact super admin to get a new invite url'\n        );\n      }\n    } else {\n      // todo : opening up signup for timebeing\n      // return next(new Error(`Email '${email}' already registered`));\n    }\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  password = await promisify(bcrypt.hash)(password, salt);\n  const email_verification_token = uuidv4();\n\n  if (!ignore_subscribe) {\n    Tele.emit('evt_subscribe', email);\n  }\n\n  if (user) {\n    if (token) {\n      await User.update(user.id, {\n        firstname,\n        lastname,\n        salt,\n        password,\n        email_verification_token,\n        invite_token: null,\n        invite_token_expires: null\n      });\n    } else {\n      NcError.badRequest('User already exist');\n    }\n  } else {\n    let roles = 'user';\n\n    if (await User.isFirst()) {\n      roles = 'user,super';\n      // todo: update in nc_store\n      // roles = 'owner,creator,editor'\n      Tele.emit('evt', {\n        evt_type: 'project:invite',\n        count: 1\n      });\n    } else {\n      if (process.env.NC_INVITE_ONLY_SIGNUP) {\n        NcError.badRequest('Not allowed to signup, contact super admin.');\n      } else {\n        roles = 'user_new';\n      }\n    }\n\n    await User.insert({\n      firstname,\n      lastname,\n      email,\n      salt,\n      password,\n      email_verification_token,\n      roles\n    });\n  }\n  user = await User.getByEmail(email);\n\n  try {\n    const template = (await import('./ui/emailTemplates/verify')).default;\n    await (await NcPluginMgrv2.emailAdapter()).mailSend({\n      to: email,\n      subject: 'Verify email',\n      html: ejs.render(template, {\n        verifyLink:\n          (req as any).ncSiteUrl +\n          `/email/verify/${user.email_verification_token}`\n      })\n    });\n  } catch (e) {\n    console.log(\n      'Warning : `mailSend` failed, Please configure emailClient configuration.'\n    );\n  }\n  await promisify((req as any).login.bind(req))(user);\n  const refreshToken = randomTokenString();\n  await User.update(user.id, {\n    refresh_token: refreshToken\n  });\n\n  setTokenCookie(res, refreshToken);\n\n  user = (req as any).user;\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'SIGNUP',\n    user: user.email,\n    description: `signed up `,\n    ip: (req as any).clientIp\n  });\n\n  res.json({\n    token: jwt.sign(\n      {\n        email: user.email,\n        firstname: user.firstname,\n        lastname: user.lastname,\n        id: user.id,\n        roles: user.roles\n      },\n      Noco.getConfig().auth.jwt.secret,\n      Noco.getConfig().auth.jwt.options\n    )\n  } as any);\n}\n\nasync function successfulSignIn({\n  user,\n  err,\n  info,\n  req,\n  res,\n  auditDescription\n}) {\n  try {\n    if (!user || !user.email) {\n      if (err) {\n        return res.status(400).send(err);\n      }\n      if (info) {\n        return res.status(400).send(info);\n      }\n      return res.status(400).send({ msg: 'Your signin has failed' });\n    }\n\n    await promisify((req as any).login.bind(req))(user);\n    const refreshToken = randomTokenString();\n\n    await User.update(user.id, {\n      refresh_token: refreshToken\n    });\n    setTokenCookie(res, refreshToken);\n\n    Audit.insert({\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'SIGNIN',\n      user: user.email,\n      ip: req.clientIp,\n      description: auditDescription\n    });\n\n    res.json({\n      token: jwt.sign(\n        {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n          id: user.id,\n          roles: user.roles\n        },\n\n        Noco.getConfig().auth.jwt.secret,\n        Noco.getConfig().auth.jwt.options\n      )\n    } as any);\n  } catch (e) {\n    console.log(e);\n    throw e;\n  }\n}\n\nasync function signin(req, res, next) {\n  passport.authenticate(\n    'local',\n    { session: false },\n    async (err, user, info): Promise<any> =>\n      await successfulSignIn({\n        user,\n        err,\n        info,\n        req,\n        res,\n        auditDescription: 'signed in'\n      })\n  )(req, res, next);\n}\n\nasync function googleSignin(req, res, next) {\n  passport.authenticate(\n    'google',\n    {\n      session: false,\n      callbackURL: req.ncSiteUrl + Noco.getConfig().dashboardPath\n    },\n    async (err, user, info): Promise<any> =>\n      await successfulSignIn({\n        user,\n        err,\n        info,\n        req,\n        res,\n        auditDescription: 'signed in using Google Auth'\n      })\n  )(req, res, next);\n}\n\nfunction randomTokenString(): string {\n  return crypto.randomBytes(40).toString('hex');\n}\nfunction setTokenCookie(res, token): void {\n  // create http only cookie with refresh token that expires in 7 days\n  const cookieOptions = {\n    httpOnly: true,\n    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n  };\n  res.cookie('refresh_token', token, cookieOptions);\n}\n\nasync function me(req, res): Promise<any> {\n  res.json(req?.session?.passport?.user ?? {});\n}\n\nasync function passwordChange(req: Request<any, any>, res): Promise<any> {\n  if (!(req as any).isAuthenticated()) {\n    NcError.forbidden('Not allowed');\n  }\n  const { currentPassword, newPassword } = req.body;\n  if (!currentPassword || !newPassword) {\n    return NcError.badRequest('Missing new/old password');\n  }\n  const user = await User.getByEmail((req as any).user.email);\n  const hashedPassword = await promisify(bcrypt.hash)(\n    currentPassword,\n    user.salt\n  );\n  if (hashedPassword !== user.password) {\n    return NcError.badRequest('Current password is wrong');\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  const password = await promisify(bcrypt.hash)(newPassword, salt);\n\n  await User.update(user.id, {\n    salt,\n    password,\n    email: user.email\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'PASSWORD_CHANGE',\n    user: user.email,\n    description: `changed password `,\n    ip: (req as any).clientIp\n  });\n\n  res.json({ msg: 'Password updated successfully' });\n}\n\nasync function passwordForgot(req: Request<any, any>, res): Promise<any> {\n  const _email = req.body.email;\n  if (!_email) {\n    NcError.badRequest('Please enter your email address.');\n  }\n\n  const email = _email.toLowerCase();\n  const user = await User.getByEmail(email);\n\n  if (user) {\n    const token = uuidv4();\n    await User.update(user.id, {\n      reset_password_token: token,\n      reset_password_expires: new Date(Date.now() + 60 * 60 * 1000)\n    });\n    try {\n      const template = (await import('./ui/emailTemplates/forgotPassword'))\n        .default;\n      await NcPluginMgrv2.emailAdapter().then(adapter =>\n        adapter.mailSend({\n          to: user.email,\n          subject: 'Password Reset Link',\n          text: `Visit following link to update your password : ${\n            (req as any).ncSiteUrl\n          }/api/v1/db/auth/password/reset/${token}.`,\n          html: ejs.render(template, {\n            resetLink:\n              (req as any).ncSiteUrl + `/api/v1/db/auth/password/reset/${token}`\n          })\n        })\n      );\n    } catch (e) {\n      console.log(e);\n      return NcError.badRequest(\n        'Email Plugin is not found. Please contact administrators to configure it in App Store first.'\n      );\n    }\n\n    Audit.insert({\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'PASSWORD_FORGOT',\n      user: user.email,\n      description: `requested for password reset `,\n      ip: (req as any).clientIp\n    });\n  } else {\n    return NcError.badRequest('Your email has not been registered.');\n  }\n  res.json({ msg: 'Please check your email to reset the password' });\n}\n\nasync function tokenValidate(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    reset_password_token: token\n  });\n\n  if (!user || !user.email) {\n    NcError.badRequest('Invalid reset url');\n  }\n  if (user.reset_password_expires < new Date()) {\n    NcError.badRequest('Password reset url expired');\n  }\n  res.json(true);\n}\n\nasync function passwordReset(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    reset_password_token: token\n  });\n\n  if (!user) {\n    NcError.badRequest('Invalid reset url');\n  }\n  if (user.reset_password_expires < new Date()) {\n    NcError.badRequest('Password reset url expired');\n  }\n  if (user.provider && user.provider !== 'local') {\n    NcError.badRequest('Email registered via social account');\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  const password = await promisify(bcrypt.hash)(req.body.password, salt);\n\n  await User.update(user.id, {\n    salt,\n    password,\n    reset_password_expires: null,\n    reset_password_token: ''\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'PASSWORD_RESET',\n    user: user.email,\n    description: `did reset password `,\n    ip: req.clientIp\n  });\n\n  res.json({ msg: 'Password reset successful' });\n}\n\nasync function emailVerification(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    email_verification_token: token\n  });\n\n  if (!user) {\n    NcError.badRequest('Invalid verification url');\n  }\n\n  await User.update(user.id, {\n    email_verification_token: '',\n    email_verified: true\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'EMAIL_VERIFICATION',\n    user: user.email,\n    description: `verified email `,\n    ip: req.clientIp\n  });\n\n  res.json({ msg: 'Email verified successfully' });\n}\n\nasync function refreshToken(req, res): Promise<any> {\n  try {\n    if (!req?.cookies?.refresh_token) {\n      return res.status(400).json({ msg: 'Missing refresh token' });\n    }\n\n    const user = await User.getByRefreshToken(req.cookies.refresh_token);\n\n    if (!user) {\n      return res.status(400).json({ msg: 'Invalid refresh token' });\n    }\n\n    const refreshToken = randomTokenString();\n\n    await User.update(user.id, {\n      refresh_token: refreshToken\n    });\n\n    setTokenCookie(res, refreshToken);\n\n    res.json({\n      token: jwt.sign(\n        {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n          id: user.id,\n          roles: user.roles\n        },\n        Noco.getConfig().auth.jwt.secret,\n        Noco.getConfig().auth.jwt.options\n      )\n    } as any);\n  } catch (e) {\n    return res.status(400).json({ msg: e.message });\n  }\n}\n\nasync function renderPasswordReset(req, res): Promise<any> {\n  try {\n    res.send(\n      ejs.render((await import('./ui/auth/resetPassword')).default, {\n        token: JSON.stringify(req.params.tokenId),\n        baseUrl: `/`\n      })\n    );\n  } catch (e) {\n    return res.status(400).json({ msg: e.message });\n  }\n}\n\nconst mapRoutes = router => {\n  // todo: old api - /auth/signup?tool=1\n  router.post('/auth/user/signup', catchError(signup));\n  router.post('/auth/user/signin', catchError(signin));\n  router.get('/auth/user/me', extractProjectIdAndAuthenticate, catchError(me));\n  router.post('/auth/password/forgot', catchError(passwordForgot));\n  router.post('/auth/token/validate/:tokenId', catchError(tokenValidate));\n  router.post('/auth/password/reset/:tokenId', catchError(passwordReset));\n  router.post('/auth/email/validate/:tokenId', catchError(emailVerification));\n  router.post(\n    '/user/password/change',\n    ncMetaAclMw(passwordChange, 'passwordChange')\n  );\n  router.post('/auth/token/refresh', ncMetaAclMw(refreshToken, 'refreshToken'));\n\n  /* Google auth apis */\n\n  router.post(`/auth/google/genTokenByCode`, catchError(googleSignin));\n\n  router.get('/auth/google', (req: any, res, next) =>\n    passport.authenticate('google', {\n      scope: ['profile', 'email'],\n      state: req.query.state,\n      callbackURL: req.ncSiteUrl + Noco.getConfig().dashboardPath\n    })(req, res, next)\n  );\n\n  // new API\n  router.post('/api/v1/db/auth/user/signup', catchError(signup));\n  router.post('/api/v1/db/auth/user/signin', catchError(signin));\n  router.get(\n    '/api/v1/db/auth/user/me',\n    extractProjectIdAndAuthenticate,\n    catchError(me)\n  );\n  router.post('/api/v1/db/auth/password/forgot', catchError(passwordForgot));\n  router.post(\n    '/api/v1/db/auth/token/validate/:tokenId',\n    catchError(tokenValidate)\n  );\n  router.post(\n    '/api/v1/db/auth/password/reset/:tokenId',\n    catchError(passwordReset)\n  );\n  router.post(\n    '/api/v1/db/auth/email/validate/:tokenId',\n    catchError(emailVerification)\n  );\n  router.post(\n    '/api/v1/db/auth/password/change',\n    ncMetaAclMw(passwordChange, 'passwordChange')\n  );\n  router.post(\n    '/api/v1/db/auth/token/refresh',\n    ncMetaAclMw(refreshToken, 'refreshToken')\n  );\n  router.get(\n    '/api/v1/db/auth/password/reset/:tokenId',\n    catchError(renderPasswordReset)\n  );\n};\nexport { mapRoutes as userApis };\n", "import projectAcl from '../../utils/projectAcl';\nimport { NextFunction, Request, Response } from 'express';\nimport catchError, { NcError } from './catchError';\nimport extractProjectIdAndAuthenticate from './extractProjectIdAndAuthenticate';\nexport default function(handlerFn, permissionName) {\n  return [\n    extractProjectIdAndAuthenticate,\n    catchError(function authMiddleware(req, _res, next) {\n      const roles = req?.session?.passport?.user?.roles;\n      if (\n        !(\n          roles?.creator ||\n          roles?.owner ||\n          roles?.editor ||\n          roles?.viewer ||\n          roles?.commenter ||\n          roles?.user ||\n          roles?.user_new\n        )\n      ) {\n        NcError.unauthorized('Unauthorized access');\n      }\n      next();\n    }),\n    // @ts-ignore\n    catchError(async function projectAclMiddleware(\n      req: Request<any, any, any, any, any>,\n      _res: Response,\n      next: NextFunction\n    ) {\n      // if (req['files'] && req.body.json) {\n      //   req.body = JSON.parse(req.body.json);\n      // }\n      // if (req['session']?.passport?.user?.isAuthorized) {\n      //   if (\n      //     req?.body?.project_id &&\n      //     !req['session']?.passport?.user?.isPublicBase &&\n      //     !(await this.xcMeta.isUserHaveAccessToProject(\n      //       req?.body?.project_id,\n      //       req['session']?.passport?.user?.id\n      //     ))\n      //   ) {\n      //     return res\n      //       .status(403)\n      //       .json({ msg: \"User doesn't have project access\" });\n      //   }\n      //\n      //   if (req?.body?.api) {\n\n      // todo : verify user have access to project or not\n\n      const roles = req['session']?.passport?.user?.roles;\n      const isAllowed =\n        roles &&\n        Object.entries(roles).some(([name, hasRole]) => {\n          return (\n            hasRole &&\n            projectAcl[name] &&\n            (projectAcl[name] === '*' || projectAcl[name][permissionName])\n          );\n        });\n      if (!isAllowed) {\n        NcError.forbidden(\n          `${permissionName} - ${Object.keys(roles).filter(\n            k => roles[k]\n          )} : Not allowed`\n        );\n      }\n      //   }\n      // }\n      next();\n    }),\n    catchError(handlerFn)\n  ];\n}\n", "import * as nc_011 from './v2/nc_011';\nimport * as nc_012_alter_column_data_types from './v2/nc_012_alter_column_data_types';\nimport * as nc_013_sync_source from './v2/nc_013_sync_source';\nimport * as nc_014_alter_column_data_types from './v2/nc_014_alter_column_data_types';\nimport * as nc_015_add_meta_col_in_column_table from './v2/nc_015_add_meta_col_in_column_table';\nimport * as nc_016_alter_hooklog_payload_types from './v2/nc_016_alter_hooklog_payload_types';\n\n// Create a custom migration source class\nexport default class XcMigrationSourcev2 {\n  // Must return a Promise containing a list of migrations.\n  // Migrations can be whatever you want, they will be passed as\n  // arguments to getMigrationName and getMigration\n  public getMigrations(): Promise<any> {\n    // In this run we are just returning migration names\n    return Promise.resolve([\n      'nc_011',\n      'nc_012_alter_column_data_types',\n      'nc_013_sync_source',\n      'nc_014_alter_column_data_types',\n      'nc_015_add_meta_col_in_column_table',\n      'nc_016_alter_hooklog_payload_types'\n    ]);\n  }\n\n  public getMigrationName(migration): string {\n    return migration;\n  }\n\n  public getMigration(migration): any {\n    switch (migration) {\n      case 'nc_011':\n        return nc_011;\n      case 'nc_012_alter_column_data_types':\n        return nc_012_alter_column_data_types;\n      case 'nc_013_sync_source':\n        return nc_013_sync_source;\n      case 'nc_014_alter_column_data_types':\n        return nc_014_alter_column_data_types;\n      case 'nc_015_add_meta_col_in_column_table':\n        return nc_015_add_meta_col_in_column_table;\n      case 'nc_016_alter_hooklog_payload_types':\n        return nc_016_alter_hooklog_payload_types;\n    }\n  }\n}\n\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "Couldn't find the requested file /packages/nocodb/src/lib/migrations/v2/nc_017_add_user_token_version_column.ts in nocodb/nocodb.", "import { UserType } from 'nocodb-sdk';\nimport { CacheGetType, CacheScope, MetaTable } from '../utils/globals';\nimport Noco from '../Noco';\nimport extractProps from '../meta/helpers/extractProps';\nimport NocoCache from '../cache/NocoCache';\nexport default class User implements UserType {\n  id: number;\n\n  /** @format email */\n  email: string;\n\n  password?: string;\n  salt?: string;\n  firstname: string;\n  lastname: string;\n  username?: string;\n  refresh_token?: string;\n  invite_token?: string;\n  invite_token_expires?: number | Date;\n  reset_password_expires?: number | Date;\n  reset_password_token?: string;\n  email_verification_token?: string;\n  email_verified: boolean;\n  roles?: string;\n\n  constructor(data: User) {\n    Object.assign(this, data);\n  }\n\n  public static async insert(user: Partial<User>, ncMeta = Noco.ncMeta) {\n    const insertObj = extractProps(user, [\n      'id',\n      'email',\n      'password',\n      'salt',\n      'firstname',\n      'lastname',\n      'username',\n      'refresh_token',\n      'invite_token',\n      'invite_token_expires',\n      'reset_password_expires',\n      'reset_password_token',\n      'email_verification_token',\n      'email_verified',\n      'roles'\n    ]);\n    const { id } = await ncMeta.metaInsert2(\n      null,\n      null,\n      MetaTable.USERS,\n      insertObj\n    );\n\n    await NocoCache.del(CacheScope.INSTANCE_META);\n\n    return this.get(id, ncMeta);\n  }\n  public static async update(id, user: Partial<User>, ncMeta = Noco.ncMeta) {\n    const updateObj = extractProps(user, [\n      'email',\n      'password',\n      'salt',\n      'firstname',\n      'lastname',\n      'username',\n      'refresh_token',\n      'invite_token',\n      'invite_token_expires',\n      'reset_password_expires',\n      'reset_password_token',\n      'email_verification_token',\n      'email_verified',\n      'roles'\n    ]);\n    // get existing cache\n    const keys = [\n      // update user:<id>\n      `${CacheScope.USER}:${id}`,\n      // update user:<email>\n      `${CacheScope.USER}:${user.email}`\n    ];\n    for (const key of keys) {\n      let o = await NocoCache.get(key, CacheGetType.TYPE_OBJECT);\n      if (o) {\n        o = { ...o, ...updateObj };\n        // set cache\n        await NocoCache.set(key, o);\n      }\n    }\n    // as <projectId> is unknown, delete user:<email>___<projectId> in cache\n    await NocoCache.delAll(CacheScope.USER, `${user.email}___*`);\n\n    // set meta\n    return await ncMeta.metaUpdate(null, null, MetaTable.USERS, updateObj, id);\n  }\n  public static async getByEmail(email, ncMeta = Noco.ncMeta) {\n    let user =\n      email &&\n      (await NocoCache.get(\n        `${CacheScope.USER}:${email}`,\n        CacheGetType.TYPE_OBJECT\n      ));\n    if (!user) {\n      user = await ncMeta.metaGet2(null, null, MetaTable.USERS, {\n        email\n      });\n      await NocoCache.set(`${CacheScope.USER}:${email}`, user);\n    }\n    return user;\n  }\n\n  static async isFirst(ncMeta = Noco.ncMeta) {\n    const isFirst = !(await NocoCache.getAll(`${CacheScope.USER}:*`))?.length;\n    if (isFirst)\n      return !(await ncMeta.metaGet2(null, null, MetaTable.USERS, {}));\n    return false;\n  }\n\n  static async count(ncMeta = Noco.ncMeta) {\n    return (\n      await ncMeta\n        .knex(MetaTable.USERS)\n        .count('id', { as: 'count' })\n        .first()\n    )?.count;\n  }\n\n  static async get(userId, ncMeta = Noco.ncMeta) {\n    let user =\n      userId &&\n      (await NocoCache.get(\n        `${CacheScope.USER}:${userId}`,\n        CacheGetType.TYPE_OBJECT\n      ));\n    if (!user) {\n      user = await ncMeta.metaGet2(null, null, MetaTable.USERS, userId);\n      await NocoCache.set(`${CacheScope.USER}:${userId}`, user);\n    }\n    return user;\n  }\n\n  static async getByRefreshToken(refresh_token, ncMeta = Noco.ncMeta) {\n    const user = await ncMeta.metaGet2(null, null, MetaTable.USERS, {\n      refresh_token\n    });\n    return user;\n  }\n}\n", "import { promisify } from 'util';\n\nimport bcrypt from 'bcryptjs';\nimport * as ejs from 'ejs';\nimport * as jwt from 'jsonwebtoken';\nimport { Tele } from 'nc-help';\nimport passport from 'passport';\nimport { Strategy as AuthTokenStrategy } from 'passport-auth-token';\nimport { Strategy as GithubStrategy } from 'passport-github';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport validator from 'validator';\n\nimport { DbConfig, NcConfig } from '../../../interface/config';\nimport { Knex } from '../../db/sql-data-mapper';\nimport Noco from '../../Noco';\n\nconst autoBind = require('auto-bind');\nconst PassportLocalStrategy = require('passport-local').Strategy;\nimport { Strategy as CustomStrategy } from 'passport-custom';\n\nconst { v4: uuidv4 } = require('uuid');\n\nimport * as crypto from 'crypto';\n\nimport NcMetaIO from '../../meta/NcMetaIO';\n\nconst { isEmail } = require('validator');\n\nimport axios from 'axios';\n\nimport IEmailAdapter from '../../../interface/IEmailAdapter';\nimport XcCache from '../plugins/adapters/cache/XcCache';\n\npassport.serializeUser(function(\n  {\n    id,\n    email,\n    email_verified,\n    roles: _roles,\n    provider,\n    firstname,\n    lastname,\n    isAuthorized,\n    isPublicBase\n  },\n  done\n) {\n  const roles = (_roles || '')\n    .split(',')\n    .reduce((obj, role) => Object.assign(obj, { [role]: true }), {});\n  if (roles.owner) {\n    roles.creator = true;\n  }\n  done(null, {\n    isAuthorized,\n    isPublicBase,\n    id,\n    email,\n    email_verified,\n    provider,\n    firstname,\n    lastname,\n    roles\n  });\n});\n\npassport.deserializeUser(function(user, done) {\n  done(null, user);\n});\n\nconst NC_ROLES = 'nc_roles';\nconst NC_ACL = 'nc_acl';\nexport default class RestAuthCtrl {\n  protected app: Noco;\n\n  protected dbDriver: Knex;\n  // @ts-ignore\n  protected connectionConfig: DbConfig;\n  protected config: NcConfig;\n\n  protected jwtOptions: any;\n\n  protected xcMeta: NcMetaIO;\n\n  public static instance: RestAuthCtrl;\n\n  protected apiTokens: Array<{\n    token: string;\n    [key: string]: any;\n  }>;\n\n  // private router:Router;\n\n  constructor(\n    app: Noco,\n    dbDriver: Knex,\n    connectionConfig: DbConfig,\n    config: NcConfig,\n    xcMeta?: NcMetaIO\n  ) {\n    this.app = app;\n    this.dbDriver = dbDriver;\n    this.connectionConfig = connectionConfig;\n    this.config = config;\n    this.xcMeta = xcMeta;\n    autoBind(this);\n    // todo: default secret generation\n    this.config.auth.jwt.secret = this.config?.auth?.jwt?.secret ?? 'secret';\n    this.jwtOptions = {\n      secretOrKey: this.config.auth.jwt.secret,\n      expiresIn: process.env.NC_JWT_EXPIRES_IN ?? '10h'\n    };\n    this.jwtOptions.jwtFromRequest = ExtractJwt.fromHeader('xc-auth');\n    if (this.config?.auth?.jwt?.options) {\n      Object.assign(this.jwtOptions, this.config?.auth?.jwt?.options);\n    }\n    // this.router = Router();\n    RestAuthCtrl.instance = this;\n  }\n\n  get users(): any {\n    return this.dbDriver('xc_users');\n  }\n\n  async init() {\n    await this.loadLatestApiTokens();\n    await this.createAuthTableIfNotExists();\n\n    await this.initStrategies();\n    Tele.emit('evt_app_started', await this.users.count('id as count').first());\n    this.app.router.use(passport.initialize());\n\n    const jwtMiddleware = passport.authenticate('jwt', { session: false });\n\n    this.app.router.get('/password/reset/:token', async function(req, res) {\n      res.send(\n        ejs.render((await import('./ui/auth/resetPassword')).default, {\n          token: JSON.stringify(req.params?.token),\n          baseUrl: `/`\n        })\n      );\n    });\n    this.app.router.get('/email/verify/:token', async (req, res) => {\n      res.send(\n        ejs.render((await import('./ui/auth/emailVerify')).default, {\n          token: JSON.stringify(req.params?.token),\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.get('/signin', async (_req, res) => {\n      res.send(\n        ejs.render((await import('./ui/auth/signin')).default, {\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.get('/signup', async (_req, res) => {\n      res.render(\n        ejs.render((await import('./ui/auth/signup')).default, {\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.post(`/auth/signin`, this.signin);\n\n    this.app.router.post(`/auth/signup`, this.signup);\n    this.app.router.post(`/auth/refresh-token`, this.refreshToken);\n\n    /* Google auth apis */\n\n    this.app.router.post(`/auth/google/genTokenByCode`, this.googleSignin);\n\n    this.app.router.get('/auth/google', (req: any, res, next) =>\n      passport.authenticate('google', {\n        scope: ['profile', 'email'],\n        state: req.query.state,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      })(req, res, next)\n    );\n    /* Github auth apis */\n\n    this.app.router.post(`/auth/github/genTokenByCode`, this.githubSignin);\n\n    this.app.router.get('/auth/github', (req: any, res, next) =>\n      passport.authenticate('github', {\n        scope: ['profile', 'email'],\n        state: `github|${req.query.state || ''}`,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      })(req, res, next)\n    );\n\n    /*\n        this.app.router.get('/auth/azureadoauth2',\n          passport.authenticate('azure_ad_oauth2'));\n\n        this.app.router.get('/auth/azureadoauth2/callback',\n          passport.authenticate('azure_ad_oauth2', { failureRedirect: '/login' }),\n           (_req, res) => {\n            // Successful authentication, redirect home.\n            res.redirect('/');\n          });\n    */\n\n    this.app.router.post(`/auth/password/forgot`, this.passwordForgot);\n    this.app.router.post(`/auth/token/validate/:tokenId`, this.tokenValidate);\n    this.app.router.post(`/auth/password/reset/:tokenId`, this.passwordReset);\n    this.app.router.post(\n      `/user/password/change`,\n      jwtMiddleware,\n      this.passwordChange\n    );\n    this.app.router.post(\n      `/auth/email/validate/:tokenId`,\n      this.emailVerification\n    );\n    this.app.router.put(`/user`, jwtMiddleware, this.updateUser);\n\n    // middleware for setting passport user( for treating non-authenticated user as guest)\n    this.app.router.use(async (req, res, next) => {\n      const user = await new Promise(resolve => {\n        passport.authenticate(\n          'jwt',\n          { session: false },\n          (_err, user, _info) => {\n            if (user && !req.headers['xc-shared-base-id']) {\n              if (\n                req.path.indexOf('/user/me') === -1 &&\n                req.header('xc-preview') &&\n                /(?:^|,)(?:owner|creator)(?:$|,)/.test(user.roles)\n              ) {\n                return resolve({\n                  ...user,\n                  isAuthorized: true,\n                  roles: req.header('xc-preview')\n                });\n              }\n\n              return resolve({ ...user, isAuthorized: true });\n            }\n\n            if (req.headers['xc-token']) {\n              passport.authenticate(\n                'authtoken',\n                {\n                  session: false,\n                  optional: false\n                },\n                (_err, user, _info) => {\n                  if (user) {\n                    return resolve({\n                      ...user,\n                      isAuthorized: true,\n                      roles:\n                        user.roles === 'owner' ? 'owner,creator' : user.roles\n                    });\n                  } else {\n                    resolve({ roles: 'guest' });\n                  }\n                }\n              )(req, res, next);\n            } else if (req.headers['xc-shared-base-id']) {\n              passport.authenticate('baseView', {}, (_err, user, _info) => {\n                if (user) {\n                  return resolve({\n                    ...user,\n                    isAuthorized: true,\n                    isPublicBase: true\n                  });\n                } else {\n                  resolve({ roles: 'guest' });\n                }\n              })(req, res, next);\n            } else {\n              resolve({ roles: 'guest' });\n            }\n          }\n        )(req, res, next);\n      });\n\n      await promisify((req as any).login.bind(req))(user);\n      next();\n    });\n\n    this.app.router.get(`/user/me`, this.me);\n    this.app.router.post(`/auth/signout`, this.signout);\n\n    /* Admin APIs */\n    this.app.router.use('/admin', this.isAdmin);\n\n    this.app.router.get('/admin/roles', this.listRoles);\n    this.app.router.delete('/admin/roles/:id', this.deleteRole);\n    this.app.router.put('/admin/roles', this.saveOrUpdateRoles);\n\n    this.app.router.post('/admin', this.addAdmin);\n    this.app.router.put('/admin/:id', this.updateAdmin);\n    this.app.router.delete('/admin/:id', this.deleteAdmin);\n    this.app.router.get('/admin', this.listUsers);\n    this.app.router.post('/admin/resendInvite/:id', this.resendInvite);\n  }\n\n  public async initStrategies(): Promise<void> {\n    const self = this;\n\n    passport.use(\n      'authtoken',\n      new AuthTokenStrategy({ headerFields: ['xc-token'] }, (token, done) => {\n        const apiToken = this.apiTokens?.find(t => t.token === token);\n        if (apiToken) {\n          done(null, { roles: 'editor' });\n        } else {\n          return done({ msg: 'Invalid tok' });\n        }\n      })\n    );\n    this.initCustomStrategy();\n    this.initJwtStrategy();\n\n    passport.use(\n      new PassportLocalStrategy(\n        {\n          usernameField: 'email',\n          session: false\n        },\n        async (email, password, done) => {\n          try {\n            const user = await self.users.where({ email }).first();\n            if (!user) {\n              return done({ msg: `Email ${email} is not registered!` });\n            }\n            const hashedPassword = await promisify(bcrypt.hash)(\n              password,\n              user.salt\n            );\n            if (user.password !== hashedPassword) {\n              return done({ msg: `Password not valid!` });\n            } else {\n              return done(null, user);\n            }\n          } catch (e) {\n            done(e);\n          }\n        }\n      )\n    );\n\n    const googlePlugin = await this.xcMeta.metaGet(null, null, 'nc_plugins', {\n      title: 'Google'\n    });\n\n    if (googlePlugin && googlePlugin.input) {\n      const settings = JSON.parse(googlePlugin.input);\n      process.env.NC_GOOGLE_CLIENT_ID = settings.client_id;\n      process.env.NC_GOOGLE_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GOOGLE_CLIENT_ID &&\n      process.env.NC_GOOGLE_CLIENT_SECRET\n    ) {\n      const googleAuthParamsOrig = GoogleStrategy.prototype.authorizationParams;\n      GoogleStrategy.prototype.authorizationParams = (options: any) => {\n        const params = googleAuthParamsOrig.call(this, options);\n\n        if (options.state) {\n          params.state = options.state;\n        }\n\n        return params;\n      };\n\n      const clientConfig = {\n        clientID: process.env.NC_GOOGLE_CLIENT_ID,\n        clientSecret: process.env.NC_GOOGLE_CLIENT_SECRET,\n        // todo: update url\n        callbackURL: 'http://localhost:3000',\n        passReqToCallback: true\n      };\n\n      const googleStrategy = new GoogleStrategy(\n        clientConfig,\n        async (req, _accessToken, _refreshToken, profile, cb) => {\n          try {\n            const email = profile.emails[0].value;\n\n            let user = await this.users\n              .where({\n                email\n              })\n              .first();\n            const token = req.query.state;\n\n            if (token) {\n              Tele.emit('evt_subscribe', email);\n              await this.users\n                .update({\n                  // firstname, lastname,\n                  // email_verification_token,\n                  invite_token: null,\n                  invite_token_expires: null,\n                  email_verified: true\n                })\n                .where({\n                  email,\n                  invite_token: token\n                });\n            } else {\n              let roles = 'editor';\n\n              if (!(await this.users.first())) {\n                roles = 'owner';\n              }\n\n              if (!user) {\n                if (roles === 'editor') {\n                  return cb({ msg: `Account not found!` });\n                }\n\n                Tele.emit('evt_subscribe', email);\n                const salt = await promisify(bcrypt.genSalt)(10);\n                user = await this.users.insert({\n                  email: profile.emails[0].value,\n                  password: '',\n                  salt,\n                  roles,\n                  email_verified: true\n                });\n              } else {\n                await this.users\n                  .update({\n                    email_verified: true\n                  })\n                  .where({\n                    email\n                  });\n              }\n              user = await this.users\n                .where({\n                  email\n                })\n                .first();\n            }\n            cb(null, user);\n          } catch (e) {\n            cb(e, null);\n          }\n        }\n      );\n\n      passport.use(googleStrategy);\n    }\n\n    const githubPlugin = await this.xcMeta.metaGet(null, null, 'nc_plugins', {\n      title: 'Github'\n    });\n    if (githubPlugin && githubPlugin.input) {\n      const settings = JSON.parse(githubPlugin.input);\n      process.env.NC_GITHUB_CLIENT_ID = settings.client_id;\n      process.env.NC_GITHUB_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GITHUB_CLIENT_ID &&\n      process.env.NC_GITHUB_CLIENT_SECRET\n    ) {\n      const githubStrategy = new GithubStrategy(\n        {\n          clientID: process.env.NC_GITHUB_CLIENT_ID,\n          clientSecret: process.env.NC_GITHUB_CLIENT_SECRET,\n          // callbackURL: app.$config.auth.github.callbackUrl,\n          passReqToCallback: true\n        },\n        async (req, accessToken, _refreshToken, profile, cb) => {\n          try {\n            let email =\n              profile.emails && profile.emails[0] && profile.emails[0].value;\n            if (!email) {\n              const res = await axios.get('https://api.github.com/user', {\n                headers: {\n                  Authorization: 'token ' + accessToken\n                }\n              });\n              if (res.data && res.data.length) {\n                email = res.data[0].email;\n              } else {\n                return cb(null, false, {\n                  message:\n                    'There is no email id associated to your github account.'\n                });\n              }\n            }\n\n            let user = await this.users\n              .where({\n                email\n              })\n              .first();\n            const token = req.query?.state?.replace('github|', '');\n\n            if (token) {\n              Tele.emit('evt_subscribe', email);\n              await this.users\n                .update({\n                  // firstname, lastname,\n                  // email_verification_token,\n                  invite_token: null,\n                  invite_token_expires: null,\n                  email_verified: true\n                })\n                .where({\n                  email,\n                  invite_token: token\n                });\n            } else {\n              let roles = 'editor';\n\n              if (!(await this.users.first())) {\n                roles = 'owner';\n              }\n\n              if (!user) {\n                if (roles === 'editor') {\n                  return cb({ msg: `Account not found!` });\n                }\n\n                Tele.emit('evt_subscribe', email);\n                const salt = await promisify(bcrypt.genSalt)(10);\n                user = await this.users.insert({\n                  email: profile.emails[0].value,\n                  password: '',\n                  salt,\n                  roles,\n                  email_verified: true\n                });\n              } else {\n                await this.users\n                  .update({\n                    email_verified: true\n                  })\n                  .where({\n                    email\n                  });\n              }\n              user = await this.users\n                .where({\n                  email\n                })\n                .first();\n            }\n            cb(null, user);\n          } catch (e) {\n            cb(e, null);\n          }\n        }\n      );\n\n      passport.use(githubStrategy);\n    }\n\n    /*    passport.use(new AzureAdOAuth2Strategy({\n\n          },\n          (_accessToken, _refresh_token, params, profile, done) => {\n            // currently we can't find a way to exchange access token by user info (see userProfile implementation), so\n            // you will need a jwt-package like https://github.com/auth0/node-jsonwebtoken to decode id_token and get waad profile\n            const waadProfile = profile || jwt.decode(params.id_token);\n\n            // this is just an run: here you would provide a model *User* with the function *findOrCreate*\n            done(waadProfile)\n          }));*/\n  }\n\n  protected initJwtStrategy() {\n    passport.use(\n      new Strategy(this.jwtOptions, (jwtPayload, done) => {\n        this.users\n          .where({\n            email: jwtPayload?.email\n          })\n          .first()\n          .then(user => {\n            if (user) {\n              user.roles = 'owner';\n              return done(null, user);\n            } else {\n              return done(new Error('User not found'));\n            }\n          })\n          .catch(err => {\n            return done(err);\n          });\n      })\n    );\n  }\n\n  protected initCustomStrategy() {\n    passport.use(\n      'baseView',\n      new CustomStrategy(async (req: any, callback) => {\n        let user;\n        if (req.headers['xc-shared-base-id']) {\n          const cacheKey = `nc_shared_bases||${req.headers['xc-shared-base-id']}`;\n\n          let sharedBase = XcCache.get(cacheKey);\n\n          if (!sharedBase) {\n            sharedBase = await this.xcMeta\n              .knex('nc_shared_bases')\n              .where({\n                enabled: true,\n                shared_base_id: req.headers['xc-shared-base-id']\n              })\n              .first();\n            XcCache.set(cacheKey, sharedBase);\n          }\n          user = {\n            roles: sharedBase?.roles\n          };\n        }\n\n        callback(null, user);\n      })\n    );\n  }\n\n  protected async signin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'local',\n      { session: false },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              // err: { msg: string }\n              return res.status(400).send(err);\n            }\n            if (info) {\n              // info: { message: string }\n              // Info was thrown directly before.\n              // In order to avoid breaking change, both \"msg\" and \"message\" are returned.\n              return res.status(400).send({ msg: info.message ?? '' });\n            }\n            return res.status(400).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          this.xcMeta.audit(null, null, 'nc_audit', {\n            op_type: 'AUTHENTICATION',\n            op_sub_type: 'SIGNIN',\n            user: user.email,\n            ip: req.clientIp,\n            description: `signed in`\n          });\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async googleSignin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'google',\n      {\n        session: false,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              return res.status(400).send(err);\n            }\n            if (info) {\n              return res.status(400).send(info);\n            }\n            return res.status(500).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          this.xcMeta.audit(null, null, 'nc_audit', {\n            op_type: 'AUTHENTICATION',\n            op_sub_type: 'SIGNIN',\n            user: user.email,\n            ip: req.clientIp,\n            description: `signed in using Google Auth`\n          });\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async githubSignin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'github',\n      {\n        session: false,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              return res.status(400).send(err);\n            }\n            if (info) {\n              return res.status(400).send(info);\n            }\n            return res.status(500).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async refreshToken(req, res): Promise<any> {\n    console.log('token refresh');\n    try {\n      if (!req?.cookies?.refresh_token) {\n        return res.status(400).json({ msg: 'Missing refresh token' });\n      }\n\n      const user = await this.users\n        .where({\n          refresh_token: req.cookies.refresh_token\n        })\n        .first();\n\n      if (!user) {\n        return res.status(400).json({ msg: 'Invalid refresh token' });\n      }\n\n      const refreshToken = this.randomTokenString();\n\n      await this.users\n        .update({\n          refresh_token: refreshToken\n        })\n        .where({\n          id: user.id\n        });\n\n      this.setTokenCookie(res, refreshToken);\n\n      res.json({\n        token: jwt.sign(\n          {\n            email: user.email,\n            firstname: user.firstname,\n            lastname: user.lastname,\n            id: user.id,\n            roles: user.roles\n          },\n          this.config.auth.jwt.secret,\n          this.config.auth.jwt.options\n        )\n      } as any);\n    } catch (e) {\n      return res.status(400).json({ msg: e.message });\n    }\n  }\n\n  protected async signup(req, res, next): Promise<any> {\n    try {\n      const {\n        email: _email,\n        firstname,\n        lastname,\n        token,\n        ignore_subscribe\n      } = req.body;\n      let { password } = req.body;\n\n      if (!isEmail(_email)) {\n        return next(new Error(`Invalid email`));\n      }\n\n      const email = _email.toLowerCase();\n\n      let user = await this.users\n        .where({\n          email\n        })\n        .first();\n\n      if (user) {\n        if (token) {\n          if (token !== user.invite_token) {\n            return next(new Error(`Invalid invite url`));\n          } else if (user.invite_token_expires < new Date()) {\n            return next(\n              new Error(\n                'Expired invite url, Please contact super admin to get a new invite url'\n              )\n            );\n          }\n        } else {\n          // todo : opening up signup for timebeing\n          // return next(new Error(`Email '${email}' already registered`));\n        }\n      }\n\n      const salt = await promisify(bcrypt.genSalt)(10);\n      password = await promisify(bcrypt.hash)(password, salt);\n      const email_verification_token = uuidv4();\n\n      if (!ignore_subscribe) {\n        Tele.emit('evt_subscribe', email);\n      }\n\n      if (user) {\n        if (token) {\n          await this.users\n            .update({\n              firstname,\n              lastname,\n              salt,\n              password,\n              email_verification_token,\n              invite_token: null,\n              invite_token_expires: null\n            })\n            .where({\n              email,\n              invite_token: token\n            });\n        } else {\n          return next(new Error('User already exist'));\n        }\n      } else {\n        let roles = 'user';\n\n        if (!(await this.users.first())) {\n          // todo: update in nc_store\n          // roles = 'owner,creator,editor'\n          Tele.emit('evt', { evt_type: 'project:invite', count: 1 });\n        } else {\n          if (process.env.NC_INVITE_ONLY_SIGNUP) {\n            return next(\n              new Error('Not allowed to signup, contact super admin.')\n            );\n          } else {\n            roles = 'user_new';\n          }\n        }\n\n        await this.users.insert({\n          firstname,\n          lastname,\n          email,\n          salt,\n          password,\n          email_verification_token,\n          roles\n        });\n      }\n      user = await this.users\n        .where({\n          email\n        })\n        .first();\n\n      try {\n        const template = (await import('./ui/emailTemplates/verify')).default;\n        await this.emailClient.mailSend({\n          to: email,\n          subject: 'Verify email',\n          html: ejs.render(template, {\n            verifyLink:\n              req.ncSiteUrl + `/email/verify/${user.email_verification_token}`\n          })\n        });\n      } catch (e) {\n        console.log(\n          'Warning : `mailSend` failed, Please configure emailClient configuration.'\n        );\n      }\n      await promisify((req as any).login.bind(req))(user);\n      const refreshToken = this.randomTokenString();\n      await this.users\n        .update({\n          refresh_token: refreshToken\n        })\n        .where({\n          id: user.id\n        });\n\n      this.setTokenCookie(res, refreshToken);\n\n      user = (req as any).user;\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'SIGNUP',\n        user: user.email,\n        description: `signed up `,\n        ip: req.clientIp\n      });\n\n      res.json({\n        token: jwt.sign(\n          {\n            email: user.email,\n            firstname: user.firstname,\n            lastname: user.lastname,\n            id: user.id,\n            roles: user.roles\n          },\n          this.config.auth.jwt.secret\n        )\n      } as any);\n    } catch (e) {\n      console.log(e);\n      next(e);\n    }\n  }\n\n  protected async signout(req, res, next): Promise<any> {\n    try {\n      res.clearCookie('refresh_token');\n      const email = req?.session?.passport?.user?.email?.toLowerCase();\n\n      if (email) {\n        await this.users\n          .update({\n            refresh_token: null\n          })\n          .where({\n            email\n          });\n      }\n\n      res.json({ msg: 'Success' });\n    } catch (e) {\n      console.log(e);\n      next(e);\n    }\n  }\n\n  protected async passwordForgot(req, res, next): Promise<any> {\n    const _email = req.body.email;\n    if (!_email) {\n      return next(new Error('Please enter your email address.'));\n    }\n\n    const email = _email.toLowerCase();\n\n    const user = await this.users.where({ email }).first();\n    if (user) {\n      const token = uuidv4();\n      await this.users\n        .update({\n          reset_password_token: token,\n          reset_password_expires: new Date(Date.now() + 60 * 60 * 1000)\n        })\n        .where({ id: user.id });\n\n      try {\n        const template = (await import('./ui/emailTemplates/forgotPassword'))\n          .default;\n        await this.emailClient.mailSend({\n          to: user.email,\n          subject: 'Password Reset Link',\n          text: `Visit following link to update your password : ${req.ncSiteUrl}/password/reset/${token}.`,\n          html: ejs.render(template, {\n            resetLink: req.ncSiteUrl + `/password/reset/${token}`\n          })\n        });\n      } catch (e) {\n        console.log(\n          'Warning : `mailSend` failed, Please configure emailClient configuration.'\n        );\n      }\n      console.log(`Password reset token : ${token}`);\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'PASSWORD_FORGOT',\n        user: user.email,\n        description: `requested for password reset `,\n        ip: req.clientIp\n      });\n    }\n    res.json({ msg: 'Check your email if you are registered with us.' });\n  }\n\n  protected async tokenValidate(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ reset_password_token: token })\n      .first();\n    if (!user || !user.email) {\n      return next(new Error('Invalid reset url'));\n    }\n    if (user.reset_password_expires < new Date()) {\n      return next(new Error('Password reset url expired'));\n    }\n    res.json(true);\n  }\n\n  protected async passwordReset(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ reset_password_token: token })\n      .first();\n    if (!user) {\n      return next(new Error('Invalid reset url'));\n    }\n    if (user.reset_password_expires < new Date()) {\n      return next(new Error('Password reset url expired'));\n    }\n    if (user.provider && user.provider !== 'local') {\n      return next(new Error('Email registered via social account'));\n    }\n\n    const salt = await promisify(bcrypt.genSalt)(10);\n    const password = await promisify(bcrypt.hash)(req.body.password, salt);\n\n    await this.users\n      .update({\n        salt,\n        password,\n        reset_password_expires: null,\n        reset_password_token: ''\n      })\n      .where({\n        id: user.id\n      });\n\n    this.xcMeta.audit(null, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'PASSWORD_RESET',\n      user: user.email,\n      description: `did reset password `,\n      ip: req.clientIp\n    });\n\n    res.json({ msg: 'Password reset successful' });\n  }\n\n  protected async passwordChange(req, res, next): Promise<any> {\n    const { currentPassword, newPassword } = req.body;\n    if (req.isAuthenticated()) {\n      if (!currentPassword || !newPassword) {\n        return next(new Error('Missing new/old password'));\n      }\n      const user = await this.users.where({ email: req.user.email }).first();\n      const hashedPassword = await promisify(bcrypt.hash)(\n        currentPassword,\n        user.salt\n      );\n      if (hashedPassword !== user.password) {\n        return next(new Error('Current password is wrong'));\n      }\n\n      const salt = await promisify(bcrypt.genSalt)(10);\n      const password = await promisify(bcrypt.hash)(newPassword, salt);\n\n      await this.users\n        .update({\n          salt,\n          password\n        })\n        .where({ id: user.id });\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'PASSWORD_CHANGE',\n        user: user.email,\n        description: `changed password `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'Password updated successfully' });\n    }\n  }\n\n  protected async emailVerification(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ email_verification_token: token })\n      .first();\n    if (!user) {\n      return next(new Error('Invalid verification url'));\n    }\n\n    await this.users\n      .update({\n        email_verification_token: '',\n        email_verified: true\n      })\n      .where({ id: user.id });\n\n    this.xcMeta.audit(null, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'EMAIL_VERIFICATION',\n      user: user.email,\n      description: `verified email `,\n      ip: req.clientIp\n    });\n\n    res.json({ msg: 'Email verified successfully' });\n  }\n\n  protected async me(req, res): Promise<any> {\n    res.json(req?.session?.passport?.user ?? {});\n  }\n\n  protected async updateUser(req, res): Promise<any> {\n    await this.users\n      .update({\n        firstname: req.body.firstname,\n        lastname: req.body.lastname\n      })\n      .where({\n        id: req.user.id\n      });\n    res.json({ msg: 'Updated successfully' });\n  }\n\n  /* Admin apis : START */\n\n  // @ts-ignore\n  protected async isSuperAdmin(req, res, next): Promise<any> {\n    if (req.session?.passport?.user?.roles?.owner) {\n      return next();\n    }\n    res.status(401).json({ msg: 'Access denied' });\n  }\n\n  protected async isAdmin(req, res, next): Promise<any> {\n    if (\n      req.session?.passport?.user?.roles?.owner ||\n      req.session?.passport?.user?.roles?.creator ||\n      req?.session?.passport?.user?.roles?.editor\n    ) {\n      return next();\n    }\n    res.status(403).json({ msg: 'Access denied' });\n  }\n\n  protected async addAdmin(req, res, next): Promise<any> {\n    // if (!this.config?.mailer || !this.emailClient) {\n    //   return next(new Error('SMTP config is not found'));\n    // }\n\n    const _email = req.body.email;\n\n    if (!_email || !validator.isEmail(_email)) {\n      return next(new Error('Invalid email address'));\n    }\n    const email = _email.toLowerCase();\n    // todo: handle roles which contains super\n    if (\n      !req.session?.passport?.user?.roles?.owner &&\n      req.body.roles.indexOf('owner') > -1\n    ) {\n      return next(new Error('Insufficient privilege to add super admin role.'));\n    }\n\n    const invite_token = uuidv4();\n    let count;\n    const user = await this.users.where({ email }).first();\n    if (user) {\n      if (\n        !(await this.xcMeta.isUserHaveAccessToProject(\n          req.body.project_id,\n          user.id\n        ))\n      ) {\n        await this.xcMeta.projectAddUser(\n          req.body.project_id,\n          user.id,\n          'creator'\n        );\n      }\n    } else {\n      try {\n        await this.users.insert({\n          invite_token,\n          invite_token_expires: new Date(Date.now() + 24 * 60 * 60 * 1000),\n          email\n        });\n        count = await this.users.count('id as count').first();\n\n        const { id } = await this.users.where({ email }).first();\n        await this.xcMeta.projectAddUser(req.body.project_id, id, 'creator');\n\n        if (!(await this.sendInviteEmail(email, invite_token, req))) {\n          res.json({ invite_token, email });\n        }\n      } catch (e) {\n        return next(e);\n      }\n    }\n\n    Tele.emit('evt', { evt_type: 'project:invite', count: count?.count });\n    this.xcMeta.audit(req.body.project_id, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'INVITE',\n      user: req.user.email,\n      description: `invited ${email} to ${req.body.project_id} project `,\n      ip: req.clientIp\n    });\n\n    res.json({\n      msg: 'success'\n    });\n  }\n\n  protected async updateAdmin(req, res, next): Promise<any> {\n    if (!req?.body?.project_id) {\n      return next(new Error('Missing project id in request body.'));\n    }\n    if (\n      req.session?.passport?.user?.roles?.owner &&\n      req.session?.passport?.user?.id === +req.params.id &&\n      req.body.roles.indexOf('owner') === -1\n    ) {\n      return next(new Error(\"Super admin can't remove Super role themselves\"));\n    }\n    try {\n      const user = await this.users\n        .where({\n          id: req.params.id\n        })\n        .first();\n\n      if (!user) {\n        return next(`User with id '${req.params.id}' doesn't exist`);\n      }\n\n      // todo: handle roles which contains super\n      if (\n        !req.session?.passport?.user?.roles?.owner &&\n        req.body.roles.indexOf('owner') > -1\n      ) {\n        return next(\n          new Error('Insufficient privilege to add super admin role.')\n        );\n      }\n\n      // await this.users.update({\n      //   roles: 'creator'\n      // }).where({\n      //   id: req.params.id\n      // });\n      await this.xcMeta.metaUpdate(\n        req?.body?.project_id,\n        null,\n        'nc_projects_users',\n        {\n          roles: 'creator'\n        },\n        {\n          user_id: req.params.id\n        }\n      );\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'ROLES_MANAGEMENT',\n        user: req.user.email,\n        description: `updated roles for ${user.email} with ${req.body.roles} `,\n        ip: req.clientIp\n      });\n\n      res.json({\n        msg: 'User details updated successfully'\n      });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async deleteAdmin(req, res, next): Promise<any> {\n    try {\n      const { project_id, type } = req.query;\n\n      if (req.session?.passport?.user?.id === +req.params.id) {\n        return next(new Error(\"Admin can't delete themselves!\"));\n      }\n\n      if (!req.session?.passport?.user?.roles?.owner) {\n        const deleteUser = await this.users\n          .where('id', req.params.id)\n          .andWhere('roles', 'like', '%super%')\n          .first();\n        if (deleteUser) {\n          return next(\n            new Error('Insufficient privilege to delete a super admin user.')\n          );\n        }\n      }\n      if (type === 'DELETE_FROM_PROJECT') {\n        // remove user from Project\n        XcCache.del(`${req?.query?.email}___${req?.req?.project_id}`);\n        await this.xcMeta.projectRemoveUser(project_id, req.params.id);\n      } else if (type === 'DELETE_FROM_NOCODB') {\n        // remove user from NocoDB\n        await this.xcMeta.removeXcUser(req.params.id);\n      } else {\n        new Error('Invalid type is provided.');\n      }\n    } catch (e) {\n      return next(e);\n    }\n    res.json({\n      msg: 'success'\n    });\n  }\n\n  protected async listUsers(req, res, next): Promise<any> {\n    try {\n      const { offset = 0, limit = 20, query, project_id } = req.query;\n      let count;\n\n      const queryBuilder = this.users\n        .select(\n          'xc_users.*',\n          'nc_projects_users.project_id',\n          'nc_projects_users.roles as roles'\n        )\n        .offset(offset)\n        .limit(limit);\n\n      if (query) {\n        queryBuilder.where('email', 'like', `%${query}%`);\n      }\n      const self = this;\n      queryBuilder.leftJoin('nc_projects_users', function() {\n        this.on('nc_projects_users.user_id', '=', 'xc_users.id').andOn(\n          'nc_projects_users.project_id',\n          '=',\n          self.xcMeta.knex.raw('?', [project_id])\n        );\n      });\n\n      if (!req.session?.passport?.user?.roles?.owner) {\n        queryBuilder.whereNot('nc_projects_users.roles', 'like', '%owner%');\n        count = (\n          await this.users\n            .count('id as count')\n            .whereNot('roles', 'like', '%owner%')\n            .first()\n        ).count;\n      } else {\n        count = (\n          await this.users\n            .count('id as count')\n            .where('email', 'like', `%${query}%`)\n            .first()\n        ).count;\n      }\n      const list = (await queryBuilder).map(\n        ({ password, salt, refresh_token, ...rest }) => rest\n      );\n\n      res.json({\n        list,\n        count,\n        offset,\n        limit\n      });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async resendInvite(req, res, next): Promise<any> {\n    try {\n      const user = await this.users.where({ id: req.params.id }).first();\n\n      if (!user) {\n        return next(new Error(`User with id '${req.params.id}' not found`));\n      }\n\n      req.body.roles = user.roles;\n      const invite_token = uuidv4();\n\n      await this.users\n        .update({\n          invite_token,\n          invite_token_expires: new Date(Date.now() + 24 * 60 * 60 * 1000)\n        })\n        .where({\n          id: user.id\n        });\n      await this.sendInviteEmail(user.email, invite_token, req);\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'RESEND_INVITE',\n        user: user.email,\n        description: `resent a invite to ${user.email} `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async sendInviteEmail(email, token, req): Promise<any> {\n    try {\n      const template = (await import('./ui/emailTemplates/invite')).default;\n\n      if (this.emailClient) {\n        await this.emailClient.mailSend({\n          to: email,\n          subject: 'Verify email',\n          html: ejs.render(template, {\n            signupLink: `${req.ncSiteUrl}${this.config?.dashboardPath}#/user/authentication/signup/${token}`,\n            projectName: req.body?.projectName,\n            roles: (req.body?.roles || '')\n              .split(',')\n              .map(r => r.replace(/^./, m => m.toUpperCase()))\n              .join(', '),\n            adminEmail: req.session?.passport?.user?.email\n          })\n        });\n        return true;\n      }\n      // throw new Error('SMTP not configured, sending email failed')\n      // } else {\n      //   await this.xcSendInviteEmail({\n      //     fromEmail: req.session?.passport?.user?.email,\n      //     projectName: 'NocoDB',\n      //     inviteUrl: `${req.ncSiteUrl}${this.config?.dashboardPath}#/user/authentication/signup/${token}`,\n      //     toEmail: email\n      //   })\n      // }\n    } catch (e) {\n      console.log(\n        'Warning : `mailSend` failed, Please configure emailClient configuration.',\n        e.message\n      );\n      throw e;\n    }\n  }\n\n  protected async saveOrUpdateRoles(req, res, next): Promise<any> {\n    try {\n      // todo: optimize transaction\n      for (const role of req.body.roles) {\n        if (role.id) {\n          const oldRole = await this.xcMeta.metaGet('', '', NC_ROLES, {\n            id: role.id\n          });\n\n          if (\n            oldRole.title !== role.title ||\n            oldRole.description !== role.description\n          ) {\n            await this.xcMeta.metaUpdate(\n              '',\n              '',\n              NC_ROLES,\n              {\n                ...role\n              },\n              {\n                id: role.id\n              }\n            );\n          }\n          if (oldRole.title !== role.title) {\n            for (const builder of (this.app as Noco).getBuilders()) {\n              try {\n                await this.xcMeta.startTransaction();\n                const aclRows = await this.xcMeta.metaList(\n                  '',\n                  builder.getDbAlias(),\n                  NC_ACL\n                );\n                for (const aclRow of aclRows) {\n                  if (aclRow.acl) {\n                    const acl = JSON.parse(aclRow.acl);\n                    acl[role.title] = acl[oldRole.title];\n                    delete acl[oldRole.title];\n                    await this.xcMeta.metaUpdate(\n                      '',\n                      builder.getDbAlias(),\n                      NC_ACL,\n                      {\n                        acl: JSON.stringify(acl)\n                      },\n                      aclRow.id\n                    );\n                  }\n                }\n                await this.xcMeta.commit();\n              } catch (e) {\n                await this.xcMeta.rollback(e);\n              }\n            }\n          }\n        } else {\n          if (\n            await this.xcMeta.metaGet('', '', NC_ROLES, { title: role.title })\n          ) {\n            return next(Error(`Role name '${role.title}' already exist`));\n          }\n\n          await this.xcMeta.metaInsert('', '', NC_ROLES, role);\n\n          for (const builder of (this.app as Noco).getBuilders()) {\n            try {\n              await this.xcMeta.startTransaction();\n              const aclRows = await this.xcMeta.metaList(\n                '',\n                builder.getDbAlias(),\n                NC_ACL\n              );\n              for (const aclRow of aclRows) {\n                if (aclRow.acl) {\n                  const acl = JSON.parse(aclRow.acl);\n                  acl[role.title] = true;\n                  await this.xcMeta.metaUpdate(\n                    '',\n                    builder.getDbAlias(),\n                    NC_ACL,\n                    {\n                      acl: JSON.stringify(acl)\n                    },\n                    {\n                      id: aclRow.id\n                    }\n                  );\n                }\n              }\n              await this.xcMeta.commit();\n            } catch (e) {\n              await this.xcMeta.rollback(e);\n            }\n          }\n        }\n      }\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'ROLES_MANAGEMENT',\n        user: req.user.email,\n        description: `updated roles `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  // @ts-ignore\n  protected async deleteRole(req, res, next): Promise<any> {\n    try {\n      const role = await this.xcMeta.metaGet('', '', NC_ROLES, {\n        id: req.params.id\n      });\n      if (!role) {\n        return next(new Error(`Role with id '${req.params.id}' not found`));\n      }\n      const deleteRoleName = role.title;\n\n      // todo: update acl in all other database connection\n      for (const builder of (this.app as Noco).getBuilders()) {\n        try {\n          await this.xcMeta.startTransaction();\n          const aclRows = await this.xcMeta.metaList(\n            '',\n            builder.getDbAlias(),\n            NC_ACL\n          );\n          for (const aclRow of aclRows) {\n            if (aclRow.acl) {\n              const acl = JSON.parse(aclRow.acl);\n              delete acl[deleteRoleName];\n              await this.xcMeta.metaUpdate(\n                '',\n                builder.getDbAlias(),\n                NC_ACL,\n                {\n                  acl: JSON.stringify(acl)\n                },\n                {\n                  id: aclRow.id\n                }\n              );\n            }\n          }\n          await this.xcMeta.commit();\n        } catch (e) {\n          this.xcMeta.rollback(e);\n        }\n      }\n\n      await this.xcMeta.metaDelete('', '', NC_ROLES, { id: req.params.id });\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async listRoles(_req, res, next): Promise<any> {\n    try {\n      res.json(await this.xcMeta.metaList('', '', NC_ROLES));\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  /* Admin apis */\n  protected async createAuthTableIfNotExists(): Promise<any> {\n    if (!(await this.dbDriver.schema.hasTable('xc_users'))) {\n      await this.dbDriver.schema.createTable('xc_users', function(table) {\n        table.increments();\n        table.string('email');\n        table.string('password', 255);\n        table.string('salt', 255);\n        table.string('firstname');\n        table.string('lastname');\n        table.string('username');\n        table.string('refresh_token', 255);\n        table.string('invite_token', 255);\n        table.string('invite_token_expires', 255);\n        table.timestamp('reset_password_expires');\n        table.string('reset_password_token', 255);\n        table.string('email_verification_token', 255);\n        table.boolean('email_verified');\n        table.string('roles', 255).defaultTo('editor');\n        table.timestamps();\n      });\n    }\n  }\n\n  protected setTokenCookie(res, token): void {\n    // create http only cookie with refresh token that expires in 7 days\n    const cookieOptions = {\n      httpOnly: true,\n      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n    };\n    res.cookie('refresh_token', token, cookieOptions);\n  }\n\n  protected randomTokenString(): string {\n    return crypto.randomBytes(40).toString('hex');\n  }\n\n  // protected async xcSendInviteEmail(reqBody: {\n  //   fromEmail: string;\n  //   toEmail: string;\n  //   inviteUrl: string\n  //   projectName: string;\n  // }): Promise<any> {\n  //   try {\n  //     await axios.post('https://nocodb.com/api/v1/invite', reqBody);\n  //   } catch (_e) {\n  //   }\n  // }\n\n  protected get emailClient(): IEmailAdapter {\n    return this.app?.metaMgr?.emailAdapter;\n  }\n\n  public async loadLatestApiTokens(): Promise<any> {\n    this.apiTokens = await this.xcMeta.metaList(null, null, 'nc_api_tokens');\n  }\n}\n\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n"], "fixing_code": ["<template>\n  <v-container class=\"text-center\">\n    <v-row align=\"center\">\n      <v-col class=\"col-md-8 offset-md-2\">\n        <v-tabs\n          v-model=\"tabs1.tab\"\n          background-color=\"\"\n          class=\"elevation-2\"\n        >\n          <v-tabs-slider />\n\n          <v-tab\n            v-for=\"(t,i) in tabs1.tabs\"\n            :key=\"i\"\n            :href=\"`#tab-${i}`\"\n          >\n            <span class=\"caption text-capitalize\">{{ t.title }}</span>\n          </v-tab>\n\n          <v-tab-item\n            v-for=\"(t,i) in tabs1.tabs\"\n            :key=\"i\"\n            :value=\"'tab-' + i\"\n          >\n            <v-card\n              v-if=\"t.type==='password'\"\n              class=\"py-10 \"\n              flat\n              tile\n            >\n              <br>\n              <div v-if=\"isAdmin\">\n                <h1>You are an Admin too!</h1>\n                <h2 class=\"title is-2\">\n                  You are admin as well\n                </h2>\n                <router-link to=\"/user/admin\">\n                  User list\n                </router-link>\n              </div>\n\n              <v-row align=\"center\">\n                <v-col md=\"8\" offset-md=\"2\">\n                  <!--                  <p class=\"title\">\n                    Change Password\n                  </p>-->\n\n                  <div>\n                    <v-alert v-model=\"formUtil.formErr\" type=\"error\" dismissible>\n                      {{ formUtil.formErrMsg }}\n                    </v-alert>\n                  </div>\n\n                  <v-card class=\"pa-5 elevation-10\" color=\"\">\n                    <v-form ref=\"formType\" v-model=\"valid\" lazy-validation>\n                      <v-text-field\n                        v-model=\"passwordDetails.currentPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"Currrent password\"\n                        :append-icon=\"e3 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[0]\"\n                        :type=\"e3 ? 'password' : 'text'\"\n                        @click:append=\"() => (e3 = !e3)\"\n                      />\n\n                      <v-text-field\n                        v-model=\"passwordDetails.newPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"New password\"\n                        :append-icon=\"e4 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[1]\"\n                        :type=\"e4 ? 'password' : 'text'\"\n                        @click:append=\"() => (e4 = !e4)\"\n                      />\n\n                      <v-text-field\n                        v-model=\"passwordDetails.verifyPassword\"\n                        dense\n                        class=\"caption\"\n                        name=\"input-10-2\"\n                        label=\"Confirm new password\"\n                        :append-icon=\"e5 ? 'visibility' : 'visibility_off'\"\n                        :rules=\"formRules.password[2]\"\n                        :type=\"e5 ? 'password' : 'text'\"\n                        @click:append=\"() => (e5 = !e5)\"\n                      />\n\n                      <v-btn\n                        class=\"caption\"\n                        color=\"primary\"\n                        :disabled=\"!valid\"\n                        @click=\"resetUserPassword\"\n                      >\n                        SAVE PASSWORD\n                      </v-btn>\n                    </v-form>\n                  </v-card>\n                </v-col>\n              </v-row>\n            </v-card>\n          </v-tab-item>\n        </v-tabs>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script>\nimport { isEmail } from '@/helpers'\n\nexport default {\n  directives: {},\n  components: {},\n  validate({ params }) {\n    return true\n  },\n  props: {},\n  data() {\n    return {\n      user: {\n        provider: 'local'\n      },\n      tabs: 3,\n      tabs1: {\n        tab: null,\n        tabs: [{\n          type: 'password',\n          title: 'Change Password'\n        }\n        ]\n      },\n\n      subscriptions: [],\n\n      passwordDetails: {\n        newPassword: null,\n        verifyPassword: null,\n        currentPassword: null\n      },\n      formUtil: {\n        formErr: false,\n        formErrMsg: ''\n      },\n      e3: true,\n      e4: true,\n      e5: true,\n      valid: true,\n      formRules: {\n        email: [\n          // E-mail is required\n          v => !!v || this.$t('msg.error.signUpRules.emailReqd'),\n          // E-mail must be valid\n          v => isEmail(v) ||\n            this.$t('msg.error.signUpRules.emailInvalid')\n        ],\n        password: [\n          // Current Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired')\n          ],\n          // New Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired'),\n            // You password must be atleast 8 characters\n            v => (v && v.length >= 8) || this.$t('msg.error.signUpRules.passwdLength')\n          ],\n          // Confirm Password\n          [\n            // Password is required\n            v => !!v || this.$t('msg.error.signUpRules.passwdRequired'),\n            // TODO: i18n\n            v => v === this.passwordDetails.newPassword || 'Confirm password should match',\n            // You password must be atleast 8 characters\n            v => (v && v.length >= 8) || this.$t('msg.error.signUpRules.passwdLength')\n          ]\n        ]\n      }\n    }\n  },\n  head() {\n    return {}\n  },\n  computed: {\n    isAdmin() {\n      if (this.$store.state.users.user) {\n        // console.log(this.$store.state.users.user.roles.indexOf('creator'));\n        return 'creator' in this.$store.state.users.user.roles\n      }\n      return false\n    },\n\n    isEmailAuth() {\n      if (this.$store.state.users.user) {\n        // console.log(this.$store.state.users.user.roles.indexOf('creator'));\n        return (this.$store.state.users.user.provider === 'local')\n      }\n      return false\n    }\n\n  },\n  watch: {},\n  created() {\n  },\n  mounted() {\n    this.getSubscriptions()\n  },\n  beforeDestroy() {\n  },\n  methods: {\n    test() {\n      // console.log('test method');\n    },\n\n    async resetUserPassword(e) {\n      e.preventDefault()\n      if (this.$refs.formType[0].validate()) {\n        try {\n          await this.$api.auth.passwordChange(\n            {\n              currentPassword: this.passwordDetails.currentPassword,\n              newPassword: this.passwordDetails.newPassword\n            }\n          )\n          this.$toast.success('Password changed successfully. Please login again.').goAway(3000)\n          this.$refs.formType[0].reset()\n          await this.$store.dispatch('users/ActSignOut')\n          this.$router.push('/user/authentication/signin')\n        } catch (e) {\n          this.$toast\n            .error(await this._extractSdkResponseErrorMsg(e))\n            .goAway(3000);\n          return;\n        }\n      }\n    },\n\n    async getSubscriptions(e) {\n    }\n  },\n  beforeCreated() {\n  },\n  destroy() {\n  }\n}\n</script>\n\n<style scoped>\n\n</style>\n<!--\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n-->\n", "// import axios from 'axios';\n//\n// if (!window.axios) {\n//   window.axios = axios.create({\n//     baseURL: 'http://localhost:8080',\n//   });\n// }\n\nexport default ({ store, $axios, redirect, $toast, route, app }) => {\n  // Add a request interceptor\n  $axios.interceptors.request.use(function(config) {\n    config.headers['xc-gui'] = 'true'\n    if (store.state.users.token) {\n      config.headers['xc-auth'] = store.state.users.token\n    }\n    if (!config.url.endsWith('/user/me') && !config.url.endsWith('/admin/roles') && store.state.users.previewAs) {\n      config.headers['xc-preview'] = store.state.users.previewAs\n    }\n\n    if (!config.url.endsWith('/user/me') && !config.url.endsWith('/admin/roles')) {\n      if (app.context && app.context.route && app.context.route.params && app.context.route.params.shared_base_id) {\n        config.headers['xc-shared-base-id'] = app.context.route.params.shared_base_id\n      }\n    }\n\n    return config\n  })\n\n  // $axios.setBaseURL('http://localhost:8080')\n\n  $axios.interceptors.response.use((response) => {\n    // Return a successful response back to the calling service\n    return response\n  }, (error) => {\n    if (error.response && error.response.data && error.response.data.msg === 'Database config not found') {\n      redirect('/project/0')\n      return\n    }\n\n    // Return any error which is not due to authentication back to the calling service\n    if (!error.response || error.response.status !== 401) {\n      return new Promise((resolve, reject) => {\n        reject(error)\n      })\n    }\n\n    // Logout user if token refresh didn't work or user is disabled\n    if (error.config.url === '/auth/refresh-token') {\n      store.dispatch('users/ActSignOut')\n\n      return new Promise((resolve, reject) => {\n        reject(error)\n      })\n    }\n\n    // Try request again with new token\n    return $axios.post('/auth/refresh-token', null, {\n      withCredentials: true\n    })\n      .then((token) => {\n        // New request with new token\n        const config = error.config\n        config.headers['xc-auth'] = token.data.token\n        store.commit('users/MutSetToken', token.data.token)\n\n        return new Promise((resolve, reject) => {\n          $axios.request(config).then((response) => {\n            resolve(response)\n          }).catch((error) => {\n            reject(error)\n          })\n        })\n      })\n      .catch(async(error) => {\n        await store.dispatch('users/ActSignOut')\n        if (store.state.project.appInfo.firstUser) {\n          redirect('/')\n        } else {\n          $toast.clear()\n          $toast.info('Token Expired. Please login again.', {\n            position: 'bottom-center'\n          }).goAway(5000)\n          redirect('/user/authentication/signin')\n        }\n        Promise.reject(error)\n      })\n  })\n}\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import User from '../../../models/User';\nimport ProjectUser from '../../../models/ProjectUser';\nimport { promisify } from 'util';\nimport { Strategy as CustomStrategy } from 'passport-custom';\n\nimport { Strategy } from 'passport-jwt';\nimport passport from 'passport';\nimport { ExtractJwt } from 'passport-jwt';\nimport { Strategy as AuthTokenStrategy } from 'passport-auth-token';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\n\nconst PassportLocalStrategy = require('passport-local').Strategy;\n\nconst jwtOptions = {\n  expiresIn: process.env.NC_JWT_EXPIRES_IN ?? '10h',\n  jwtFromRequest: ExtractJwt.fromHeader('xc-auth')\n};\n\nimport bcrypt from 'bcryptjs';\nimport Project from '../../../models/Project';\nimport NocoCache from '../../../cache/NocoCache';\nimport { CacheGetType, CacheScope } from '../../../utils/globals';\nimport ApiToken from '../../../models/ApiToken';\nimport Noco from '../../../Noco';\nimport Plugin from '../../../models/Plugin';\n\nexport function initStrategies(router): void {\n  passport.use(\n    'authtoken',\n    new AuthTokenStrategy({ headerFields: ['xc-token'] }, (token, done) => {\n      ApiToken.getByToken(token)\n        .then(apiToken => {\n          if (apiToken) {\n            done(null, { roles: 'editor' });\n          } else {\n            return done({ msg: 'Invalid tok' });\n          }\n        })\n        .catch(e => {\n          console.log(e);\n          done({ msg: 'Invalid tok' });\n        });\n    })\n  );\n\n  passport.serializeUser(function(\n    {\n      id,\n      email,\n      email_verified,\n      roles: _roles,\n      provider,\n      firstname,\n      lastname,\n      isAuthorized,\n      isPublicBase,\n      token_version\n    },\n    done\n  ) {\n    const roles = (_roles || '')\n      .split(',')\n      .reduce((obj, role) => Object.assign(obj, { [role]: true }), {});\n    if (roles.owner) {\n      roles.creator = true;\n    }\n    done(null, {\n      isAuthorized,\n      isPublicBase,\n      id,\n      email,\n      email_verified,\n      provider,\n      firstname,\n      lastname,\n      roles,\n      token_version\n    });\n  });\n\n  passport.deserializeUser(function(user, done) {\n    done(null, user);\n  });\n\n  passport.use(\n    new Strategy(\n      {\n        secretOrKey: Noco.getConfig().auth.jwt.secret,\n        ...jwtOptions,\n        passReqToCallback: true,\n        ...Noco.getConfig().auth.jwt.options\n      },\n      async (req, jwtPayload, done) => {\n        const keyVals = [jwtPayload?.email];\n        if (req.ncProjectId) {\n          keyVals.push(req.ncProjectId);\n        }\n        const key = keyVals.join('___');\n        const cachedVal = await NocoCache.get(\n          `${CacheScope.USER}:${key}`,\n          CacheGetType.TYPE_OBJECT\n        );\n\n        if (cachedVal) {\n          if (cachedVal.token_version !== jwtPayload.token_version) {\n            return done(new Error('Token Expired. Please login again.'));\n          }\n          return done(null, cachedVal);\n        }\n\n        User.getByEmail(jwtPayload?.email)\n          .then(async user => {\n            if (user.token_version !== jwtPayload.token_version) {\n              return done(new Error('Token Expired. Please login again.'));\n            }\n            if (req.ncProjectId) {\n              // this.xcMeta\n              //   .metaGet(req.ncProjectId, null, 'nc_projects_users', {\n              //     user_id: user?.id\n              //   })\n\n              ProjectUser.get(req.ncProjectId, user.id)\n                .then(async projectUser => {\n                  user.roles = projectUser?.roles || 'user';\n                  user.roles =\n                    user.roles === 'owner' ? 'owner,creator' : user.roles;\n                  // + (user.roles ? `,${user.roles}` : '');\n\n                  await NocoCache.set(`${CacheScope.USER}:${key}`, user);\n                  done(null, user);\n                })\n                .catch(e => done(e));\n            } else {\n              // const roles = projectUser?.roles ? JSON.parse(projectUser.roles) : {guest: true};\n              if (user) {\n                await NocoCache.set(`${CacheScope.USER}:${key}`, user);\n                return done(null, user);\n              } else {\n                return done(new Error('User not found'));\n              }\n            }\n          })\n          .catch(err => {\n            return done(err);\n          });\n      }\n    )\n  );\n\n  passport.use(\n    new PassportLocalStrategy(\n      {\n        usernameField: 'email',\n        session: false\n      },\n      async (email, password, done) => {\n        try {\n          const user = await User.getByEmail(email);\n          if (!user) {\n            return done({ msg: `Email ${email} is not registered!` });\n          }\n          const hashedPassword = await promisify(bcrypt.hash)(\n            password,\n            user.salt\n          );\n          if (user.password !== hashedPassword) {\n            return done({ msg: `Password not valid!` });\n          } else {\n            return done(null, user);\n          }\n        } catch (e) {\n          done(e);\n        }\n      }\n    )\n  );\n\n  passport.use(\n    'baseView',\n    new CustomStrategy(async (req: any, callback) => {\n      let user;\n      if (req.headers['xc-shared-base-id']) {\n        // const cacheKey = `nc_shared_bases||${req.headers['xc-shared-base-id']}`;\n\n        let sharedProject = null;\n\n        if (!sharedProject) {\n          sharedProject = await Project.getByUuid(\n            req.headers['xc-shared-base-id']\n          );\n        }\n        user = {\n          roles: sharedProject?.roles\n        };\n      }\n\n      callback(null, user);\n    })\n  );\n\n  // mostly copied from older code\n  Plugin.getPluginByTitle('Google').then(googlePlugin => {\n    if (googlePlugin && googlePlugin.input) {\n      const settings = JSON.parse(googlePlugin.input);\n      process.env.NC_GOOGLE_CLIENT_ID = settings.client_id;\n      process.env.NC_GOOGLE_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GOOGLE_CLIENT_ID &&\n      process.env.NC_GOOGLE_CLIENT_SECRET\n    ) {\n      const googleAuthParamsOrig = GoogleStrategy.prototype.authorizationParams;\n      GoogleStrategy.prototype.authorizationParams = (options: any) => {\n        const params = googleAuthParamsOrig.call(this, options);\n\n        if (options.state) {\n          params.state = options.state;\n        }\n\n        return params;\n      };\n\n      const clientConfig = {\n        clientID: process.env.NC_GOOGLE_CLIENT_ID,\n        clientSecret: process.env.NC_GOOGLE_CLIENT_SECRET,\n        // todo: update url\n        callbackURL: 'http://localhost:3000',\n        passReqToCallback: true\n      };\n\n      const googleStrategy = new GoogleStrategy(\n        clientConfig,\n        async (req, _accessToken, _refreshToken, profile, done) => {\n          const email = profile.emails[0].value;\n\n          User.getByEmail(email)\n            .then(async user => {\n              if (req.ncProjectId) {\n                ProjectUser.get(req.ncProjectId, user.id)\n                  .then(async projectUser => {\n                    user.roles = projectUser?.roles || 'user';\n                    user.roles =\n                      user.roles === 'owner' ? 'owner,creator' : user.roles;\n                    // + (user.roles ? `,${user.roles}` : '');\n\n                    done(null, user);\n                  })\n                  .catch(e => done(e));\n              } else {\n                // const roles = projectUser?.roles ? JSON.parse(projectUser.roles) : {guest: true};\n                if (user) {\n                  return done(null, user);\n                } else {\n                  let roles = 'editor';\n\n                  if (!(await User.isFirst())) {\n                    roles = 'owner';\n                  }\n                  if (roles === 'editor') {\n                    return done(new Error('User not found'));\n                  }\n                  const salt = await promisify(bcrypt.genSalt)(10);\n                  user = await await User.insert({\n                    email: profile.emails[0].value,\n                    password: '',\n                    salt,\n                    roles,\n                    email_verified: true\n                  });\n                  return done(null, user);\n                }\n              }\n            })\n            .catch(err => {\n              return done(err);\n            });\n        }\n      );\n\n      passport.use(googleStrategy);\n    }\n  });\n\n  router.use(passport.initialize());\n}\n", "import { Request, Response } from 'express';\nimport { TableType } from 'nocodb-sdk';\nimport catchError, { NcError } from '../../helpers/catchError';\nconst { isEmail } = require('validator');\nimport * as ejs from 'ejs';\n\nimport bcrypt from 'bcryptjs';\nimport { promisify } from 'util';\nimport User from '../../../models/User';\nimport { Tele } from 'nc-help';\n\nconst { v4: uuidv4 } = require('uuid');\nimport * as jwt from 'jsonwebtoken';\nimport Audit from '../../../models/Audit';\nimport crypto from 'crypto';\nimport NcPluginMgrv2 from '../../helpers/NcPluginMgrv2';\n\nimport passport from 'passport';\nimport extractProjectIdAndAuthenticate from '../../helpers/extractProjectIdAndAuthenticate';\nimport ncMetaAclMw from '../../helpers/ncMetaAclMw';\nimport { MetaTable } from '../../../utils/globals';\nimport Noco from '../../../Noco';\n\nexport async function signup(req: Request, res: Response<TableType>) {\n  const {\n    email: _email,\n    firstname,\n    lastname,\n    token,\n    ignore_subscribe\n  } = req.body;\n  let { password } = req.body;\n\n  if (!isEmail(_email)) {\n    NcError.badRequest(`Invalid email`);\n  }\n\n  const email = _email.toLowerCase();\n\n  let user = await User.getByEmail(email);\n\n  if (user) {\n    if (token) {\n      if (token !== user.invite_token) {\n        NcError.badRequest(`Invalid invite url`);\n      } else if (user.invite_token_expires < new Date()) {\n        NcError.badRequest(\n          'Expired invite url, Please contact super admin to get a new invite url'\n        );\n      }\n    } else {\n      // todo : opening up signup for timebeing\n      // return next(new Error(`Email '${email}' already registered`));\n    }\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  password = await promisify(bcrypt.hash)(password, salt);\n  const email_verification_token = uuidv4();\n\n  if (!ignore_subscribe) {\n    Tele.emit('evt_subscribe', email);\n  }\n\n  if (user) {\n    if (token) {\n      await User.update(user.id, {\n        firstname,\n        lastname,\n        salt,\n        password,\n        email_verification_token,\n        invite_token: null,\n        invite_token_expires: null,\n        email: user.email\n      });\n    } else {\n      NcError.badRequest('User already exist');\n    }\n  } else {\n    let roles = 'user';\n\n    if (await User.isFirst()) {\n      roles = 'user,super';\n      // todo: update in nc_store\n      // roles = 'owner,creator,editor'\n      Tele.emit('evt', {\n        evt_type: 'project:invite',\n        count: 1\n      });\n    } else {\n      if (process.env.NC_INVITE_ONLY_SIGNUP) {\n        NcError.badRequest('Not allowed to signup, contact super admin.');\n      } else {\n        roles = 'user_new';\n      }\n    }\n\n    const token_version = randomTokenString();\n\n    await User.insert({\n      firstname,\n      lastname,\n      email,\n      salt,\n      password,\n      email_verification_token,\n      roles,\n      token_version\n    });\n  }\n  user = await User.getByEmail(email);\n\n  try {\n    const template = (await import('./ui/emailTemplates/verify')).default;\n    await (await NcPluginMgrv2.emailAdapter()).mailSend({\n      to: email,\n      subject: 'Verify email',\n      html: ejs.render(template, {\n        verifyLink:\n          (req as any).ncSiteUrl +\n          `/email/verify/${user.email_verification_token}`\n      })\n    });\n  } catch (e) {\n    console.log(\n      'Warning : `mailSend` failed, Please configure emailClient configuration.'\n    );\n  }\n  await promisify((req as any).login.bind(req))(user);\n  const refreshToken = randomTokenString();\n  await User.update(user.id, {\n    refresh_token: refreshToken,\n    email: user.email\n  });\n\n  setTokenCookie(res, refreshToken);\n\n  user = (req as any).user;\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'SIGNUP',\n    user: user.email,\n    description: `signed up `,\n    ip: (req as any).clientIp\n  });\n\n  res.json({\n    token: jwt.sign(\n      {\n        email: user.email,\n        firstname: user.firstname,\n        lastname: user.lastname,\n        id: user.id,\n        roles: user.roles,\n        token_version: user.token_version\n      },\n      Noco.getConfig().auth.jwt.secret,\n      Noco.getConfig().auth.jwt.options\n    )\n  } as any);\n}\n\nasync function successfulSignIn({\n  user,\n  err,\n  info,\n  req,\n  res,\n  auditDescription\n}) {\n  try {\n    if (!user || !user.email) {\n      if (err) {\n        return res.status(400).send(err);\n      }\n      if (info) {\n        return res.status(400).send(info);\n      }\n      return res.status(400).send({ msg: 'Your signin has failed' });\n    }\n\n    await promisify((req as any).login.bind(req))(user);\n    const refreshToken = randomTokenString();\n\n    let token_version = user.token_version;\n    if (!token_version) {\n      token_version = randomTokenString();\n    }\n\n    await User.update(user.id, {\n      refresh_token: refreshToken,\n      email: user.email,\n      token_version\n    });\n    setTokenCookie(res, refreshToken);\n\n    Audit.insert({\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'SIGNIN',\n      user: user.email,\n      ip: req.clientIp,\n      description: auditDescription\n    });\n\n    res.json({\n      token: jwt.sign(\n        {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n          id: user.id,\n          roles: user.roles,\n          token_version\n        },\n\n        Noco.getConfig().auth.jwt.secret,\n        Noco.getConfig().auth.jwt.options\n      )\n    } as any);\n  } catch (e) {\n    console.log(e);\n    throw e;\n  }\n}\n\nasync function signin(req, res, next) {\n  passport.authenticate(\n    'local',\n    { session: false },\n    async (err, user, info): Promise<any> =>\n      await successfulSignIn({\n        user,\n        err,\n        info,\n        req,\n        res,\n        auditDescription: 'signed in'\n      })\n  )(req, res, next);\n}\n\nasync function googleSignin(req, res, next) {\n  passport.authenticate(\n    'google',\n    {\n      session: false,\n      callbackURL: req.ncSiteUrl + Noco.getConfig().dashboardPath\n    },\n    async (err, user, info): Promise<any> =>\n      await successfulSignIn({\n        user,\n        err,\n        info,\n        req,\n        res,\n        auditDescription: 'signed in using Google Auth'\n      })\n  )(req, res, next);\n}\n\nfunction randomTokenString(): string {\n  return crypto.randomBytes(40).toString('hex');\n}\n\nfunction setTokenCookie(res, token): void {\n  // create http only cookie with refresh token that expires in 7 days\n  const cookieOptions = {\n    httpOnly: true,\n    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n  };\n  res.cookie('refresh_token', token, cookieOptions);\n}\n\nasync function me(req, res): Promise<any> {\n  res.json(req?.session?.passport?.user ?? {});\n}\n\nasync function passwordChange(req: Request<any, any>, res): Promise<any> {\n  if (!(req as any).isAuthenticated()) {\n    NcError.forbidden('Not allowed');\n  }\n  const { currentPassword, newPassword } = req.body;\n  if (!currentPassword || !newPassword) {\n    return NcError.badRequest('Missing new/old password');\n  }\n  const user = await User.getByEmail((req as any).user.email);\n  const hashedPassword = await promisify(bcrypt.hash)(\n    currentPassword,\n    user.salt\n  );\n  if (hashedPassword !== user.password) {\n    return NcError.badRequest('Current password is wrong');\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  const password = await promisify(bcrypt.hash)(newPassword, salt);\n\n  await User.update(user.id, {\n    salt,\n    password,\n    email: user.email,\n    token_version: null\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'PASSWORD_CHANGE',\n    user: user.email,\n    description: `changed password `,\n    ip: (req as any).clientIp\n  });\n\n  res.json({ msg: 'Password updated successfully' });\n}\n\nasync function passwordForgot(req: Request<any, any>, res): Promise<any> {\n  const _email = req.body.email;\n  if (!_email) {\n    NcError.badRequest('Please enter your email address.');\n  }\n\n  const email = _email.toLowerCase();\n  const user = await User.getByEmail(email);\n\n  if (user) {\n    const token = uuidv4();\n    await User.update(user.id, {\n      email: user.email,\n      reset_password_token: token,\n      reset_password_expires: new Date(Date.now() + 60 * 60 * 1000),\n      token_version: null\n    });\n    try {\n      const template = (await import('./ui/emailTemplates/forgotPassword'))\n        .default;\n      await NcPluginMgrv2.emailAdapter().then(adapter =>\n        adapter.mailSend({\n          to: user.email,\n          subject: 'Password Reset Link',\n          text: `Visit following link to update your password : ${\n            (req as any).ncSiteUrl\n          }/api/v1/db/auth/password/reset/${token}.`,\n          html: ejs.render(template, {\n            resetLink:\n              (req as any).ncSiteUrl + `/api/v1/db/auth/password/reset/${token}`\n          })\n        })\n      );\n    } catch (e) {\n      console.log(e);\n      return NcError.badRequest(\n        'Email Plugin is not found. Please contact administrators to configure it in App Store first.'\n      );\n    }\n\n    Audit.insert({\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'PASSWORD_FORGOT',\n      user: user.email,\n      description: `requested for password reset `,\n      ip: (req as any).clientIp\n    });\n  } else {\n    return NcError.badRequest('Your email has not been registered.');\n  }\n  res.json({ msg: 'Please check your email to reset the password' });\n}\n\nasync function tokenValidate(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    reset_password_token: token\n  });\n\n  if (!user || !user.email) {\n    NcError.badRequest('Invalid reset url');\n  }\n  if (user.reset_password_expires < new Date()) {\n    NcError.badRequest('Password reset url expired');\n  }\n  if (!user.token_version) {\n    NcError.badRequest('Token Expired. Please login again.');\n  }\n  res.json(true);\n}\n\nasync function passwordReset(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    reset_password_token: token\n  });\n\n  if (!user) {\n    NcError.badRequest('Invalid reset url');\n  }\n  if (user.reset_password_expires < new Date()) {\n    NcError.badRequest('Password reset url expired');\n  }\n  if (user.provider && user.provider !== 'local') {\n    NcError.badRequest('Email registered via social account');\n  }\n\n  const salt = await promisify(bcrypt.genSalt)(10);\n  const password = await promisify(bcrypt.hash)(req.body.password, salt);\n\n  await User.update(user.id, {\n    salt,\n    password,\n    email: user.email,\n    reset_password_expires: null,\n    reset_password_token: '',\n    token_version: null\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'PASSWORD_RESET',\n    user: user.email,\n    description: `did reset password `,\n    ip: req.clientIp\n  });\n\n  res.json({ msg: 'Password reset successful' });\n}\n\nasync function emailVerification(req, res): Promise<any> {\n  const token = req.params.tokenId;\n\n  const user = await Noco.ncMeta.metaGet(null, null, MetaTable.USERS, {\n    email_verification_token: token\n  });\n\n  if (!user) {\n    NcError.badRequest('Invalid verification url');\n  }\n\n  await User.update(user.id, {\n    email: user.email,\n    email_verification_token: '',\n    email_verified: true\n  });\n\n  Audit.insert({\n    op_type: 'AUTHENTICATION',\n    op_sub_type: 'EMAIL_VERIFICATION',\n    user: user.email,\n    description: `verified email `,\n    ip: req.clientIp\n  });\n\n  res.json({ msg: 'Email verified successfully' });\n}\n\nasync function refreshToken(req, res): Promise<any> {\n  try {\n    if (!req?.cookies?.refresh_token) {\n      return res.status(400).json({ msg: 'Missing refresh token' });\n    }\n\n    const user = await User.getByRefreshToken(req.cookies.refresh_token);\n\n    if (!user) {\n      return res.status(400).json({ msg: 'Invalid refresh token' });\n    }\n\n    const refreshToken = randomTokenString();\n\n    await User.update(user.id, {\n      email: user.email,\n      refresh_token: refreshToken\n    });\n\n    setTokenCookie(res, refreshToken);\n\n    res.json({\n      token: jwt.sign(\n        {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n          id: user.id,\n          roles: user.roles\n        },\n        Noco.getConfig().auth.jwt.secret,\n        Noco.getConfig().auth.jwt.options\n      )\n    } as any);\n  } catch (e) {\n    return res.status(400).json({ msg: e.message });\n  }\n}\n\nasync function renderPasswordReset(req, res): Promise<any> {\n  try {\n    res.send(\n      ejs.render((await import('./ui/auth/resetPassword')).default, {\n        token: JSON.stringify(req.params.tokenId),\n        baseUrl: `/`\n      })\n    );\n  } catch (e) {\n    return res.status(400).json({ msg: e.message });\n  }\n}\n\nconst mapRoutes = router => {\n  // todo: old api - /auth/signup?tool=1\n  router.post('/auth/user/signup', catchError(signup));\n  router.post('/auth/user/signin', catchError(signin));\n  router.get('/auth/user/me', extractProjectIdAndAuthenticate, catchError(me));\n  router.post('/auth/password/forgot', catchError(passwordForgot));\n  router.post('/auth/token/validate/:tokenId', catchError(tokenValidate));\n  router.post('/auth/password/reset/:tokenId', catchError(passwordReset));\n  router.post('/auth/email/validate/:tokenId', catchError(emailVerification));\n  router.post(\n    '/user/password/change',\n    ncMetaAclMw(passwordChange, 'passwordChange')\n  );\n  router.post('/auth/token/refresh', ncMetaAclMw(refreshToken, 'refreshToken'));\n\n  /* Google auth apis */\n\n  router.post(`/auth/google/genTokenByCode`, catchError(googleSignin));\n\n  router.get('/auth/google', (req: any, res, next) =>\n    passport.authenticate('google', {\n      scope: ['profile', 'email'],\n      state: req.query.state,\n      callbackURL: req.ncSiteUrl + Noco.getConfig().dashboardPath\n    })(req, res, next)\n  );\n\n  // new API\n  router.post('/api/v1/db/auth/user/signup', catchError(signup));\n  router.post('/api/v1/db/auth/user/signin', catchError(signin));\n  router.get(\n    '/api/v1/db/auth/user/me',\n    extractProjectIdAndAuthenticate,\n    catchError(me)\n  );\n  router.post('/api/v1/db/auth/password/forgot', catchError(passwordForgot));\n  router.post(\n    '/api/v1/db/auth/token/validate/:tokenId',\n    catchError(tokenValidate)\n  );\n  router.post(\n    '/api/v1/db/auth/password/reset/:tokenId',\n    catchError(passwordReset)\n  );\n  router.post(\n    '/api/v1/db/auth/email/validate/:tokenId',\n    catchError(emailVerification)\n  );\n  router.post(\n    '/api/v1/db/auth/password/change',\n    ncMetaAclMw(passwordChange, 'passwordChange')\n  );\n  router.post(\n    '/api/v1/db/auth/token/refresh',\n    ncMetaAclMw(refreshToken, 'refreshToken')\n  );\n  router.get(\n    '/api/v1/db/auth/password/reset/:tokenId',\n    catchError(renderPasswordReset)\n  );\n};\nexport { mapRoutes as userApis };\n", "import projectAcl from '../../utils/projectAcl';\nimport { NextFunction, Request, Response } from 'express';\nimport catchError, { NcError } from './catchError';\nimport extractProjectIdAndAuthenticate from './extractProjectIdAndAuthenticate';\n\nexport default function(handlerFn, permissionName) {\n  return [\n    extractProjectIdAndAuthenticate,\n    catchError(async function authMiddleware(req, _res, next) {\n      const roles = req?.session?.passport?.user?.roles;\n      if (\n        !(\n          roles?.creator ||\n          roles?.owner ||\n          roles?.editor ||\n          roles?.viewer ||\n          roles?.commenter ||\n          roles?.user ||\n          roles?.user_new\n        )\n      ) {\n        NcError.unauthorized('Unauthorized access');\n      }\n      next();\n    }),\n    // @ts-ignore\n    catchError(async function projectAclMiddleware(\n      req: Request<any, any, any, any, any>,\n      _res: Response,\n      next: NextFunction\n    ) {\n      // if (req['files'] && req.body.json) {\n      //   req.body = JSON.parse(req.body.json);\n      // }\n      // if (req['session']?.passport?.user?.isAuthorized) {\n      //   if (\n      //     req?.body?.project_id &&\n      //     !req['session']?.passport?.user?.isPublicBase &&\n      //     !(await this.xcMeta.isUserHaveAccessToProject(\n      //       req?.body?.project_id,\n      //       req['session']?.passport?.user?.id\n      //     ))\n      //   ) {\n      //     return res\n      //       .status(403)\n      //       .json({ msg: \"User doesn't have project access\" });\n      //   }\n      //\n      //   if (req?.body?.api) {\n\n      // todo : verify user have access to project or not\n\n      const roles = req['session']?.passport?.user?.roles;\n      const isAllowed =\n        roles &&\n        Object.entries(roles).some(([name, hasRole]) => {\n          return (\n            hasRole &&\n            projectAcl[name] &&\n            (projectAcl[name] === '*' || projectAcl[name][permissionName])\n          );\n        });\n      if (!isAllowed) {\n        NcError.forbidden(\n          `${permissionName} - ${Object.keys(roles).filter(\n            k => roles[k]\n          )} : Not allowed`\n        );\n      }\n      //   }\n      // }\n      next();\n    }),\n    catchError(handlerFn)\n  ];\n}\n", "import * as nc_011 from './v2/nc_011';\nimport * as nc_012_alter_column_data_types from './v2/nc_012_alter_column_data_types';\nimport * as nc_013_sync_source from './v2/nc_013_sync_source';\nimport * as nc_014_alter_column_data_types from './v2/nc_014_alter_column_data_types';\nimport * as nc_015_add_meta_col_in_column_table from './v2/nc_015_add_meta_col_in_column_table';\nimport * as nc_016_alter_hooklog_payload_types from './v2/nc_016_alter_hooklog_payload_types';\nimport * as nc_017_add_user_token_version_column from './v2/nc_017_add_user_token_version_column';\n\n// Create a custom migration source class\nexport default class XcMigrationSourcev2 {\n  // Must return a Promise containing a list of migrations.\n  // Migrations can be whatever you want, they will be passed as\n  // arguments to getMigrationName and getMigration\n  public getMigrations(): Promise<any> {\n    // In this run we are just returning migration names\n    return Promise.resolve([\n      'nc_011',\n      'nc_012_alter_column_data_types',\n      'nc_013_sync_source',\n      'nc_014_alter_column_data_types',\n      'nc_015_add_meta_col_in_column_table',\n      'nc_016_alter_hooklog_payload_types',\n      'nc_017_add_user_token_version_column'\n    ]);\n  }\n\n  public getMigrationName(migration): string {\n    return migration;\n  }\n\n  public getMigration(migration): any {\n    switch (migration) {\n      case 'nc_011':\n        return nc_011;\n      case 'nc_012_alter_column_data_types':\n        return nc_012_alter_column_data_types;\n      case 'nc_013_sync_source':\n        return nc_013_sync_source;\n      case 'nc_014_alter_column_data_types':\n        return nc_014_alter_column_data_types;\n      case 'nc_015_add_meta_col_in_column_table':\n        return nc_015_add_meta_col_in_column_table;\n      case 'nc_016_alter_hooklog_payload_types':\n        return nc_016_alter_hooklog_payload_types;\n      case 'nc_017_add_user_token_version_column':\n        return nc_017_add_user_token_version_column;\n    }\n  }\n}\n\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import Knex from 'knex';\n\nconst up = async (knex: Knex) => {\n  await knex.schema.alterTable('nc_users_v2', table => {\n    table.string('token_version');\n  });\n};\n\nconst down = async knex => {\n  await knex.schema.alterTable('nc_users_v2', table => {\n    table.dropColumns('token_version');\n  });\n};\n\nexport { up, down };\n\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n", "import { UserType } from 'nocodb-sdk';\nimport { CacheGetType, CacheScope, MetaTable } from '../utils/globals';\nimport Noco from '../Noco';\nimport extractProps from '../meta/helpers/extractProps';\nimport NocoCache from '../cache/NocoCache';\nexport default class User implements UserType {\n  id: number;\n\n  /** @format email */\n  email: string;\n\n  password?: string;\n  salt?: string;\n  firstname: string;\n  lastname: string;\n  username?: string;\n  refresh_token?: string;\n  invite_token?: string;\n  invite_token_expires?: number | Date;\n  reset_password_expires?: number | Date;\n  reset_password_token?: string;\n  email_verification_token?: string;\n  email_verified: boolean;\n  roles?: string;\n  token_version?: string;\n\n  constructor(data: User) {\n    Object.assign(this, data);\n  }\n\n  public static async insert(user: Partial<User>, ncMeta = Noco.ncMeta) {\n    const insertObj = extractProps(user, [\n      'id',\n      'email',\n      'password',\n      'salt',\n      'firstname',\n      'lastname',\n      'username',\n      'refresh_token',\n      'invite_token',\n      'invite_token_expires',\n      'reset_password_expires',\n      'reset_password_token',\n      'email_verification_token',\n      'email_verified',\n      'roles',\n      'token_version'\n    ]);\n    const { id } = await ncMeta.metaInsert2(\n      null,\n      null,\n      MetaTable.USERS,\n      insertObj\n    );\n\n    await NocoCache.del(CacheScope.INSTANCE_META);\n\n    return this.get(id, ncMeta);\n  }\n  public static async update(id, user: Partial<User>, ncMeta = Noco.ncMeta) {\n    const updateObj = extractProps(user, [\n      'email',\n      'password',\n      'salt',\n      'firstname',\n      'lastname',\n      'username',\n      'refresh_token',\n      'invite_token',\n      'invite_token_expires',\n      'reset_password_expires',\n      'reset_password_token',\n      'email_verification_token',\n      'email_verified',\n      'roles',\n      'token_version'\n    ]);\n    // get existing cache\n    const keys = [\n      // update user:<id>\n      `${CacheScope.USER}:${id}`,\n      // update user:<email>\n      `${CacheScope.USER}:${user.email}`\n    ];\n    for (const key of keys) {\n      let o = await NocoCache.get(key, CacheGetType.TYPE_OBJECT);\n      if (o) {\n        o = { ...o, ...updateObj };\n        // set cache\n        await NocoCache.set(key, o);\n      }\n    }\n    // as <projectId> is unknown, delete user:<email>___<projectId> in cache\n    await NocoCache.delAll(CacheScope.USER, `${user.email}___*`);\n\n    // set meta\n    return await ncMeta.metaUpdate(null, null, MetaTable.USERS, updateObj, id);\n  }\n  public static async getByEmail(email, ncMeta = Noco.ncMeta) {\n    let user =\n      email &&\n      (await NocoCache.get(\n        `${CacheScope.USER}:${email}`,\n        CacheGetType.TYPE_OBJECT\n      ));\n    if (!user) {\n      user = await ncMeta.metaGet2(null, null, MetaTable.USERS, {\n        email\n      });\n      await NocoCache.set(`${CacheScope.USER}:${email}`, user);\n    }\n    return user;\n  }\n\n  static async isFirst(ncMeta = Noco.ncMeta) {\n    const isFirst = !(await NocoCache.getAll(`${CacheScope.USER}:*`))?.length;\n    if (isFirst)\n      return !(await ncMeta.metaGet2(null, null, MetaTable.USERS, {}));\n    return false;\n  }\n\n  static async count(ncMeta = Noco.ncMeta) {\n    return (\n      await ncMeta\n        .knex(MetaTable.USERS)\n        .count('id', { as: 'count' })\n        .first()\n    )?.count;\n  }\n\n  static async get(userId, ncMeta = Noco.ncMeta) {\n    let user =\n      userId &&\n      (await NocoCache.get(\n        `${CacheScope.USER}:${userId}`,\n        CacheGetType.TYPE_OBJECT\n      ));\n    if (!user) {\n      user = await ncMeta.metaGet2(null, null, MetaTable.USERS, userId);\n      await NocoCache.set(`${CacheScope.USER}:${userId}`, user);\n    }\n    return user;\n  }\n\n  static async getByRefreshToken(refresh_token, ncMeta = Noco.ncMeta) {\n    const user = await ncMeta.metaGet2(null, null, MetaTable.USERS, {\n      refresh_token\n    });\n    return user;\n  }\n}\n", "import { promisify } from 'util';\n\nimport bcrypt from 'bcryptjs';\nimport * as ejs from 'ejs';\nimport * as jwt from 'jsonwebtoken';\nimport { Tele } from 'nc-help';\nimport passport from 'passport';\nimport { Strategy as AuthTokenStrategy } from 'passport-auth-token';\nimport { Strategy as GithubStrategy } from 'passport-github';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport validator from 'validator';\n\nimport { DbConfig, NcConfig } from '../../../interface/config';\nimport { Knex } from '../../db/sql-data-mapper';\nimport Noco from '../../Noco';\n\nconst autoBind = require('auto-bind');\nconst PassportLocalStrategy = require('passport-local').Strategy;\nimport { Strategy as CustomStrategy } from 'passport-custom';\n\nconst { v4: uuidv4 } = require('uuid');\n\nimport * as crypto from 'crypto';\n\nimport NcMetaIO from '../../meta/NcMetaIO';\n\nconst { isEmail } = require('validator');\n\nimport axios from 'axios';\n\nimport IEmailAdapter from '../../../interface/IEmailAdapter';\nimport XcCache from '../plugins/adapters/cache/XcCache';\n\npassport.serializeUser(function(\n  {\n    id,\n    email,\n    email_verified,\n    roles: _roles,\n    provider,\n    firstname,\n    lastname,\n    isAuthorized,\n    isPublicBase,\n    token_version\n  },\n  done\n) {\n  const roles = (_roles || '')\n    .split(',')\n    .reduce((obj, role) => Object.assign(obj, { [role]: true }), {});\n  if (roles.owner) {\n    roles.creator = true;\n  }\n  done(null, {\n    isAuthorized,\n    isPublicBase,\n    id,\n    email,\n    email_verified,\n    provider,\n    firstname,\n    lastname,\n    roles,\n    token_version\n  });\n});\n\npassport.deserializeUser(function(user, done) {\n  done(null, user);\n});\n\nconst NC_ROLES = 'nc_roles';\nconst NC_ACL = 'nc_acl';\nexport default class RestAuthCtrl {\n  protected app: Noco;\n\n  protected dbDriver: Knex;\n  // @ts-ignore\n  protected connectionConfig: DbConfig;\n  protected config: NcConfig;\n\n  protected jwtOptions: any;\n\n  protected xcMeta: NcMetaIO;\n\n  public static instance: RestAuthCtrl;\n\n  protected apiTokens: Array<{\n    token: string;\n    [key: string]: any;\n  }>;\n\n  // private router:Router;\n\n  constructor(\n    app: Noco,\n    dbDriver: Knex,\n    connectionConfig: DbConfig,\n    config: NcConfig,\n    xcMeta?: NcMetaIO\n  ) {\n    this.app = app;\n    this.dbDriver = dbDriver;\n    this.connectionConfig = connectionConfig;\n    this.config = config;\n    this.xcMeta = xcMeta;\n    autoBind(this);\n    // todo: default secret generation\n    this.config.auth.jwt.secret = this.config?.auth?.jwt?.secret ?? 'secret';\n    this.jwtOptions = {\n      secretOrKey: this.config.auth.jwt.secret,\n      expiresIn: process.env.NC_JWT_EXPIRES_IN ?? '10h'\n    };\n    this.jwtOptions.jwtFromRequest = ExtractJwt.fromHeader('xc-auth');\n    if (this.config?.auth?.jwt?.options) {\n      Object.assign(this.jwtOptions, this.config?.auth?.jwt?.options);\n    }\n    // this.router = Router();\n    RestAuthCtrl.instance = this;\n  }\n\n  get users(): any {\n    return this.dbDriver('xc_users');\n  }\n\n  async init() {\n    await this.loadLatestApiTokens();\n    await this.createAuthTableIfNotExists();\n\n    await this.initStrategies();\n    Tele.emit('evt_app_started', await this.users.count('id as count').first());\n    this.app.router.use(passport.initialize());\n\n    const jwtMiddleware = passport.authenticate('jwt', { session: false });\n\n    this.app.router.get('/password/reset/:token', async function(req, res) {\n      res.send(\n        ejs.render((await import('./ui/auth/resetPassword')).default, {\n          token: JSON.stringify(req.params?.token),\n          baseUrl: `/`\n        })\n      );\n    });\n    this.app.router.get('/email/verify/:token', async (req, res) => {\n      res.send(\n        ejs.render((await import('./ui/auth/emailVerify')).default, {\n          token: JSON.stringify(req.params?.token),\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.get('/signin', async (_req, res) => {\n      res.send(\n        ejs.render((await import('./ui/auth/signin')).default, {\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.get('/signup', async (_req, res) => {\n      res.render(\n        ejs.render((await import('./ui/auth/signup')).default, {\n          baseUrl: `/`\n        })\n      );\n    });\n\n    this.app.router.post(`/auth/signin`, this.signin);\n\n    this.app.router.post(`/auth/signup`, this.signup);\n    this.app.router.post(`/auth/refresh-token`, this.refreshToken);\n\n    /* Google auth apis */\n\n    this.app.router.post(`/auth/google/genTokenByCode`, this.googleSignin);\n\n    this.app.router.get('/auth/google', (req: any, res, next) =>\n      passport.authenticate('google', {\n        scope: ['profile', 'email'],\n        state: req.query.state,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      })(req, res, next)\n    );\n    /* Github auth apis */\n\n    this.app.router.post(`/auth/github/genTokenByCode`, this.githubSignin);\n\n    this.app.router.get('/auth/github', (req: any, res, next) =>\n      passport.authenticate('github', {\n        scope: ['profile', 'email'],\n        state: `github|${req.query.state || ''}`,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      })(req, res, next)\n    );\n\n    /*\n        this.app.router.get('/auth/azureadoauth2',\n          passport.authenticate('azure_ad_oauth2'));\n\n        this.app.router.get('/auth/azureadoauth2/callback',\n          passport.authenticate('azure_ad_oauth2', { failureRedirect: '/login' }),\n           (_req, res) => {\n            // Successful authentication, redirect home.\n            res.redirect('/');\n          });\n    */\n\n    this.app.router.post(`/auth/password/forgot`, this.passwordForgot);\n    this.app.router.post(`/auth/token/validate/:tokenId`, this.tokenValidate);\n    this.app.router.post(`/auth/password/reset/:tokenId`, this.passwordReset);\n    this.app.router.post(\n      `/user/password/change`,\n      jwtMiddleware,\n      this.passwordChange\n    );\n    this.app.router.post(\n      `/auth/email/validate/:tokenId`,\n      this.emailVerification\n    );\n    this.app.router.put(`/user`, jwtMiddleware, this.updateUser);\n\n    // middleware for setting passport user( for treating non-authenticated user as guest)\n    this.app.router.use(async (req, res, next) => {\n      const user = await new Promise(resolve => {\n        passport.authenticate(\n          'jwt',\n          { session: false },\n          (_err, user, _info) => {\n            if (user && !req.headers['xc-shared-base-id']) {\n              if (\n                req.path.indexOf('/user/me') === -1 &&\n                req.header('xc-preview') &&\n                /(?:^|,)(?:owner|creator)(?:$|,)/.test(user.roles)\n              ) {\n                return resolve({\n                  ...user,\n                  isAuthorized: true,\n                  roles: req.header('xc-preview')\n                });\n              }\n\n              return resolve({ ...user, isAuthorized: true });\n            }\n\n            if (req.headers['xc-token']) {\n              passport.authenticate(\n                'authtoken',\n                {\n                  session: false,\n                  optional: false\n                },\n                (_err, user, _info) => {\n                  if (user) {\n                    return resolve({\n                      ...user,\n                      isAuthorized: true,\n                      roles:\n                        user.roles === 'owner' ? 'owner,creator' : user.roles\n                    });\n                  } else {\n                    resolve({ roles: 'guest' });\n                  }\n                }\n              )(req, res, next);\n            } else if (req.headers['xc-shared-base-id']) {\n              passport.authenticate('baseView', {}, (_err, user, _info) => {\n                if (user) {\n                  return resolve({\n                    ...user,\n                    isAuthorized: true,\n                    isPublicBase: true\n                  });\n                } else {\n                  resolve({ roles: 'guest' });\n                }\n              })(req, res, next);\n            } else {\n              resolve({ roles: 'guest' });\n            }\n          }\n        )(req, res, next);\n      });\n\n      await promisify((req as any).login.bind(req))(user);\n      next();\n    });\n\n    this.app.router.get(`/user/me`, this.me);\n    this.app.router.post(`/auth/signout`, this.signout);\n\n    /* Admin APIs */\n    this.app.router.use('/admin', this.isAdmin);\n\n    this.app.router.get('/admin/roles', this.listRoles);\n    this.app.router.delete('/admin/roles/:id', this.deleteRole);\n    this.app.router.put('/admin/roles', this.saveOrUpdateRoles);\n\n    this.app.router.post('/admin', this.addAdmin);\n    this.app.router.put('/admin/:id', this.updateAdmin);\n    this.app.router.delete('/admin/:id', this.deleteAdmin);\n    this.app.router.get('/admin', this.listUsers);\n    this.app.router.post('/admin/resendInvite/:id', this.resendInvite);\n  }\n\n  public async initStrategies(): Promise<void> {\n    const self = this;\n\n    passport.use(\n      'authtoken',\n      new AuthTokenStrategy({ headerFields: ['xc-token'] }, (token, done) => {\n        const apiToken = this.apiTokens?.find(t => t.token === token);\n        if (apiToken) {\n          done(null, { roles: 'editor' });\n        } else {\n          return done({ msg: 'Invalid tok' });\n        }\n      })\n    );\n    this.initCustomStrategy();\n    this.initJwtStrategy();\n\n    passport.use(\n      new PassportLocalStrategy(\n        {\n          usernameField: 'email',\n          session: false\n        },\n        async (email, password, done) => {\n          try {\n            const user = await self.users.where({ email }).first();\n            if (!user) {\n              return done({ msg: `Email ${email} is not registered!` });\n            }\n            const hashedPassword = await promisify(bcrypt.hash)(\n              password,\n              user.salt\n            );\n            if (user.password !== hashedPassword) {\n              return done({ msg: `Password not valid!` });\n            } else {\n              return done(null, user);\n            }\n          } catch (e) {\n            done(e);\n          }\n        }\n      )\n    );\n\n    const googlePlugin = await this.xcMeta.metaGet(null, null, 'nc_plugins', {\n      title: 'Google'\n    });\n\n    if (googlePlugin && googlePlugin.input) {\n      const settings = JSON.parse(googlePlugin.input);\n      process.env.NC_GOOGLE_CLIENT_ID = settings.client_id;\n      process.env.NC_GOOGLE_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GOOGLE_CLIENT_ID &&\n      process.env.NC_GOOGLE_CLIENT_SECRET\n    ) {\n      const googleAuthParamsOrig = GoogleStrategy.prototype.authorizationParams;\n      GoogleStrategy.prototype.authorizationParams = (options: any) => {\n        const params = googleAuthParamsOrig.call(this, options);\n\n        if (options.state) {\n          params.state = options.state;\n        }\n\n        return params;\n      };\n\n      const clientConfig = {\n        clientID: process.env.NC_GOOGLE_CLIENT_ID,\n        clientSecret: process.env.NC_GOOGLE_CLIENT_SECRET,\n        // todo: update url\n        callbackURL: 'http://localhost:3000',\n        passReqToCallback: true\n      };\n\n      const googleStrategy = new GoogleStrategy(\n        clientConfig,\n        async (req, _accessToken, _refreshToken, profile, cb) => {\n          try {\n            const email = profile.emails[0].value;\n\n            let user = await this.users\n              .where({\n                email\n              })\n              .first();\n            const token = req.query.state;\n\n            if (token) {\n              Tele.emit('evt_subscribe', email);\n              await this.users\n                .update({\n                  // firstname, lastname,\n                  // email_verification_token,\n                  invite_token: null,\n                  invite_token_expires: null,\n                  email_verified: true\n                })\n                .where({\n                  email,\n                  invite_token: token\n                });\n            } else {\n              let roles = 'editor';\n\n              if (!(await this.users.first())) {\n                roles = 'owner';\n              }\n\n              if (!user) {\n                if (roles === 'editor') {\n                  return cb({ msg: `Account not found!` });\n                }\n\n                Tele.emit('evt_subscribe', email);\n                const salt = await promisify(bcrypt.genSalt)(10);\n                user = await this.users.insert({\n                  email: profile.emails[0].value,\n                  password: '',\n                  salt,\n                  roles,\n                  email_verified: true\n                });\n              } else {\n                await this.users\n                  .update({\n                    email_verified: true\n                  })\n                  .where({\n                    email\n                  });\n              }\n              user = await this.users\n                .where({\n                  email\n                })\n                .first();\n            }\n            cb(null, user);\n          } catch (e) {\n            cb(e, null);\n          }\n        }\n      );\n\n      passport.use(googleStrategy);\n    }\n\n    const githubPlugin = await this.xcMeta.metaGet(null, null, 'nc_plugins', {\n      title: 'Github'\n    });\n    if (githubPlugin && githubPlugin.input) {\n      const settings = JSON.parse(githubPlugin.input);\n      process.env.NC_GITHUB_CLIENT_ID = settings.client_id;\n      process.env.NC_GITHUB_CLIENT_SECRET = settings.client_secret;\n    }\n\n    if (\n      process.env.NC_GITHUB_CLIENT_ID &&\n      process.env.NC_GITHUB_CLIENT_SECRET\n    ) {\n      const githubStrategy = new GithubStrategy(\n        {\n          clientID: process.env.NC_GITHUB_CLIENT_ID,\n          clientSecret: process.env.NC_GITHUB_CLIENT_SECRET,\n          // callbackURL: app.$config.auth.github.callbackUrl,\n          passReqToCallback: true\n        },\n        async (req, accessToken, _refreshToken, profile, cb) => {\n          try {\n            let email =\n              profile.emails && profile.emails[0] && profile.emails[0].value;\n            if (!email) {\n              const res = await axios.get('https://api.github.com/user', {\n                headers: {\n                  Authorization: 'token ' + accessToken\n                }\n              });\n              if (res.data && res.data.length) {\n                email = res.data[0].email;\n              } else {\n                return cb(null, false, {\n                  message:\n                    'There is no email id associated to your github account.'\n                });\n              }\n            }\n\n            let user = await this.users\n              .where({\n                email\n              })\n              .first();\n            const token = req.query?.state?.replace('github|', '');\n\n            if (token) {\n              Tele.emit('evt_subscribe', email);\n              await this.users\n                .update({\n                  // firstname, lastname,\n                  // email_verification_token,\n                  invite_token: null,\n                  invite_token_expires: null,\n                  email_verified: true\n                })\n                .where({\n                  email,\n                  invite_token: token\n                });\n            } else {\n              let roles = 'editor';\n\n              if (!(await this.users.first())) {\n                roles = 'owner';\n              }\n\n              if (!user) {\n                if (roles === 'editor') {\n                  return cb({ msg: `Account not found!` });\n                }\n\n                Tele.emit('evt_subscribe', email);\n                const salt = await promisify(bcrypt.genSalt)(10);\n                user = await this.users.insert({\n                  email: profile.emails[0].value,\n                  password: '',\n                  salt,\n                  roles,\n                  email_verified: true\n                });\n              } else {\n                await this.users\n                  .update({\n                    email_verified: true\n                  })\n                  .where({\n                    email\n                  });\n              }\n              user = await this.users\n                .where({\n                  email\n                })\n                .first();\n            }\n            cb(null, user);\n          } catch (e) {\n            cb(e, null);\n          }\n        }\n      );\n\n      passport.use(githubStrategy);\n    }\n\n    /*    passport.use(new AzureAdOAuth2Strategy({\n\n          },\n          (_accessToken, _refresh_token, params, profile, done) => {\n            // currently we can't find a way to exchange access token by user info (see userProfile implementation), so\n            // you will need a jwt-package like https://github.com/auth0/node-jsonwebtoken to decode id_token and get waad profile\n            const waadProfile = profile || jwt.decode(params.id_token);\n\n            // this is just an run: here you would provide a model *User* with the function *findOrCreate*\n            done(waadProfile)\n          }));*/\n  }\n\n  protected initJwtStrategy() {\n    passport.use(\n      new Strategy(this.jwtOptions, (jwtPayload, done) => {\n        this.users\n          .where({\n            email: jwtPayload?.email\n          })\n          .first()\n          .then(user => {\n            if (user) {\n              user.roles = 'owner';\n              return done(null, user);\n            } else {\n              return done(new Error('User not found'));\n            }\n          })\n          .catch(err => {\n            return done(err);\n          });\n      })\n    );\n  }\n\n  protected initCustomStrategy() {\n    passport.use(\n      'baseView',\n      new CustomStrategy(async (req: any, callback) => {\n        let user;\n        if (req.headers['xc-shared-base-id']) {\n          const cacheKey = `nc_shared_bases||${req.headers['xc-shared-base-id']}`;\n\n          let sharedBase = XcCache.get(cacheKey);\n\n          if (!sharedBase) {\n            sharedBase = await this.xcMeta\n              .knex('nc_shared_bases')\n              .where({\n                enabled: true,\n                shared_base_id: req.headers['xc-shared-base-id']\n              })\n              .first();\n            XcCache.set(cacheKey, sharedBase);\n          }\n          user = {\n            roles: sharedBase?.roles\n          };\n        }\n\n        callback(null, user);\n      })\n    );\n  }\n\n  protected async signin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'local',\n      { session: false },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              // err: { msg: string }\n              return res.status(400).send(err);\n            }\n            if (info) {\n              // info: { message: string }\n              // Info was thrown directly before.\n              // In order to avoid breaking change, both \"msg\" and \"message\" are returned.\n              return res.status(400).send({ msg: info.message ?? '' });\n            }\n            return res.status(400).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          this.xcMeta.audit(null, null, 'nc_audit', {\n            op_type: 'AUTHENTICATION',\n            op_sub_type: 'SIGNIN',\n            user: user.email,\n            ip: req.clientIp,\n            description: `signed in`\n          });\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async googleSignin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'google',\n      {\n        session: false,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              return res.status(400).send(err);\n            }\n            if (info) {\n              return res.status(400).send(info);\n            }\n            return res.status(500).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          this.xcMeta.audit(null, null, 'nc_audit', {\n            op_type: 'AUTHENTICATION',\n            op_sub_type: 'SIGNIN',\n            user: user.email,\n            ip: req.clientIp,\n            description: `signed in using Google Auth`\n          });\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async githubSignin(req, res, next): Promise<any> {\n    passport.authenticate(\n      'github',\n      {\n        session: false,\n        callbackURL: req.ncSiteUrl + this.config.dashboardPath\n      },\n      async (err, user, info): Promise<any> => {\n        try {\n          if (!user || !user.email) {\n            if (err) {\n              return res.status(400).send(err);\n            }\n            if (info) {\n              return res.status(400).send(info);\n            }\n            return res.status(500).send({ msg: 'Your signin has failed' });\n          }\n\n          await promisify((req as any).login.bind(req))(user);\n          const refreshToken = this.randomTokenString();\n\n          await this.users\n            .update({\n              refresh_token: refreshToken\n            })\n            .where({ id: user.id });\n\n          this.setTokenCookie(res, refreshToken);\n\n          res.json({\n            token: jwt.sign(\n              {\n                email: user.email,\n                firstname: user.firstname,\n                lastname: user.lastname,\n                id: user.id,\n                roles: user.roles\n              },\n              this.config.auth.jwt.secret,\n              this.config.auth.jwt.options\n            )\n          } as any);\n        } catch (e) {\n          console.log(e);\n          throw e;\n        }\n      }\n    )(req, res, next);\n  }\n\n  protected async refreshToken(req, res): Promise<any> {\n    console.log('token refresh');\n    try {\n      if (!req?.cookies?.refresh_token) {\n        return res.status(400).json({ msg: 'Missing refresh token' });\n      }\n\n      const user = await this.users\n        .where({\n          refresh_token: req.cookies.refresh_token\n        })\n        .first();\n\n      if (!user) {\n        return res.status(400).json({ msg: 'Invalid refresh token' });\n      }\n\n      const refreshToken = this.randomTokenString();\n\n      await this.users\n        .update({\n          refresh_token: refreshToken\n        })\n        .where({\n          id: user.id\n        });\n\n      this.setTokenCookie(res, refreshToken);\n\n      res.json({\n        token: jwt.sign(\n          {\n            email: user.email,\n            firstname: user.firstname,\n            lastname: user.lastname,\n            id: user.id,\n            roles: user.roles\n          },\n          this.config.auth.jwt.secret,\n          this.config.auth.jwt.options\n        )\n      } as any);\n    } catch (e) {\n      return res.status(400).json({ msg: e.message });\n    }\n  }\n\n  protected async signup(req, res, next): Promise<any> {\n    try {\n      const {\n        email: _email,\n        firstname,\n        lastname,\n        token,\n        ignore_subscribe\n      } = req.body;\n      let { password } = req.body;\n\n      if (!isEmail(_email)) {\n        return next(new Error(`Invalid email`));\n      }\n\n      const email = _email.toLowerCase();\n\n      let user = await this.users\n        .where({\n          email\n        })\n        .first();\n\n      if (user) {\n        if (token) {\n          if (token !== user.invite_token) {\n            return next(new Error(`Invalid invite url`));\n          } else if (user.invite_token_expires < new Date()) {\n            return next(\n              new Error(\n                'Expired invite url, Please contact super admin to get a new invite url'\n              )\n            );\n          }\n        } else {\n          // todo : opening up signup for timebeing\n          // return next(new Error(`Email '${email}' already registered`));\n        }\n      }\n\n      const salt = await promisify(bcrypt.genSalt)(10);\n      password = await promisify(bcrypt.hash)(password, salt);\n      const email_verification_token = uuidv4();\n\n      if (!ignore_subscribe) {\n        Tele.emit('evt_subscribe', email);\n      }\n\n      if (user) {\n        if (token) {\n          await this.users\n            .update({\n              firstname,\n              lastname,\n              salt,\n              password,\n              email_verification_token,\n              invite_token: null,\n              invite_token_expires: null\n            })\n            .where({\n              email,\n              invite_token: token\n            });\n        } else {\n          return next(new Error('User already exist'));\n        }\n      } else {\n        let roles = 'user';\n\n        if (!(await this.users.first())) {\n          // todo: update in nc_store\n          // roles = 'owner,creator,editor'\n          Tele.emit('evt', { evt_type: 'project:invite', count: 1 });\n        } else {\n          if (process.env.NC_INVITE_ONLY_SIGNUP) {\n            return next(\n              new Error('Not allowed to signup, contact super admin.')\n            );\n          } else {\n            roles = 'user_new';\n          }\n        }\n\n        await this.users.insert({\n          firstname,\n          lastname,\n          email,\n          salt,\n          password,\n          email_verification_token,\n          roles\n        });\n      }\n      user = await this.users\n        .where({\n          email\n        })\n        .first();\n\n      try {\n        const template = (await import('./ui/emailTemplates/verify')).default;\n        await this.emailClient.mailSend({\n          to: email,\n          subject: 'Verify email',\n          html: ejs.render(template, {\n            verifyLink:\n              req.ncSiteUrl + `/email/verify/${user.email_verification_token}`\n          })\n        });\n      } catch (e) {\n        console.log(\n          'Warning : `mailSend` failed, Please configure emailClient configuration.'\n        );\n      }\n      await promisify((req as any).login.bind(req))(user);\n      const refreshToken = this.randomTokenString();\n      await this.users\n        .update({\n          refresh_token: refreshToken\n        })\n        .where({\n          id: user.id\n        });\n\n      this.setTokenCookie(res, refreshToken);\n\n      user = (req as any).user;\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'SIGNUP',\n        user: user.email,\n        description: `signed up `,\n        ip: req.clientIp\n      });\n\n      res.json({\n        token: jwt.sign(\n          {\n            email: user.email,\n            firstname: user.firstname,\n            lastname: user.lastname,\n            id: user.id,\n            roles: user.roles\n          },\n          this.config.auth.jwt.secret\n        )\n      } as any);\n    } catch (e) {\n      console.log(e);\n      next(e);\n    }\n  }\n\n  protected async signout(req, res, next): Promise<any> {\n    try {\n      res.clearCookie('refresh_token');\n      const email = req?.session?.passport?.user?.email?.toLowerCase();\n\n      if (email) {\n        await this.users\n          .update({\n            refresh_token: null\n          })\n          .where({\n            email\n          });\n      }\n\n      res.json({ msg: 'Success' });\n    } catch (e) {\n      console.log(e);\n      next(e);\n    }\n  }\n\n  protected async passwordForgot(req, res, next): Promise<any> {\n    const _email = req.body.email;\n    if (!_email) {\n      return next(new Error('Please enter your email address.'));\n    }\n\n    const email = _email.toLowerCase();\n\n    const user = await this.users.where({ email }).first();\n    if (user) {\n      const token = uuidv4();\n      await this.users\n        .update({\n          reset_password_token: token,\n          reset_password_expires: new Date(Date.now() + 60 * 60 * 1000)\n        })\n        .where({ id: user.id });\n\n      try {\n        const template = (await import('./ui/emailTemplates/forgotPassword'))\n          .default;\n        await this.emailClient.mailSend({\n          to: user.email,\n          subject: 'Password Reset Link',\n          text: `Visit following link to update your password : ${req.ncSiteUrl}/password/reset/${token}.`,\n          html: ejs.render(template, {\n            resetLink: req.ncSiteUrl + `/password/reset/${token}`\n          })\n        });\n      } catch (e) {\n        console.log(\n          'Warning : `mailSend` failed, Please configure emailClient configuration.'\n        );\n      }\n      console.log(`Password reset token : ${token}`);\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'PASSWORD_FORGOT',\n        user: user.email,\n        description: `requested for password reset `,\n        ip: req.clientIp\n      });\n    }\n    res.json({ msg: 'Check your email if you are registered with us.' });\n  }\n\n  protected async tokenValidate(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ reset_password_token: token })\n      .first();\n    if (!user || !user.email) {\n      return next(new Error('Invalid reset url'));\n    }\n    if (user.reset_password_expires < new Date()) {\n      return next(new Error('Password reset url expired'));\n    }\n    res.json(true);\n  }\n\n  protected async passwordReset(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ reset_password_token: token })\n      .first();\n    if (!user) {\n      return next(new Error('Invalid reset url'));\n    }\n    if (user.reset_password_expires < new Date()) {\n      return next(new Error('Password reset url expired'));\n    }\n    if (user.provider && user.provider !== 'local') {\n      return next(new Error('Email registered via social account'));\n    }\n\n    const salt = await promisify(bcrypt.genSalt)(10);\n    const password = await promisify(bcrypt.hash)(req.body.password, salt);\n\n    await this.users\n      .update({\n        salt,\n        password,\n        reset_password_expires: null,\n        reset_password_token: ''\n      })\n      .where({\n        id: user.id\n      });\n\n    this.xcMeta.audit(null, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'PASSWORD_RESET',\n      user: user.email,\n      description: `did reset password `,\n      ip: req.clientIp\n    });\n\n    res.json({ msg: 'Password reset successful' });\n  }\n\n  protected async passwordChange(req, res, next): Promise<any> {\n    const { currentPassword, newPassword } = req.body;\n    if (req.isAuthenticated()) {\n      if (!currentPassword || !newPassword) {\n        return next(new Error('Missing new/old password'));\n      }\n      const user = await this.users.where({ email: req.user.email }).first();\n      const hashedPassword = await promisify(bcrypt.hash)(\n        currentPassword,\n        user.salt\n      );\n      if (hashedPassword !== user.password) {\n        return next(new Error('Current password is wrong'));\n      }\n\n      const salt = await promisify(bcrypt.genSalt)(10);\n      const password = await promisify(bcrypt.hash)(newPassword, salt);\n\n      await this.users\n        .update({\n          salt,\n          password\n        })\n        .where({ id: user.id });\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'PASSWORD_CHANGE',\n        user: user.email,\n        description: `changed password `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'Password updated successfully' });\n    }\n  }\n\n  protected async emailVerification(req, res, next): Promise<any> {\n    const token = req.params.tokenId;\n    const user = await this.users\n      .where({ email_verification_token: token })\n      .first();\n    if (!user) {\n      return next(new Error('Invalid verification url'));\n    }\n\n    await this.users\n      .update({\n        email_verification_token: '',\n        email_verified: true\n      })\n      .where({ id: user.id });\n\n    this.xcMeta.audit(null, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'EMAIL_VERIFICATION',\n      user: user.email,\n      description: `verified email `,\n      ip: req.clientIp\n    });\n\n    res.json({ msg: 'Email verified successfully' });\n  }\n\n  protected async me(req, res): Promise<any> {\n    res.json(req?.session?.passport?.user ?? {});\n  }\n\n  protected async updateUser(req, res): Promise<any> {\n    await this.users\n      .update({\n        firstname: req.body.firstname,\n        lastname: req.body.lastname\n      })\n      .where({\n        id: req.user.id\n      });\n    res.json({ msg: 'Updated successfully' });\n  }\n\n  /* Admin apis : START */\n\n  // @ts-ignore\n  protected async isSuperAdmin(req, res, next): Promise<any> {\n    if (req.session?.passport?.user?.roles?.owner) {\n      return next();\n    }\n    res.status(401).json({ msg: 'Access denied' });\n  }\n\n  protected async isAdmin(req, res, next): Promise<any> {\n    if (\n      req.session?.passport?.user?.roles?.owner ||\n      req.session?.passport?.user?.roles?.creator ||\n      req?.session?.passport?.user?.roles?.editor\n    ) {\n      return next();\n    }\n    res.status(403).json({ msg: 'Access denied' });\n  }\n\n  protected async addAdmin(req, res, next): Promise<any> {\n    // if (!this.config?.mailer || !this.emailClient) {\n    //   return next(new Error('SMTP config is not found'));\n    // }\n\n    const _email = req.body.email;\n\n    if (!_email || !validator.isEmail(_email)) {\n      return next(new Error('Invalid email address'));\n    }\n    const email = _email.toLowerCase();\n    // todo: handle roles which contains super\n    if (\n      !req.session?.passport?.user?.roles?.owner &&\n      req.body.roles.indexOf('owner') > -1\n    ) {\n      return next(new Error('Insufficient privilege to add super admin role.'));\n    }\n\n    const invite_token = uuidv4();\n    let count;\n    const user = await this.users.where({ email }).first();\n    if (user) {\n      if (\n        !(await this.xcMeta.isUserHaveAccessToProject(\n          req.body.project_id,\n          user.id\n        ))\n      ) {\n        await this.xcMeta.projectAddUser(\n          req.body.project_id,\n          user.id,\n          'creator'\n        );\n      }\n    } else {\n      try {\n        await this.users.insert({\n          invite_token,\n          invite_token_expires: new Date(Date.now() + 24 * 60 * 60 * 1000),\n          email\n        });\n        count = await this.users.count('id as count').first();\n\n        const { id } = await this.users.where({ email }).first();\n        await this.xcMeta.projectAddUser(req.body.project_id, id, 'creator');\n\n        if (!(await this.sendInviteEmail(email, invite_token, req))) {\n          res.json({ invite_token, email });\n        }\n      } catch (e) {\n        return next(e);\n      }\n    }\n\n    Tele.emit('evt', { evt_type: 'project:invite', count: count?.count });\n    this.xcMeta.audit(req.body.project_id, null, 'nc_audit', {\n      op_type: 'AUTHENTICATION',\n      op_sub_type: 'INVITE',\n      user: req.user.email,\n      description: `invited ${email} to ${req.body.project_id} project `,\n      ip: req.clientIp\n    });\n\n    res.json({\n      msg: 'success'\n    });\n  }\n\n  protected async updateAdmin(req, res, next): Promise<any> {\n    if (!req?.body?.project_id) {\n      return next(new Error('Missing project id in request body.'));\n    }\n    if (\n      req.session?.passport?.user?.roles?.owner &&\n      req.session?.passport?.user?.id === +req.params.id &&\n      req.body.roles.indexOf('owner') === -1\n    ) {\n      return next(new Error(\"Super admin can't remove Super role themselves\"));\n    }\n    try {\n      const user = await this.users\n        .where({\n          id: req.params.id\n        })\n        .first();\n\n      if (!user) {\n        return next(`User with id '${req.params.id}' doesn't exist`);\n      }\n\n      // todo: handle roles which contains super\n      if (\n        !req.session?.passport?.user?.roles?.owner &&\n        req.body.roles.indexOf('owner') > -1\n      ) {\n        return next(\n          new Error('Insufficient privilege to add super admin role.')\n        );\n      }\n\n      // await this.users.update({\n      //   roles: 'creator'\n      // }).where({\n      //   id: req.params.id\n      // });\n      await this.xcMeta.metaUpdate(\n        req?.body?.project_id,\n        null,\n        'nc_projects_users',\n        {\n          roles: 'creator'\n        },\n        {\n          user_id: req.params.id\n        }\n      );\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'ROLES_MANAGEMENT',\n        user: req.user.email,\n        description: `updated roles for ${user.email} with ${req.body.roles} `,\n        ip: req.clientIp\n      });\n\n      res.json({\n        msg: 'User details updated successfully'\n      });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async deleteAdmin(req, res, next): Promise<any> {\n    try {\n      const { project_id, type } = req.query;\n\n      if (req.session?.passport?.user?.id === +req.params.id) {\n        return next(new Error(\"Admin can't delete themselves!\"));\n      }\n\n      if (!req.session?.passport?.user?.roles?.owner) {\n        const deleteUser = await this.users\n          .where('id', req.params.id)\n          .andWhere('roles', 'like', '%super%')\n          .first();\n        if (deleteUser) {\n          return next(\n            new Error('Insufficient privilege to delete a super admin user.')\n          );\n        }\n      }\n      if (type === 'DELETE_FROM_PROJECT') {\n        // remove user from Project\n        XcCache.del(`${req?.query?.email}___${req?.req?.project_id}`);\n        await this.xcMeta.projectRemoveUser(project_id, req.params.id);\n      } else if (type === 'DELETE_FROM_NOCODB') {\n        // remove user from NocoDB\n        await this.xcMeta.removeXcUser(req.params.id);\n      } else {\n        new Error('Invalid type is provided.');\n      }\n    } catch (e) {\n      return next(e);\n    }\n    res.json({\n      msg: 'success'\n    });\n  }\n\n  protected async listUsers(req, res, next): Promise<any> {\n    try {\n      const { offset = 0, limit = 20, query, project_id } = req.query;\n      let count;\n\n      const queryBuilder = this.users\n        .select(\n          'xc_users.*',\n          'nc_projects_users.project_id',\n          'nc_projects_users.roles as roles'\n        )\n        .offset(offset)\n        .limit(limit);\n\n      if (query) {\n        queryBuilder.where('email', 'like', `%${query}%`);\n      }\n      const self = this;\n      queryBuilder.leftJoin('nc_projects_users', function() {\n        this.on('nc_projects_users.user_id', '=', 'xc_users.id').andOn(\n          'nc_projects_users.project_id',\n          '=',\n          self.xcMeta.knex.raw('?', [project_id])\n        );\n      });\n\n      if (!req.session?.passport?.user?.roles?.owner) {\n        queryBuilder.whereNot('nc_projects_users.roles', 'like', '%owner%');\n        count = (\n          await this.users\n            .count('id as count')\n            .whereNot('roles', 'like', '%owner%')\n            .first()\n        ).count;\n      } else {\n        count = (\n          await this.users\n            .count('id as count')\n            .where('email', 'like', `%${query}%`)\n            .first()\n        ).count;\n      }\n      const list = (await queryBuilder).map(\n        ({ password, salt, refresh_token, ...rest }) => rest\n      );\n\n      res.json({\n        list,\n        count,\n        offset,\n        limit\n      });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async resendInvite(req, res, next): Promise<any> {\n    try {\n      const user = await this.users.where({ id: req.params.id }).first();\n\n      if (!user) {\n        return next(new Error(`User with id '${req.params.id}' not found`));\n      }\n\n      req.body.roles = user.roles;\n      const invite_token = uuidv4();\n\n      await this.users\n        .update({\n          invite_token,\n          invite_token_expires: new Date(Date.now() + 24 * 60 * 60 * 1000)\n        })\n        .where({\n          id: user.id\n        });\n      await this.sendInviteEmail(user.email, invite_token, req);\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'RESEND_INVITE',\n        user: user.email,\n        description: `resent a invite to ${user.email} `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async sendInviteEmail(email, token, req): Promise<any> {\n    try {\n      const template = (await import('./ui/emailTemplates/invite')).default;\n\n      if (this.emailClient) {\n        await this.emailClient.mailSend({\n          to: email,\n          subject: 'Verify email',\n          html: ejs.render(template, {\n            signupLink: `${req.ncSiteUrl}${this.config?.dashboardPath}#/user/authentication/signup/${token}`,\n            projectName: req.body?.projectName,\n            roles: (req.body?.roles || '')\n              .split(',')\n              .map(r => r.replace(/^./, m => m.toUpperCase()))\n              .join(', '),\n            adminEmail: req.session?.passport?.user?.email\n          })\n        });\n        return true;\n      }\n      // throw new Error('SMTP not configured, sending email failed')\n      // } else {\n      //   await this.xcSendInviteEmail({\n      //     fromEmail: req.session?.passport?.user?.email,\n      //     projectName: 'NocoDB',\n      //     inviteUrl: `${req.ncSiteUrl}${this.config?.dashboardPath}#/user/authentication/signup/${token}`,\n      //     toEmail: email\n      //   })\n      // }\n    } catch (e) {\n      console.log(\n        'Warning : `mailSend` failed, Please configure emailClient configuration.',\n        e.message\n      );\n      throw e;\n    }\n  }\n\n  protected async saveOrUpdateRoles(req, res, next): Promise<any> {\n    try {\n      // todo: optimize transaction\n      for (const role of req.body.roles) {\n        if (role.id) {\n          const oldRole = await this.xcMeta.metaGet('', '', NC_ROLES, {\n            id: role.id\n          });\n\n          if (\n            oldRole.title !== role.title ||\n            oldRole.description !== role.description\n          ) {\n            await this.xcMeta.metaUpdate(\n              '',\n              '',\n              NC_ROLES,\n              {\n                ...role\n              },\n              {\n                id: role.id\n              }\n            );\n          }\n          if (oldRole.title !== role.title) {\n            for (const builder of (this.app as Noco).getBuilders()) {\n              try {\n                await this.xcMeta.startTransaction();\n                const aclRows = await this.xcMeta.metaList(\n                  '',\n                  builder.getDbAlias(),\n                  NC_ACL\n                );\n                for (const aclRow of aclRows) {\n                  if (aclRow.acl) {\n                    const acl = JSON.parse(aclRow.acl);\n                    acl[role.title] = acl[oldRole.title];\n                    delete acl[oldRole.title];\n                    await this.xcMeta.metaUpdate(\n                      '',\n                      builder.getDbAlias(),\n                      NC_ACL,\n                      {\n                        acl: JSON.stringify(acl)\n                      },\n                      aclRow.id\n                    );\n                  }\n                }\n                await this.xcMeta.commit();\n              } catch (e) {\n                await this.xcMeta.rollback(e);\n              }\n            }\n          }\n        } else {\n          if (\n            await this.xcMeta.metaGet('', '', NC_ROLES, { title: role.title })\n          ) {\n            return next(Error(`Role name '${role.title}' already exist`));\n          }\n\n          await this.xcMeta.metaInsert('', '', NC_ROLES, role);\n\n          for (const builder of (this.app as Noco).getBuilders()) {\n            try {\n              await this.xcMeta.startTransaction();\n              const aclRows = await this.xcMeta.metaList(\n                '',\n                builder.getDbAlias(),\n                NC_ACL\n              );\n              for (const aclRow of aclRows) {\n                if (aclRow.acl) {\n                  const acl = JSON.parse(aclRow.acl);\n                  acl[role.title] = true;\n                  await this.xcMeta.metaUpdate(\n                    '',\n                    builder.getDbAlias(),\n                    NC_ACL,\n                    {\n                      acl: JSON.stringify(acl)\n                    },\n                    {\n                      id: aclRow.id\n                    }\n                  );\n                }\n              }\n              await this.xcMeta.commit();\n            } catch (e) {\n              await this.xcMeta.rollback(e);\n            }\n          }\n        }\n      }\n\n      this.xcMeta.audit(null, null, 'nc_audit', {\n        op_type: 'AUTHENTICATION',\n        op_sub_type: 'ROLES_MANAGEMENT',\n        user: req.user.email,\n        description: `updated roles `,\n        ip: req.clientIp\n      });\n\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  // @ts-ignore\n  protected async deleteRole(req, res, next): Promise<any> {\n    try {\n      const role = await this.xcMeta.metaGet('', '', NC_ROLES, {\n        id: req.params.id\n      });\n      if (!role) {\n        return next(new Error(`Role with id '${req.params.id}' not found`));\n      }\n      const deleteRoleName = role.title;\n\n      // todo: update acl in all other database connection\n      for (const builder of (this.app as Noco).getBuilders()) {\n        try {\n          await this.xcMeta.startTransaction();\n          const aclRows = await this.xcMeta.metaList(\n            '',\n            builder.getDbAlias(),\n            NC_ACL\n          );\n          for (const aclRow of aclRows) {\n            if (aclRow.acl) {\n              const acl = JSON.parse(aclRow.acl);\n              delete acl[deleteRoleName];\n              await this.xcMeta.metaUpdate(\n                '',\n                builder.getDbAlias(),\n                NC_ACL,\n                {\n                  acl: JSON.stringify(acl)\n                },\n                {\n                  id: aclRow.id\n                }\n              );\n            }\n          }\n          await this.xcMeta.commit();\n        } catch (e) {\n          this.xcMeta.rollback(e);\n        }\n      }\n\n      await this.xcMeta.metaDelete('', '', NC_ROLES, { id: req.params.id });\n      res.json({ msg: 'success' });\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  protected async listRoles(_req, res, next): Promise<any> {\n    try {\n      res.json(await this.xcMeta.metaList('', '', NC_ROLES));\n    } catch (e) {\n      next(e);\n    }\n  }\n\n  /* Admin apis */\n  protected async createAuthTableIfNotExists(): Promise<any> {\n    if (!(await this.dbDriver.schema.hasTable('xc_users'))) {\n      await this.dbDriver.schema.createTable('xc_users', function(table) {\n        table.increments();\n        table.string('email');\n        table.string('password', 255);\n        table.string('salt', 255);\n        table.string('firstname');\n        table.string('lastname');\n        table.string('username');\n        table.string('refresh_token', 255);\n        table.string('invite_token', 255);\n        table.string('invite_token_expires', 255);\n        table.timestamp('reset_password_expires');\n        table.string('reset_password_token', 255);\n        table.string('email_verification_token', 255);\n        table.boolean('email_verified');\n        table.string('roles', 255).defaultTo('editor');\n        table.timestamps();\n      });\n    }\n  }\n\n  protected setTokenCookie(res, token): void {\n    // create http only cookie with refresh token that expires in 7 days\n    const cookieOptions = {\n      httpOnly: true,\n      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n    };\n    res.cookie('refresh_token', token, cookieOptions);\n  }\n\n  protected randomTokenString(): string {\n    return crypto.randomBytes(40).toString('hex');\n  }\n\n  // protected async xcSendInviteEmail(reqBody: {\n  //   fromEmail: string;\n  //   toEmail: string;\n  //   inviteUrl: string\n  //   projectName: string;\n  // }): Promise<any> {\n  //   try {\n  //     await axios.post('https://nocodb.com/api/v1/invite', reqBody);\n  //   } catch (_e) {\n  //   }\n  // }\n\n  protected get emailClient(): IEmailAdapter {\n    return this.app?.metaMgr?.emailAdapter;\n  }\n\n  public async loadLatestApiTokens(): Promise<any> {\n    this.apiTokens = await this.xcMeta.metaList(null, null, 'nc_api_tokens');\n  }\n}\n\n/**\n * @copyright Copyright (c) 2021, Xgene Cloud Ltd\n *\n * @author Naveen MR <oof1lab@gmail.com>\n * @author Pranav C Balan <pranavxc@gmail.com>\n * @author Wing-Kam Wong <wingkwong.code@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n"], "buggy_code_start_loc": [230, 80, 56, 74, 4, 6, 1, 24, 45], "buggy_code_end_loc": [231, 81, 107, 448, 9, 42, 2, 75, 65], "fixing_code_start_loc": [230, 80, 56, 74, 5, 7, 1, 25, 45], "fixing_code_end_loc": [234, 81, 116, 474, 10, 47, 38, 78, 67], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository nocodb/nocodb prior to 0.91.7+.", "other": {"cve": {"id": "CVE-2022-2064", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-13T12:15:08.270", "lastModified": "2022-06-22T16:07:33.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository nocodb/nocodb prior to 0.91.7+."}, {"lang": "es", "value": "Una Expiraci\u00f3n de Sesi\u00f3n Insuficiente en el repositorio de GitHub nocodb/nocodb versiones anteriores a 0.91.7+"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xgenecloud:nocodb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.91.7", "matchCriteriaId": "1E79120D-C248-4A67-AC09-AECFDFFB240F"}]}]}], "references": [{"url": "https://github.com/nocodb/nocodb/commit/c9b5111b25aea2781e19395a8e9107ddbd235a2b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/39523d51-fc5c-48b8-a082-171da79761bb", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nocodb/nocodb/commit/c9b5111b25aea2781e19395a8e9107ddbd235a2b"}}