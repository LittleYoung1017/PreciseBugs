diff --git a/test/extensions/filters/http/common/fuzz/filter_corpus/clusterfuzz-testcase-minimized-filter_fuzz_test-5726031248621568 b/test/extensions/filters/http/common/fuzz/filter_corpus/clusterfuzz-testcase-minimized-filter_fuzz_test-5726031248621568
new file mode 100644
index 0000000000..a3aa016972
--- /dev/null
+++ b/test/extensions/filters/http/common/fuzz/filter_corpus/clusterfuzz-testcase-minimized-filter_fuzz_test-5726031248621568
@@ -0,0 +1,7 @@
+config {
+  name: "envoy.filters.http.tap"
+  typed_config {
+    type_url: "type.googleapis.com/envoy.extensions.filters.http.tap.v3.Tap"
+    value: "\n\002\022\000"
+  }
+}
diff --git a/test/extensions/filters/http/common/fuzz/uber_filter.cc b/test/extensions/filters/http/common/fuzz/uber_filter.cc
index 8052888886..da0e353d1b 100644
--- a/test/extensions/filters/http/common/fuzz/uber_filter.cc
+++ b/test/extensions/filters/http/common/fuzz/uber_filter.cc
@@ -195,7 +195,7 @@ void UberFilterFuzzer::fuzz(
         Server::Configuration::NamedHttpFilterConfigFactory>(proto_config.name());
     ProtobufTypes::MessagePtr message = Config::Utility::translateToFactoryConfig(
         proto_config, factory_context_.messageValidationVisitor(), factory);
-    // Clean-up config with filter-specific logic.
+    // Clean-up config with filter-specific logic before it runs through validations.
     cleanFuzzedConfig(proto_config.name(), message.get());
     cb_ = factory.createFilterFactoryFromProto(*message, "stats", factory_context_);
     cb_(filter_callback_);
diff --git a/test/extensions/filters/http/common/fuzz/uber_per_filter.cc b/test/extensions/filters/http/common/fuzz/uber_per_filter.cc
index 1abdf75194..d816d5a26a 100644
--- a/test/extensions/filters/http/common/fuzz/uber_per_filter.cc
+++ b/test/extensions/filters/http/common/fuzz/uber_per_filter.cc
@@ -104,9 +104,13 @@ void cleanTapConfig(Protobuf::Message* message) {
         true);
   }
   // TODO(samflattery): remove once StreamingGrpcSink is implemented
+  // a static config filter is required to have one sink, but since validation isn't performed on
+  // the filter until after this function runs, we have to manually check that there are sinks
+  // before checking that they are not StreamingGrpc
   else if (config.common_config().config_type_case() ==
                envoy::extensions::common::tap::v3::CommonExtensionConfig::ConfigTypeCase::
                    kStaticConfig &&
+           !config.common_config().static_config().output_config().sinks().empty() &&
            config.common_config()
                    .static_config()
                    .output_config()
@@ -129,7 +133,7 @@ void UberFilterFuzzer::cleanFuzzedConfig(absl::string_view filter_name,
   } else if (name == HttpFilterNames::get().Squash) {
     cleanAttachmentTemplate(message);
   } else if (name == HttpFilterNames::get().Tap) {
-    // TapDS oneof field not implemented.
+    // TapDS oneof field and OutputSinkType StreamingGrpc not implemented
     cleanTapConfig(message);
   }
   if (filter_name == HttpFilterNames::get().JwtAuthn) {
