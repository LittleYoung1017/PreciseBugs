diff --git a/autotest/gcore/data/bigtiff_four_strip_be_short.tif b/autotest/gcore/data/bigtiff_four_strip_be_short.tif
new file mode 100644
index 0000000000..98d3673ee3
Binary files /dev/null and b/autotest/gcore/data/bigtiff_four_strip_be_short.tif differ
diff --git a/autotest/gcore/data/bigtiff_four_strip_short.tif b/autotest/gcore/data/bigtiff_four_strip_short.tif
new file mode 100644
index 0000000000..d8dd836025
Binary files /dev/null and b/autotest/gcore/data/bigtiff_four_strip_short.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_block_be_long8.tif b/autotest/gcore/data/bigtiff_one_block_be_long8.tif
new file mode 100644
index 0000000000..ab87bdc16f
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_block_be_long8.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_block_long8.tif b/autotest/gcore/data/bigtiff_one_block_long8.tif
new file mode 100644
index 0000000000..834b5d751c
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_block_long8.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_strip_be_long.tif b/autotest/gcore/data/bigtiff_one_strip_be_long.tif
new file mode 100644
index 0000000000..eb0cd998d2
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_strip_be_long.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_strip_be_long8.tif b/autotest/gcore/data/bigtiff_one_strip_be_long8.tif
new file mode 100644
index 0000000000..437fe1c0ca
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_strip_be_long8.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_strip_long.tif b/autotest/gcore/data/bigtiff_one_strip_long.tif
new file mode 100644
index 0000000000..bbb2b1d7ec
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_strip_long.tif differ
diff --git a/autotest/gcore/data/bigtiff_one_strip_long8.tif b/autotest/gcore/data/bigtiff_one_strip_long8.tif
new file mode 100644
index 0000000000..eb7fba7dc5
Binary files /dev/null and b/autotest/gcore/data/bigtiff_one_strip_long8.tif differ
diff --git a/autotest/gcore/data/bigtiff_two_strip_be_long.tif b/autotest/gcore/data/bigtiff_two_strip_be_long.tif
new file mode 100644
index 0000000000..e01fe8addf
Binary files /dev/null and b/autotest/gcore/data/bigtiff_two_strip_be_long.tif differ
diff --git a/autotest/gcore/data/bigtiff_two_strip_be_long8.tif b/autotest/gcore/data/bigtiff_two_strip_be_long8.tif
new file mode 100644
index 0000000000..03664a6532
Binary files /dev/null and b/autotest/gcore/data/bigtiff_two_strip_be_long8.tif differ
diff --git a/autotest/gcore/data/bigtiff_two_strip_long.tif b/autotest/gcore/data/bigtiff_two_strip_long.tif
new file mode 100644
index 0000000000..36160ea794
Binary files /dev/null and b/autotest/gcore/data/bigtiff_two_strip_long.tif differ
diff --git a/autotest/gcore/data/bigtiff_two_strip_long8.tif b/autotest/gcore/data/bigtiff_two_strip_long8.tif
new file mode 100644
index 0000000000..6f31d26abb
Binary files /dev/null and b/autotest/gcore/data/bigtiff_two_strip_long8.tif differ
diff --git a/autotest/gcore/data/classictiff_four_strip_be_short.tif b/autotest/gcore/data/classictiff_four_strip_be_short.tif
new file mode 100644
index 0000000000..691cad80d2
Binary files /dev/null and b/autotest/gcore/data/classictiff_four_strip_be_short.tif differ
diff --git a/autotest/gcore/data/classictiff_four_strip_short.tif b/autotest/gcore/data/classictiff_four_strip_short.tif
new file mode 100644
index 0000000000..7cca0ee1eb
Binary files /dev/null and b/autotest/gcore/data/classictiff_four_strip_short.tif differ
diff --git a/autotest/gcore/data/classictiff_one_block_be_long.tif b/autotest/gcore/data/classictiff_one_block_be_long.tif
new file mode 100644
index 0000000000..19e2413532
Binary files /dev/null and b/autotest/gcore/data/classictiff_one_block_be_long.tif differ
diff --git a/autotest/gcore/data/classictiff_one_block_byte.tif b/autotest/gcore/data/classictiff_one_block_byte.tif
new file mode 100644
index 0000000000..7b2ca3148b
Binary files /dev/null and b/autotest/gcore/data/classictiff_one_block_byte.tif differ
diff --git a/autotest/gcore/data/classictiff_one_block_long.tif b/autotest/gcore/data/classictiff_one_block_long.tif
new file mode 100644
index 0000000000..e6df6836b9
Binary files /dev/null and b/autotest/gcore/data/classictiff_one_block_long.tif differ
diff --git a/autotest/gcore/data/classictiff_one_strip_be_long.tif b/autotest/gcore/data/classictiff_one_strip_be_long.tif
new file mode 100644
index 0000000000..3072e3b0d2
Binary files /dev/null and b/autotest/gcore/data/classictiff_one_strip_be_long.tif differ
diff --git a/autotest/gcore/data/classictiff_one_strip_long.tif b/autotest/gcore/data/classictiff_one_strip_long.tif
new file mode 100644
index 0000000000..c173a49d8b
Binary files /dev/null and b/autotest/gcore/data/classictiff_one_strip_long.tif differ
diff --git a/autotest/gcore/data/classictiff_two_strip_be_short.tif b/autotest/gcore/data/classictiff_two_strip_be_short.tif
new file mode 100644
index 0000000000..4b76633961
Binary files /dev/null and b/autotest/gcore/data/classictiff_two_strip_be_short.tif differ
diff --git a/autotest/gcore/data/classictiff_two_strip_short.tif b/autotest/gcore/data/classictiff_two_strip_short.tif
new file mode 100644
index 0000000000..a8d9221382
Binary files /dev/null and b/autotest/gcore/data/classictiff_two_strip_short.tif differ
diff --git a/autotest/gcore/data/size_of_stripbytecount_at_1_and_lower_than_stripcount.tif b/autotest/gcore/data/size_of_stripbytecount_at_1_and_lower_than_stripcount.tif
new file mode 100644
index 0000000000..2de0e41878
Binary files /dev/null and b/autotest/gcore/data/size_of_stripbytecount_at_1_and_lower_than_stripcount.tif differ
diff --git a/autotest/gcore/data/size_of_stripbytecount_lower_than_stripcount.tif b/autotest/gcore/data/size_of_stripbytecount_lower_than_stripcount.tif
new file mode 100644
index 0000000000..bd226b0209
Binary files /dev/null and b/autotest/gcore/data/size_of_stripbytecount_lower_than_stripcount.tif differ
diff --git a/autotest/gcore/tiff_read.py b/autotest/gcore/tiff_read.py
index c43a98819c..6d86d4b985 100755
--- a/autotest/gcore/tiff_read.py
+++ b/autotest/gcore/tiff_read.py
@@ -3132,6 +3132,88 @@ def tiff_read_toomanyblocks():
 
     return 'success'
 
+
+###############################################################################
+# Test reading images where the number of items in StripByteCounts/StripOffsets
+# tag is lesser than the number of strips
+
+def tiff_read_size_of_stripbytecount_lower_than_stripcount():
+
+    ds = gdal.Open('data/size_of_stripbytecount_lower_than_stripcount.tif')
+    # There are 3 strips but StripByteCounts has just two elements;
+    if ds.GetRasterBand(1).GetMetadataItem('BLOCK_OFFSET_0_1', 'TIFF') != '171':
+        gdaltest.post_reason('fail')
+        return 'fail'
+    if ds.GetRasterBand(1).GetMetadataItem('BLOCK_SIZE_0_1', 'TIFF') != '1':
+        gdaltest.post_reason('fail')
+        return 'fail'
+    if ds.GetRasterBand(1).GetMetadataItem('BLOCK_OFFSET_0_2', 'TIFF') is not None:
+        gdaltest.post_reason('fail')
+        return 'fail'
+    if ds.GetRasterBand(1).GetMetadataItem('BLOCK_SIZE_0_2', 'TIFF') is not None:
+        gdaltest.post_reason('fail')
+        return 'fail'
+
+    ds = gdal.Open('data/size_of_stripbytecount_at_1_and_lower_than_stripcount.tif')
+    # There are 3 strips but StripByteCounts has just one element;
+    if ds.GetRasterBand(1).GetMetadataItem('BLOCK_SIZE_0_0', 'TIFF') != '1':
+        gdaltest.post_reason('fail')
+        return 'fail'
+
+    return 'success'
+
+
+###############################################################################
+# Test different datatypes for StripOffsets tag with little/big, classic/bigtiff
+
+def tiff_read_stripoffset_types():
+
+    tests = [
+        ('data/classictiff_one_block_byte.tif', []), # unsupported
+        ('data/classictiff_one_block_long.tif', [158]),
+        ('data/classictiff_one_block_be_long.tif', [158]),
+        ('data/classictiff_one_strip_long.tif', [146]),
+        ('data/classictiff_one_strip_be_long.tif', [146]),
+        ('data/classictiff_two_strip_short.tif', [162, 163]),
+        ('data/classictiff_two_strip_be_short.tif', [162, 163]),
+        ('data/classictiff_four_strip_short.tif', [178, 179, 180, 181]),
+        ('data/bigtiff_four_strip_short.tif', [316, 317, 318, 319]),
+        ('data/bigtiff_four_strip_be_short.tif', [316, 317, 318, 319]),
+        ('data/bigtiff_one_block_long8.tif', [272]),
+        ('data/bigtiff_one_block_be_long8.tif', [272]),
+        ('data/bigtiff_one_strip_long.tif', [252]),
+        ('data/bigtiff_one_strip_be_long.tif', [252]),
+        ('data/bigtiff_one_strip_long8.tif', [252]),
+        ('data/bigtiff_one_strip_be_long8.tif', [252]),
+        ('data/bigtiff_two_strip_long.tif', [284, 285]),
+        ('data/bigtiff_two_strip_be_long.tif', [284, 285]),
+        ('data/bigtiff_two_strip_long8.tif', [284, 285]),
+        ('data/bigtiff_two_strip_be_long8.tif', [284, 285]),
+    ]
+
+    for (filename, expected_offsets) in tests:
+
+        # Only when built against internal libtiff we reject byte datatype
+        if len(expected_offsets) == 0 and \
+           gdal.GetDriverByName('GTiff').GetMetadataItem('LIBTIFF') != 'INTERNAL':
+            continue
+
+        ds = gdal.Open(filename)
+        offsets = []
+        for row in range(4):
+            with gdaltest.error_handler():
+                mdi = ds.GetRasterBand(1).GetMetadataItem(
+                    'BLOCK_OFFSET_0_%d' % row, 'TIFF')
+            if mdi is None:
+                break
+            offsets.append(int(mdi))
+        if offsets != expected_offsets:
+            print(filename, expected_offsets, offsets)
+
+    return 'success'
+
+
+
 ###############################################################################
 
 for item in init_list:
@@ -3240,11 +3322,13 @@ gdaltest_list.append( (tiff_read_uint33) )
 gdaltest_list.append( (tiff_read_corrupted_deflate_singlestrip) )
 gdaltest_list.append( (tiff_read_packbits_not_enough_data) )
 gdaltest_list.append( (tiff_read_toomanyblocks) )
+gdaltest_list.append( (tiff_read_size_of_stripbytecount_lower_than_stripcount) )
+gdaltest_list.append( (tiff_read_stripoffset_types) )
 
 gdaltest_list.append( (tiff_read_online_1) )
 gdaltest_list.append( (tiff_read_online_2) )
 
-# gdaltest_list = [ tiff_read_online_1 ]
+# gdaltest_list = [ tiff_read_stripoffset_types ]
 
 if __name__ == '__main__':
 
diff --git a/autotest/gcore/tiff_write.py b/autotest/gcore/tiff_write.py
index 43c6563d98..fe9b004f97 100755
--- a/autotest/gcore/tiff_write.py
+++ b/autotest/gcore/tiff_write.py
@@ -7469,12 +7469,19 @@ def tiff_write_163():
         return 'skip'
 
     gdal.Translate('/vsimem/tiff_write_163.tif', 'data/byte.tif',
-                   options = '-outsize 1 10000 -co BLOCKYSIZE=10000' )
+                   options = '-outsize 1 20000 -co BLOCKYSIZE=20000 -co PROFILE=BASELINE' )
     ds = gdal.Open('/vsimem/tiff_write_163.tif')
     cs = ds.GetRasterBand(1).Checksum()
-    if cs != 56567:
+    if cs != 47567:
+        gdaltest.post_reason('fail')
         print(cs)
         return 'fail'
+    # Check that IsBlockAvailable() works properly in that mode
+    offset_0_2 = ds.GetRasterBand(1).GetMetadataItem('BLOCK_OFFSET_0_2', 'TIFF')
+    if offset_0_2 != str(146 + 2 * 8192):
+        gdaltest.post_reason('fail')
+        print(offset_0_2)
+        return 'fail'
     ds = None
 
     gdaltest.tiff_drv.Delete( '/vsimem/tiff_write_163.tif' )
diff --git a/gdal/frmts/gtiff/geotiff.cpp b/gdal/frmts/gtiff/geotiff.cpp
index 536f0c97aa..8b082c90ae 100644
--- a/gdal/frmts/gtiff/geotiff.cpp
+++ b/gdal/frmts/gtiff/geotiff.cpp
@@ -8821,10 +8821,11 @@ void GTiffDataset::Crystalize()
     nDirOffset = TIFFCurrentDirOffset( hTIFF );
 }
 
-#ifdef INTERNAL_LIBTIFF
+#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)
 
 static
 void GTiffCacheOffsetOrCount( VSILFILE* fp,
+                              bool bSwab,
                               vsi_l_offset nBaseOffset,
                               int nBlockId,
                               uint32 nstrips,
@@ -8876,12 +8877,24 @@ void GTiffCacheOffsetOrCount( VSILFILE* fp,
          static_cast<GIntBig>(nOffsetEndPage);
          ++i )
     {
-        if( sizeofval == 4 )
+        if( sizeofval == 2 )
+        {
+            uint16 val;
+            memcpy(&val,
+                   buffer + (nOffset - nOffsetStartPage) + i * sizeof(val),
+                   sizeof(val));
+            if( bSwab )
+                CPL_SWAP16PTR(&val);
+            panVals[nBlockId + i] = val;
+        }
+        else if( sizeofval == 4 )
         {
             uint32 val;
             memcpy(&val,
                    buffer + (nOffset - nOffsetStartPage) + i * sizeof(val),
                    sizeof(val));
+            if( bSwab )
+                CPL_SWAP32PTR(&val);
             panVals[nBlockId + i] = val;
         }
         else
@@ -8890,12 +8903,137 @@ void GTiffCacheOffsetOrCount( VSILFILE* fp,
             memcpy(&val,
                    buffer + (nOffset - nOffsetStartPage) + i * sizeof(val),
                    sizeof(val));
+            if( bSwab )
+                CPL_SWAP64PTR(&val);
             panVals[nBlockId + i] = val;
         }
     }
 }
 
-#endif  // INTERNAL_LIBTIFF
+static void ReadStripArray( VSILFILE* fp,
+                            TIFF* hTIFF,
+                            const TIFFDirEntry* psEntry,
+                            int nBlockId,
+                            uint32 nStripArrayAlloc,
+                            uint64* panOffsetOrCountArray )
+{
+    const bool bSwab = (hTIFF->tif_flags & TIFF_SWAB) != 0;
+    if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&
+        psEntry->tdir_type == TIFF_SHORT &&
+        psEntry->tdir_count <= 4 )
+    {
+        uint16 offset;
+        const GByte* src = reinterpret_cast<const GByte*>(
+                                    &(psEntry->tdir_offset.toff_long8));
+        for( size_t i = 0; i < 4 && i < nStripArrayAlloc; i++ )
+        {
+            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));
+            if( bSwab )
+                CPL_SWAP16PTR(&offset);
+            panOffsetOrCountArray[i] = offset;
+        }
+    }
+    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&
+        psEntry->tdir_type == TIFF_LONG &&
+        psEntry->tdir_count <= 2 )
+    {
+        uint32 offset;
+        const GByte* src = reinterpret_cast<const GByte*>(
+                                    &(psEntry->tdir_offset.toff_long8));
+        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )
+        {
+            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));
+            if( bSwab )
+                CPL_SWAP32PTR(&offset);
+            panOffsetOrCountArray[i] = offset;
+        }
+    }
+    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&
+        psEntry->tdir_type == TIFF_LONG8 &&
+        psEntry->tdir_count <= 1 )
+    {
+        uint64 offset = psEntry->tdir_offset.toff_long8;
+        if( bSwab )
+            CPL_SWAP64PTR(&offset);
+        panOffsetOrCountArray[0] = offset;
+    }
+    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&
+        psEntry->tdir_type == TIFF_SHORT &&
+        psEntry->tdir_count <= 2 )
+    {
+        uint16 offset;
+        const GByte* src = reinterpret_cast<const GByte*>(
+                                    &(psEntry->tdir_offset.toff_long));
+
+        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )
+        {
+            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));
+            if( bSwab )
+                CPL_SWAP16PTR(&offset);
+            panOffsetOrCountArray[i] = offset;
+        }
+    }
+    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&
+        psEntry->tdir_type == TIFF_LONG &&
+        psEntry->tdir_count <= 1 )
+    {
+        uint32 offset = psEntry->tdir_offset.toff_long;
+        if( bSwab )
+            CPL_SWAP32PTR(&offset);
+        panOffsetOrCountArray[0] = offset;
+    }
+    else
+    {
+        vsi_l_offset l_nDirOffset = 0;
+        if( hTIFF->tif_flags&TIFF_BIGTIFF )
+        {
+            uint64 offset = psEntry->tdir_offset.toff_long8;
+            if( bSwab )
+                CPL_SWAP64PTR(&offset);
+            l_nDirOffset = offset;
+        }
+        else
+        {
+            uint32 offset = psEntry->tdir_offset.toff_long;
+            if( bSwab )
+                CPL_SWAP32PTR(&offset);
+            l_nDirOffset = offset;
+        }
+
+        if( psEntry->tdir_type == TIFF_SHORT )
+        {
+            GTiffCacheOffsetOrCount(fp,
+                                    bSwab,
+                                    l_nDirOffset,
+                                    nBlockId,
+                                    nStripArrayAlloc,
+                                    panOffsetOrCountArray,
+                                    sizeof(uint16));
+        }
+        else if( psEntry->tdir_type == TIFF_LONG )
+        {
+            GTiffCacheOffsetOrCount(fp,
+                                    bSwab,
+                                    l_nDirOffset,
+                                    nBlockId,
+                                    nStripArrayAlloc,
+                                    panOffsetOrCountArray,
+                                    sizeof(uint32));
+        }
+        else
+        {
+            GTiffCacheOffsetOrCount(fp,
+                                    bSwab,
+                                    l_nDirOffset,
+                                    nBlockId,
+                                    nStripArrayAlloc,
+                                    panOffsetOrCountArray,
+                                    sizeof(uint64));
+        }
+    }
+}
+
+#endif  // #if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)
 
 /************************************************************************/
 /*                          IsBlockAvailable()                          */
@@ -8913,15 +9051,51 @@ bool GTiffDataset::IsBlockAvailable( int nBlockId,
 #if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)
     // Optimization to avoid fetching the whole Strip/TileCounts and
     // Strip/TileOffsets arrays.
+
+    // Note: if strip choping is in effect, _TIFFFillStrilesInternal()
+    // will have 0-memset td_stripoffset_entry/td_stripbytecount_entry, so
+    // we won't enter the below block
+
     if( eAccess == GA_ReadOnly &&
-        !(hTIFF->tif_flags & TIFF_SWAB) &&
-        hTIFF->tif_dir.td_nstrips > 2 &&
-        (hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||
-         hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) &&
-        (hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||
-         hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8) &&
+        hTIFF->tif_dir.td_stripoffset_entry.tdir_type != 0 &&
+        hTIFF->tif_dir.td_stripbytecount_entry.tdir_type != 0 &&
         !bStreamingIn )
     {
+        if( !((hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_SHORT ||
+               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||
+               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) &&
+              (hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_SHORT ||
+               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||
+               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8)) )
+        {
+            if( nStripArrayAlloc == 0 )
+            {
+                CPLError(CE_Failure, CPLE_NotSupported,
+                         "Unhandled type for StripOffset/StripByteCount");
+                nStripArrayAlloc = ~nStripArrayAlloc;
+            }
+            if( pnOffset )
+                *pnOffset = 0;
+            if( pnSize )
+                *pnSize = 0;
+            return false;
+        }
+
+        // The size of tags can be actually lesser than the number of strips
+        // (libtiff accepts such files)
+        if( static_cast<uint32>(nBlockId) >=
+                hTIFF->tif_dir.td_stripoffset_entry.tdir_count ||
+            static_cast<uint32>(nBlockId) >=
+                hTIFF->tif_dir.td_stripbytecount_entry.tdir_count )
+        {
+            // In case the tags aren't large enough.
+            if( pnOffset )
+                *pnOffset = 0;
+            if( pnSize )
+                *pnSize = 0;
+            return false;
+        }
+
         if( hTIFF->tif_dir.td_stripoffset == NULL )
         {
             nStripArrayAlloc = 0;
@@ -8993,67 +9167,23 @@ bool GTiffDataset::IsBlockAvailable( int nBlockId,
             const vsi_l_offset nCurOffset = VSIFTellL(fp);
             if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 )
             {
-                vsi_l_offset l_nDirOffset = 0;
-                if( hTIFF->tif_flags&TIFF_BIGTIFF )
-                    l_nDirOffset =
-                        hTIFF->
-                            tif_dir.td_stripoffset_entry.tdir_offset.toff_long8;
-                else
-                    l_nDirOffset =
-                        hTIFF->
-                            tif_dir.td_stripoffset_entry.tdir_offset.toff_long;
+                ReadStripArray( fp,
+                                hTIFF,
+                                &hTIFF->tif_dir.td_stripoffset_entry,
+                                nBlockId,
+                                nStripArrayAlloc,
+                                hTIFF->tif_dir.td_stripoffset );
 
-                if( hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG )
-                {
-                    GTiffCacheOffsetOrCount(fp,
-                                            l_nDirOffset,
-                                            nBlockId,
-                                            nStripArrayAlloc,
-                                            hTIFF->tif_dir.td_stripoffset,
-                                            sizeof(uint32));
-                }
-                else
-                {
-                    GTiffCacheOffsetOrCount(fp,
-                                            l_nDirOffset,
-                                            nBlockId,
-                                            nStripArrayAlloc,
-                                            hTIFF->tif_dir.td_stripoffset,
-                                            sizeof(uint64));
-                }
             }
 
             if( ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )
             {
-                vsi_l_offset l_nDirOffset = 0;
-                if( hTIFF->tif_flags&TIFF_BIGTIFF )
-                    l_nDirOffset =
-                        hTIFF->
-                            tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8;
-                else
-                    l_nDirOffset =
-                        hTIFF->
-                            tif_dir.td_stripbytecount_entry.tdir_offset.toff_long;
-
-                if( hTIFF->tif_dir.td_stripbytecount_entry.tdir_type ==
-                    TIFF_LONG )
-                {
-                    GTiffCacheOffsetOrCount(fp,
-                                            l_nDirOffset,
-                                            nBlockId,
-                                            nStripArrayAlloc,
-                                            hTIFF->tif_dir.td_stripbytecount,
-                                            sizeof(uint32));
-                }
-                else
-                {
-                    GTiffCacheOffsetOrCount(fp,
-                                            l_nDirOffset,
-                                            nBlockId,
-                                            nStripArrayAlloc,
-                                            hTIFF->tif_dir.td_stripbytecount,
-                                            sizeof(uint64));
-                }
+                ReadStripArray( fp,
+                                hTIFF,
+                                &hTIFF->tif_dir.td_stripbytecount_entry,
+                                nBlockId,
+                                nStripArrayAlloc,
+                                hTIFF->tif_dir.td_stripbytecount );
             }
             if( VSIFSeekL(fp, nCurOffset, SEEK_SET) != 0 )
             {
diff --git a/gdal/frmts/gtiff/libtiff/tif_dirread.c b/gdal/frmts/gtiff/libtiff/tif_dirread.c
index 4ac3f5e56e..bf8cef2263 100644
--- a/gdal/frmts/gtiff/libtiff/tif_dirread.c
+++ b/gdal/frmts/gtiff/libtiff/tif_dirread.c
@@ -1,4 +1,4 @@
-/* $Id: tif_dirread.c,v 1.210 2017-06-12 10:45:35 erouault Exp $ */
+/* $Id: tif_dirread.c,v 1.211 2017-06-12 19:13:49 erouault Exp $ */
 
 /*
  * Copyright (c) 1988-1997 Sam Leffler
@@ -765,13 +765,20 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* di
 	}
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(
+    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,
+    void** value, uint64 maxcount)
 {
 	int typesize;
 	uint32 datasize;
 	void* data;
+        uint64 target_count64;
 	typesize=TIFFDataWidth(direntry->tdir_type);
-	if ((direntry->tdir_count==0)||(typesize==0))
+
+        target_count64 = (direntry->tdir_count > maxcount) ?
+                maxcount : direntry->tdir_count;
+
+	if ((target_count64==0)||(typesize==0))
 	{
 		*value=0;
 		return(TIFFReadDirEntryErrOk);
@@ -783,12 +790,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* d
          * in either the current data type or the dest data type.  This also
          * avoids problems with overflow of tmsize_t on 32bit systems.
          */
-	if ((uint64)(2147483647/typesize)<direntry->tdir_count)
+	if ((uint64)(2147483647/typesize)<target_count64)
 		return(TIFFReadDirEntryErrSizesan);
-	if ((uint64)(2147483647/desttypesize)<direntry->tdir_count)
+	if ((uint64)(2147483647/desttypesize)<target_count64)
 		return(TIFFReadDirEntryErrSizesan);
 
-	*count=(uint32)direntry->tdir_count;
+	*count=(uint32)target_count64;
 	datasize=(*count)*typesize;
 	assert((tmsize_t)datasize>0);
 	data=_TIFFCheckMalloc(tif, *count, typesize, "ReadDirEntryArray");
@@ -834,6 +841,12 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* d
 	return(TIFFReadDirEntryErrOk);
 }
 
+static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)
+{
+    return TIFFReadDirEntryArrayWithLimit(tif, direntry, count,
+                                          desttypesize, value, ~((uint64)0));
+}
+
 static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)
 {
 	enum TIFFReadDirEntryErr err;
@@ -1863,7 +1876,8 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEnt
 	return(TIFFReadDirEntryErrOk);
 }
 
-static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(
+        TIFF* tif, TIFFDirEntry* direntry, uint64** value, uint64 maxcount)
 {
 	enum TIFFReadDirEntryErr err;
 	uint32 count;
@@ -1883,7 +1897,7 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEnt
 		default:
 			return(TIFFReadDirEntryErrType);
 	}
-	err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);
+	err=TIFFReadDirEntryArrayWithLimit(tif,direntry,&count,8,&origdata,maxcount);
 	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
 	{
 		*value=0;
@@ -2029,6 +2043,11 @@ static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEnt
 	return(TIFFReadDirEntryErrOk);
 }
 
+static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
+{
+    return TIFFReadDirEntryLong8ArrayWithLimit(tif, direntry, value, ~((uint64)0));
+}
+
 static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value)
 {
 	enum TIFFReadDirEntryErr err;
@@ -3989,6 +4008,7 @@ TIFFReadDirectory(TIFF* tif)
 		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )
 
 		} else if (tif->tif_dir.td_nstrips == 1
+                           && !(tif->tif_flags&TIFF_ISTILED)
                            && _TIFFFillStriles(tif)
 			   && tif->tif_dir.td_stripoffset[0] != 0
 			   && BYTECOUNTLOOKSBAD) {
@@ -5433,14 +5453,14 @@ TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
 	static const char module[] = "TIFFFetchStripThing";
 	enum TIFFReadDirEntryErr err;
 	uint64* data;
-	err=TIFFReadDirEntryLong8Array(tif,dir,&data);
+	err=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);
 	if (err!=TIFFReadDirEntryErrOk)
 	{
 		const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); 
 		TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
 		return(0);
 	}
-	if (dir->tdir_count!=(uint64)nstrips)
+	if (dir->tdir_count<(uint64)nstrips)
 	{
 		uint64* resizeddata;
 		resizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),"for strip array");
@@ -5448,13 +5468,8 @@ TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
 			_TIFFfree(data);
 			return(0);
 		}
-		if (dir->tdir_count<(uint64)nstrips)
-		{
-			_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));
-			_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));
-		}
-		else
-			_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));
+                _TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));
+                _TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));
 		_TIFFfree(data);
 		data=resizeddata;
 	}
