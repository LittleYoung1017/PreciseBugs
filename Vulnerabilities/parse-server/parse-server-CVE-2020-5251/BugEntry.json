{"buggy_code": ["Couldn't find the requested file /spec/RegexVulnerabilities.spec.js in parse-community/parse-server.", "import PromiseRouter from '../PromiseRouter';\nimport Config from '../Config';\nimport express from 'express';\nimport path from 'path';\nimport fs from 'fs';\nimport qs from 'querystring';\nimport { Parse } from 'parse/node';\n\nconst public_html = path.resolve(__dirname, '../../public_html');\nconst views = path.resolve(__dirname, '../../views');\n\nexport class PublicAPIRouter extends PromiseRouter {\n  verifyEmail(req) {\n    const { token, username } = req.query;\n    const appId = req.params.appId;\n    const config = Config.get(appId);\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    if (!token || !username) {\n      return this.invalidLink(req);\n    }\n\n    const userController = config.userController;\n    return userController.verifyEmail(username, token).then(\n      () => {\n        const params = qs.stringify({ username });\n        return Promise.resolve({\n          status: 302,\n          location: `${config.verifyEmailSuccessURL}?${params}`,\n        });\n      },\n      () => {\n        return this.invalidVerificationLink(req);\n      }\n    );\n  }\n\n  resendVerificationEmail(req) {\n    const username = req.body.username;\n    const appId = req.params.appId;\n    const config = Config.get(appId);\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    if (!username) {\n      return this.invalidLink(req);\n    }\n\n    const userController = config.userController;\n\n    return userController.resendVerificationEmail(username).then(\n      () => {\n        return Promise.resolve({\n          status: 302,\n          location: `${config.linkSendSuccessURL}`,\n        });\n      },\n      () => {\n        return Promise.resolve({\n          status: 302,\n          location: `${config.linkSendFailURL}`,\n        });\n      }\n    );\n  }\n\n  changePassword(req) {\n    return new Promise((resolve, reject) => {\n      const config = Config.get(req.query.id);\n\n      if (!config) {\n        this.invalidRequest();\n      }\n\n      if (!config.publicServerURL) {\n        return resolve({\n          status: 404,\n          text: 'Not found.',\n        });\n      }\n      // Should we keep the file in memory or leave like that?\n      fs.readFile(\n        path.resolve(views, 'choose_password'),\n        'utf-8',\n        (err, data) => {\n          if (err) {\n            return reject(err);\n          }\n          data = data.replace(\n            'PARSE_SERVER_URL',\n            `'${config.publicServerURL}'`\n          );\n          resolve({\n            text: data,\n          });\n        }\n      );\n    });\n  }\n\n  requestResetPassword(req) {\n    const config = req.config;\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    const { username, token } = req.query;\n\n    if (!username || !token) {\n      return this.invalidLink(req);\n    }\n\n    return config.userController.checkResetTokenValidity(username, token).then(\n      () => {\n        const params = qs.stringify({\n          token,\n          id: config.applicationId,\n          username,\n          app: config.appName,\n        });\n        return Promise.resolve({\n          status: 302,\n          location: `${config.choosePasswordURL}?${params}`,\n        });\n      },\n      () => {\n        return this.invalidLink(req);\n      }\n    );\n  }\n\n  resetPassword(req) {\n    const config = req.config;\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    const { username, token, new_password } = req.body;\n\n    if ((!username || !token || !new_password) && req.xhr === false) {\n      return this.invalidLink(req);\n    }\n\n    if (!username) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'Missing username');\n    }\n\n    if (!token) {\n      throw new Parse.Error(Parse.Error.OTHER_CAUSE, 'Missing token');\n    }\n\n    if (!new_password) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'Missing password');\n    }\n\n    return config.userController\n      .updatePassword(username, token, new_password)\n      .then(\n        () => {\n          return Promise.resolve({\n            success: true,\n          });\n        },\n        err => {\n          return Promise.resolve({\n            success: false,\n            err,\n          });\n        }\n      )\n      .then(result => {\n        const params = qs.stringify({\n          username: username,\n          token: token,\n          id: config.applicationId,\n          error: result.err,\n          app: config.appName,\n        });\n\n        if (req.xhr) {\n          if (result.success) {\n            return Promise.resolve({\n              status: 200,\n              response: 'Password successfully reset',\n            });\n          }\n          if (result.err) {\n            throw new Parse.Error(Parse.Error.OTHER_CAUSE, `${result.err}`);\n          }\n        }\n\n        const encodedUsername = encodeURIComponent(username);\n        const location = result.success\n          ? `${config.passwordResetSuccessURL}?username=${encodedUsername}`\n          : `${config.choosePasswordURL}?${params}`;\n\n        return Promise.resolve({\n          status: 302,\n          location,\n        });\n      });\n  }\n\n  invalidLink(req) {\n    return Promise.resolve({\n      status: 302,\n      location: req.config.invalidLinkURL,\n    });\n  }\n\n  invalidVerificationLink(req) {\n    const config = req.config;\n    if (req.query.username && req.params.appId) {\n      const params = qs.stringify({\n        username: req.query.username,\n        appId: req.params.appId,\n      });\n      return Promise.resolve({\n        status: 302,\n        location: `${config.invalidVerificationLinkURL}?${params}`,\n      });\n    } else {\n      return this.invalidLink(req);\n    }\n  }\n\n  missingPublicServerURL() {\n    return Promise.resolve({\n      text: 'Not found.',\n      status: 404,\n    });\n  }\n\n  invalidRequest() {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized';\n    throw error;\n  }\n\n  setConfig(req) {\n    req.config = Config.get(req.params.appId);\n    return Promise.resolve();\n  }\n\n  mountRoutes() {\n    this.route(\n      'GET',\n      '/apps/:appId/verify_email',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.verifyEmail(req);\n      }\n    );\n\n    this.route(\n      'POST',\n      '/apps/:appId/resend_verification_email',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.resendVerificationEmail(req);\n      }\n    );\n\n    this.route('GET', '/apps/choose_password', req => {\n      return this.changePassword(req);\n    });\n\n    this.route(\n      'POST',\n      '/apps/:appId/request_password_reset',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.resetPassword(req);\n      }\n    );\n\n    this.route(\n      'GET',\n      '/apps/:appId/request_password_reset',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.requestResetPassword(req);\n      }\n    );\n  }\n\n  expressRouter() {\n    const router = express.Router();\n    router.use('/apps', express.static(public_html));\n    router.use('/', super.expressRouter());\n    return router;\n  }\n}\n\nexport default PublicAPIRouter;\n", "import AppCache from './cache';\nimport Parse from 'parse/node';\nimport auth from './Auth';\nimport Config from './Config';\nimport ClientSDK from './ClientSDK';\nimport defaultLogger from './logger';\n\nexport const DEFAULT_ALLOWED_HEADERS =\n  'X-Parse-Master-Key, X-Parse-REST-API-Key, X-Parse-Javascript-Key, X-Parse-Application-Id, X-Parse-Client-Version, X-Parse-Session-Token, X-Requested-With, X-Parse-Revocable-Session, Content-Type, Pragma, Cache-Control';\n\nconst getMountForRequest = function(req) {\n  const mountPathLength = req.originalUrl.length - req.url.length;\n  const mountPath = req.originalUrl.slice(0, mountPathLength);\n  return req.protocol + '://' + req.get('host') + mountPath;\n};\n\n// Checks that the request is authorized for this app and checks user\n// auth too.\n// The bodyparser should run before this middleware.\n// Adds info to the request:\n// req.config - the Config for this app\n// req.auth - the Auth for this request\nexport function handleParseHeaders(req, res, next) {\n  var mount = getMountForRequest(req);\n\n  var info = {\n    appId: req.get('X-Parse-Application-Id'),\n    sessionToken: req.get('X-Parse-Session-Token'),\n    masterKey: req.get('X-Parse-Master-Key'),\n    installationId: req.get('X-Parse-Installation-Id'),\n    clientKey: req.get('X-Parse-Client-Key'),\n    javascriptKey: req.get('X-Parse-Javascript-Key'),\n    dotNetKey: req.get('X-Parse-Windows-Key'),\n    restAPIKey: req.get('X-Parse-REST-API-Key'),\n    clientVersion: req.get('X-Parse-Client-Version'),\n  };\n\n  var basicAuth = httpAuth(req);\n\n  if (basicAuth) {\n    var basicAuthAppId = basicAuth.appId;\n    if (AppCache.get(basicAuthAppId)) {\n      info.appId = basicAuthAppId;\n      info.masterKey = basicAuth.masterKey || info.masterKey;\n      info.javascriptKey = basicAuth.javascriptKey || info.javascriptKey;\n    }\n  }\n\n  if (req.body) {\n    // Unity SDK sends a _noBody key which needs to be removed.\n    // Unclear at this point if action needs to be taken.\n    delete req.body._noBody;\n  }\n\n  var fileViaJSON = false;\n\n  if (!info.appId || !AppCache.get(info.appId)) {\n    // See if we can find the app id on the body.\n    if (req.body instanceof Buffer) {\n      // The only chance to find the app id is if this is a file\n      // upload that actually is a JSON body. So try to parse it.\n      req.body = JSON.parse(req.body);\n      fileViaJSON = true;\n    }\n\n    if (req.body) {\n      delete req.body._RevocableSession;\n    }\n\n    if (\n      req.body &&\n      req.body._ApplicationId &&\n      AppCache.get(req.body._ApplicationId) &&\n      (!info.masterKey ||\n        AppCache.get(req.body._ApplicationId).masterKey === info.masterKey)\n    ) {\n      info.appId = req.body._ApplicationId;\n      info.javascriptKey = req.body._JavaScriptKey || '';\n      delete req.body._ApplicationId;\n      delete req.body._JavaScriptKey;\n      // TODO: test that the REST API formats generated by the other\n      // SDKs are handled ok\n      if (req.body._ClientVersion) {\n        info.clientVersion = req.body._ClientVersion;\n        delete req.body._ClientVersion;\n      }\n      if (req.body._InstallationId) {\n        info.installationId = req.body._InstallationId;\n        delete req.body._InstallationId;\n      }\n      if (req.body._SessionToken) {\n        info.sessionToken = req.body._SessionToken;\n        delete req.body._SessionToken;\n      }\n      if (req.body._MasterKey) {\n        info.masterKey = req.body._MasterKey;\n        delete req.body._MasterKey;\n      }\n      if (req.body._ContentType) {\n        req.headers['content-type'] = req.body._ContentType;\n        delete req.body._ContentType;\n      }\n    } else {\n      return invalidRequest(req, res);\n    }\n  }\n\n  if (info.clientVersion) {\n    info.clientSDK = ClientSDK.fromString(info.clientVersion);\n  }\n\n  if (fileViaJSON) {\n    // We need to repopulate req.body with a buffer\n    var base64 = req.body.base64;\n    req.body = Buffer.from(base64, 'base64');\n  }\n\n  const clientIp = getClientIp(req);\n\n  info.app = AppCache.get(info.appId);\n  req.config = Config.get(info.appId, mount);\n  req.config.headers = req.headers || {};\n  req.config.ip = clientIp;\n  req.info = info;\n\n  if (\n    info.masterKey &&\n    req.config.masterKeyIps &&\n    req.config.masterKeyIps.length !== 0 &&\n    req.config.masterKeyIps.indexOf(clientIp) === -1\n  ) {\n    return invalidRequest(req, res);\n  }\n\n  var isMaster = info.masterKey === req.config.masterKey;\n\n  if (isMaster) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n    });\n    next();\n    return;\n  }\n\n  var isReadOnlyMaster = info.masterKey === req.config.readOnlyMasterKey;\n  if (\n    typeof req.config.readOnlyMasterKey != 'undefined' &&\n    req.config.readOnlyMasterKey &&\n    isReadOnlyMaster\n  ) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n      isReadOnly: true,\n    });\n    next();\n    return;\n  }\n\n  // Client keys are not required in parse-server, but if any have been configured in the server, validate them\n  //  to preserve original behavior.\n  const keys = ['clientKey', 'javascriptKey', 'dotNetKey', 'restAPIKey'];\n  const oneKeyConfigured = keys.some(function(key) {\n    return req.config[key] !== undefined;\n  });\n  const oneKeyMatches = keys.some(function(key) {\n    return req.config[key] !== undefined && info[key] === req.config[key];\n  });\n\n  if (oneKeyConfigured && !oneKeyMatches) {\n    return invalidRequest(req, res);\n  }\n\n  if (req.url == '/login') {\n    delete info.sessionToken;\n  }\n\n  if (!info.sessionToken) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n    });\n    next();\n    return;\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // handle the upgradeToRevocableSession path on it's own\n      if (\n        info.sessionToken &&\n        req.url === '/upgradeToRevocableSession' &&\n        info.sessionToken.indexOf('r:') != 0\n      ) {\n        return auth.getAuthForLegacySessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      } else {\n        return auth.getAuthForSessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      }\n    })\n    .then(auth => {\n      if (auth) {\n        req.auth = auth;\n        next();\n      }\n    })\n    .catch(error => {\n      if (error instanceof Parse.Error) {\n        next(error);\n        return;\n      } else {\n        // TODO: Determine the correct error scenario.\n        req.config.loggerController.error(\n          'error getting auth for sessionToken',\n          error\n        );\n        throw new Parse.Error(Parse.Error.UNKNOWN_ERROR, error);\n      }\n    });\n}\n\nfunction getClientIp(req) {\n  if (req.headers['x-forwarded-for']) {\n    // try to get from x-forwared-for if it set (behind reverse proxy)\n    return req.headers['x-forwarded-for'].split(',')[0];\n  } else if (req.connection && req.connection.remoteAddress) {\n    // no proxy, try getting from connection.remoteAddress\n    return req.connection.remoteAddress;\n  } else if (req.socket) {\n    // try to get it from req.socket\n    return req.socket.remoteAddress;\n  } else if (req.connection && req.connection.socket) {\n    // try to get it form the connection.socket\n    return req.connection.socket.remoteAddress;\n  } else {\n    // if non above, fallback.\n    return req.ip;\n  }\n}\n\nfunction httpAuth(req) {\n  if (!(req.req || req).headers.authorization) return;\n\n  var header = (req.req || req).headers.authorization;\n  var appId, masterKey, javascriptKey;\n\n  // parse header\n  var authPrefix = 'basic ';\n\n  var match = header.toLowerCase().indexOf(authPrefix);\n\n  if (match == 0) {\n    var encodedAuth = header.substring(authPrefix.length, header.length);\n    var credentials = decodeBase64(encodedAuth).split(':');\n\n    if (credentials.length == 2) {\n      appId = credentials[0];\n      var key = credentials[1];\n\n      var jsKeyPrefix = 'javascript-key=';\n\n      var matchKey = key.indexOf(jsKeyPrefix);\n      if (matchKey == 0) {\n        javascriptKey = key.substring(jsKeyPrefix.length, key.length);\n      } else {\n        masterKey = key;\n      }\n    }\n  }\n\n  return { appId: appId, masterKey: masterKey, javascriptKey: javascriptKey };\n}\n\nfunction decodeBase64(str) {\n  return Buffer.from(str, 'base64').toString();\n}\n\nexport function allowCrossDomain(appId) {\n  return (req, res, next) => {\n    const config = Config.get(appId, getMountForRequest(req));\n    let allowHeaders = DEFAULT_ALLOWED_HEADERS;\n    if (config && config.allowHeaders) {\n      allowHeaders += `, ${config.allowHeaders.join(', ')}`;\n    }\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', allowHeaders);\n    res.header(\n      'Access-Control-Expose-Headers',\n      'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id'\n    );\n    // intercept OPTIONS method\n    if ('OPTIONS' == req.method) {\n      res.sendStatus(200);\n    } else {\n      next();\n    }\n  };\n}\n\nexport function allowMethodOverride(req, res, next) {\n  if (req.method === 'POST' && req.body._method) {\n    req.originalMethod = req.method;\n    req.method = req.body._method;\n    delete req.body._method;\n  }\n  next();\n}\n\nexport function handleParseErrors(err, req, res, next) {\n  const log = (req.config && req.config.loggerController) || defaultLogger;\n  if (err instanceof Parse.Error) {\n    let httpStatus;\n    // TODO: fill out this mapping\n    switch (err.code) {\n      case Parse.Error.INTERNAL_SERVER_ERROR:\n        httpStatus = 500;\n        break;\n      case Parse.Error.OBJECT_NOT_FOUND:\n        httpStatus = 404;\n        break;\n      default:\n        httpStatus = 400;\n    }\n\n    res.status(httpStatus);\n    res.json({ code: err.code, error: err.message });\n    log.error('Parse error: ', err);\n    if (req.config && req.config.enableExpressErrorHandler) {\n      next(err);\n    }\n  } else if (err.status && err.message) {\n    res.status(err.status);\n    res.json({ error: err.message });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  } else {\n    log.error('Uncaught internal server error.', err, err.stack);\n    res.status(500);\n    res.json({\n      code: Parse.Error.INTERNAL_SERVER_ERROR,\n      message: 'Internal server error.',\n    });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  }\n}\n\nexport function enforceMasterKeyAccess(req, res, next) {\n  if (!req.auth.isMaster) {\n    res.status(403);\n    res.end('{\"error\":\"unauthorized: master key is required\"}');\n    return;\n  }\n  next();\n}\n\nexport function promiseEnforceMasterKeyAccess(request) {\n  if (!request.auth.isMaster) {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized: master key is required';\n    throw error;\n  }\n  return Promise.resolve();\n}\n\nfunction invalidRequest(req, res) {\n  res.status(403);\n  res.end('{\"error\":\"unauthorized\"}');\n}\n"], "fixing_code": ["const request = require('../lib/request');\n\nconst serverURL = 'http://localhost:8378/1';\nconst headers = {\n  'Content-Type': 'application/json',\n};\nconst keys = {\n  _ApplicationId: 'test',\n  _JavaScriptKey: 'test',\n};\nconst emailAdapter = {\n  sendVerificationEmail: () => Promise.resolve(),\n  sendPasswordResetEmail: () => Promise.resolve(),\n  sendMail: () => {},\n};\nconst appName = 'test';\nconst publicServerURL = 'http://localhost:8378/1';\n\ndescribe('Regex Vulnerabilities', function() {\n  beforeEach(async function() {\n    await reconfigureServer({\n      verifyUserEmails: true,\n      emailAdapter,\n      appName,\n      publicServerURL,\n    });\n\n    const signUpResponse = await request({\n      url: `${serverURL}/users`,\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        ...keys,\n        _method: 'POST',\n        username: 'someemail@somedomain.com',\n        password: 'somepassword',\n        email: 'someemail@somedomain.com',\n      }),\n    });\n    this.objectId = signUpResponse.data.objectId;\n    this.sessionToken = signUpResponse.data.sessionToken;\n    this.partialSessionToken = this.sessionToken.slice(0, 3);\n  });\n\n  describe('on session token', function() {\n    it('should not work with regex', async function() {\n      try {\n        await request({\n          url: `${serverURL}/users/me`,\n          method: 'POST',\n          headers,\n          body: JSON.stringify({\n            ...keys,\n            _SessionToken: {\n              $regex: this.partialSessionToken,\n            },\n            _method: 'GET',\n          }),\n        });\n        fail('should not work');\n      } catch (e) {\n        expect(e.data.code).toEqual(209);\n        expect(e.data.error).toEqual('Invalid session token');\n      }\n    });\n\n    it('should work with plain token', async function() {\n      const meResponse = await request({\n        url: `${serverURL}/users/me`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _SessionToken: this.sessionToken,\n          _method: 'GET',\n        }),\n      });\n      expect(meResponse.data.objectId).toEqual(this.objectId);\n      expect(meResponse.data.sessionToken).toEqual(this.sessionToken);\n    });\n  });\n\n  describe('on verify e-mail', function() {\n    beforeEach(async function() {\n      const userQuery = new Parse.Query(Parse.User);\n      this.user = await userQuery.get(this.objectId, { useMasterKey: true });\n    });\n\n    it('should not work with regex', async function() {\n      expect(this.user.get('emailVerified')).toEqual(false);\n      await request({\n        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token[$regex]=`,\n        method: 'GET',\n      });\n      await this.user.fetch({ useMasterKey: true });\n      expect(this.user.get('emailVerified')).toEqual(false);\n    });\n\n    it('should work with plain token', async function() {\n      expect(this.user.get('emailVerified')).toEqual(false);\n      // It should work\n      await request({\n        url: `${serverURL}/apps/test/verify_email?username=someemail@somedomain.com&token=${this.user.get(\n          '_email_verify_token'\n        )}`,\n        method: 'GET',\n      });\n      await this.user.fetch({ useMasterKey: true });\n      expect(this.user.get('emailVerified')).toEqual(true);\n    });\n  });\n\n  describe('on password reset', function() {\n    beforeEach(async function() {\n      this.user = await Parse.User.logIn(\n        'someemail@somedomain.com',\n        'somepassword'\n      );\n    });\n\n    it('should not work with regex', async function() {\n      expect(this.user.id).toEqual(this.objectId);\n      await request({\n        url: `${serverURL}/requestPasswordReset`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _method: 'POST',\n          email: 'someemail@somedomain.com',\n        }),\n      });\n      await this.user.fetch({ useMasterKey: true });\n      const passwordResetResponse = await request({\n        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token[$regex]=`,\n        method: 'GET',\n      });\n      expect(passwordResetResponse.status).toEqual(302);\n      expect(passwordResetResponse.headers.location).toMatch(\n        `\\\\/invalid\\\\_link\\\\.html`\n      );\n      await request({\n        url: `${serverURL}/apps/test/request_password_reset`,\n        method: 'POST',\n        body: {\n          token: { $regex: '' },\n          username: 'someemail@somedomain.com',\n          new_password: 'newpassword',\n        },\n      });\n      try {\n        await Parse.User.logIn('someemail@somedomain.com', 'newpassword');\n        fail('should not work');\n      } catch (e) {\n        expect(e.code).toEqual(101);\n        expect(e.message).toEqual('Invalid username/password.');\n      }\n    });\n\n    it('should work with plain token', async function() {\n      expect(this.user.id).toEqual(this.objectId);\n      await request({\n        url: `${serverURL}/requestPasswordReset`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          ...keys,\n          _method: 'POST',\n          email: 'someemail@somedomain.com',\n        }),\n      });\n      await this.user.fetch({ useMasterKey: true });\n      const token = this.user.get('_perishable_token');\n      const passwordResetResponse = await request({\n        url: `${serverURL}/apps/test/request_password_reset?username=someemail@somedomain.com&token=${token}`,\n        method: 'GET',\n      });\n      expect(passwordResetResponse.status).toEqual(302);\n      expect(passwordResetResponse.headers.location).toMatch(\n        `\\\\/choose\\\\_password\\\\?token\\\\=${token}\\\\&`\n      );\n      await request({\n        url: `${serverURL}/apps/test/request_password_reset`,\n        method: 'POST',\n        body: {\n          token,\n          username: 'someemail@somedomain.com',\n          new_password: 'newpassword',\n        },\n      });\n      const userAgain = await Parse.User.logIn(\n        'someemail@somedomain.com',\n        'newpassword'\n      );\n      expect(userAgain.id).toEqual(this.objectId);\n    });\n  });\n});\n", "import PromiseRouter from '../PromiseRouter';\nimport Config from '../Config';\nimport express from 'express';\nimport path from 'path';\nimport fs from 'fs';\nimport qs from 'querystring';\nimport { Parse } from 'parse/node';\n\nconst public_html = path.resolve(__dirname, '../../public_html');\nconst views = path.resolve(__dirname, '../../views');\n\nexport class PublicAPIRouter extends PromiseRouter {\n  verifyEmail(req) {\n    const { username, token: rawToken } = req.query;\n    const token =\n      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n\n    const appId = req.params.appId;\n    const config = Config.get(appId);\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    if (!token || !username) {\n      return this.invalidLink(req);\n    }\n\n    const userController = config.userController;\n    return userController.verifyEmail(username, token).then(\n      () => {\n        const params = qs.stringify({ username });\n        return Promise.resolve({\n          status: 302,\n          location: `${config.verifyEmailSuccessURL}?${params}`,\n        });\n      },\n      () => {\n        return this.invalidVerificationLink(req);\n      }\n    );\n  }\n\n  resendVerificationEmail(req) {\n    const username = req.body.username;\n    const appId = req.params.appId;\n    const config = Config.get(appId);\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    if (!username) {\n      return this.invalidLink(req);\n    }\n\n    const userController = config.userController;\n\n    return userController.resendVerificationEmail(username).then(\n      () => {\n        return Promise.resolve({\n          status: 302,\n          location: `${config.linkSendSuccessURL}`,\n        });\n      },\n      () => {\n        return Promise.resolve({\n          status: 302,\n          location: `${config.linkSendFailURL}`,\n        });\n      }\n    );\n  }\n\n  changePassword(req) {\n    return new Promise((resolve, reject) => {\n      const config = Config.get(req.query.id);\n\n      if (!config) {\n        this.invalidRequest();\n      }\n\n      if (!config.publicServerURL) {\n        return resolve({\n          status: 404,\n          text: 'Not found.',\n        });\n      }\n      // Should we keep the file in memory or leave like that?\n      fs.readFile(\n        path.resolve(views, 'choose_password'),\n        'utf-8',\n        (err, data) => {\n          if (err) {\n            return reject(err);\n          }\n          data = data.replace(\n            'PARSE_SERVER_URL',\n            `'${config.publicServerURL}'`\n          );\n          resolve({\n            text: data,\n          });\n        }\n      );\n    });\n  }\n\n  requestResetPassword(req) {\n    const config = req.config;\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    const { username, token: rawToken } = req.query;\n    const token =\n      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n\n    if (!username || !token) {\n      return this.invalidLink(req);\n    }\n\n    return config.userController.checkResetTokenValidity(username, token).then(\n      () => {\n        const params = qs.stringify({\n          token,\n          id: config.applicationId,\n          username,\n          app: config.appName,\n        });\n        return Promise.resolve({\n          status: 302,\n          location: `${config.choosePasswordURL}?${params}`,\n        });\n      },\n      () => {\n        return this.invalidLink(req);\n      }\n    );\n  }\n\n  resetPassword(req) {\n    const config = req.config;\n\n    if (!config) {\n      this.invalidRequest();\n    }\n\n    if (!config.publicServerURL) {\n      return this.missingPublicServerURL();\n    }\n\n    const { username, new_password, token: rawToken } = req.body;\n    const token =\n      rawToken && typeof rawToken !== 'string' ? rawToken.toString() : rawToken;\n\n    if ((!username || !token || !new_password) && req.xhr === false) {\n      return this.invalidLink(req);\n    }\n\n    if (!username) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'Missing username');\n    }\n\n    if (!token) {\n      throw new Parse.Error(Parse.Error.OTHER_CAUSE, 'Missing token');\n    }\n\n    if (!new_password) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'Missing password');\n    }\n\n    return config.userController\n      .updatePassword(username, token, new_password)\n      .then(\n        () => {\n          return Promise.resolve({\n            success: true,\n          });\n        },\n        err => {\n          return Promise.resolve({\n            success: false,\n            err,\n          });\n        }\n      )\n      .then(result => {\n        const params = qs.stringify({\n          username: username,\n          token: token,\n          id: config.applicationId,\n          error: result.err,\n          app: config.appName,\n        });\n\n        if (req.xhr) {\n          if (result.success) {\n            return Promise.resolve({\n              status: 200,\n              response: 'Password successfully reset',\n            });\n          }\n          if (result.err) {\n            throw new Parse.Error(Parse.Error.OTHER_CAUSE, `${result.err}`);\n          }\n        }\n\n        const encodedUsername = encodeURIComponent(username);\n        const location = result.success\n          ? `${config.passwordResetSuccessURL}?username=${encodedUsername}`\n          : `${config.choosePasswordURL}?${params}`;\n\n        return Promise.resolve({\n          status: 302,\n          location,\n        });\n      });\n  }\n\n  invalidLink(req) {\n    return Promise.resolve({\n      status: 302,\n      location: req.config.invalidLinkURL,\n    });\n  }\n\n  invalidVerificationLink(req) {\n    const config = req.config;\n    if (req.query.username && req.params.appId) {\n      const params = qs.stringify({\n        username: req.query.username,\n        appId: req.params.appId,\n      });\n      return Promise.resolve({\n        status: 302,\n        location: `${config.invalidVerificationLinkURL}?${params}`,\n      });\n    } else {\n      return this.invalidLink(req);\n    }\n  }\n\n  missingPublicServerURL() {\n    return Promise.resolve({\n      text: 'Not found.',\n      status: 404,\n    });\n  }\n\n  invalidRequest() {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized';\n    throw error;\n  }\n\n  setConfig(req) {\n    req.config = Config.get(req.params.appId);\n    return Promise.resolve();\n  }\n\n  mountRoutes() {\n    this.route(\n      'GET',\n      '/apps/:appId/verify_email',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.verifyEmail(req);\n      }\n    );\n\n    this.route(\n      'POST',\n      '/apps/:appId/resend_verification_email',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.resendVerificationEmail(req);\n      }\n    );\n\n    this.route('GET', '/apps/choose_password', req => {\n      return this.changePassword(req);\n    });\n\n    this.route(\n      'POST',\n      '/apps/:appId/request_password_reset',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.resetPassword(req);\n      }\n    );\n\n    this.route(\n      'GET',\n      '/apps/:appId/request_password_reset',\n      req => {\n        this.setConfig(req);\n      },\n      req => {\n        return this.requestResetPassword(req);\n      }\n    );\n  }\n\n  expressRouter() {\n    const router = express.Router();\n    router.use('/apps', express.static(public_html));\n    router.use('/', super.expressRouter());\n    return router;\n  }\n}\n\nexport default PublicAPIRouter;\n", "import AppCache from './cache';\nimport Parse from 'parse/node';\nimport auth from './Auth';\nimport Config from './Config';\nimport ClientSDK from './ClientSDK';\nimport defaultLogger from './logger';\n\nexport const DEFAULT_ALLOWED_HEADERS =\n  'X-Parse-Master-Key, X-Parse-REST-API-Key, X-Parse-Javascript-Key, X-Parse-Application-Id, X-Parse-Client-Version, X-Parse-Session-Token, X-Requested-With, X-Parse-Revocable-Session, Content-Type, Pragma, Cache-Control';\n\nconst getMountForRequest = function(req) {\n  const mountPathLength = req.originalUrl.length - req.url.length;\n  const mountPath = req.originalUrl.slice(0, mountPathLength);\n  return req.protocol + '://' + req.get('host') + mountPath;\n};\n\n// Checks that the request is authorized for this app and checks user\n// auth too.\n// The bodyparser should run before this middleware.\n// Adds info to the request:\n// req.config - the Config for this app\n// req.auth - the Auth for this request\nexport function handleParseHeaders(req, res, next) {\n  var mount = getMountForRequest(req);\n\n  var info = {\n    appId: req.get('X-Parse-Application-Id'),\n    sessionToken: req.get('X-Parse-Session-Token'),\n    masterKey: req.get('X-Parse-Master-Key'),\n    installationId: req.get('X-Parse-Installation-Id'),\n    clientKey: req.get('X-Parse-Client-Key'),\n    javascriptKey: req.get('X-Parse-Javascript-Key'),\n    dotNetKey: req.get('X-Parse-Windows-Key'),\n    restAPIKey: req.get('X-Parse-REST-API-Key'),\n    clientVersion: req.get('X-Parse-Client-Version'),\n  };\n\n  var basicAuth = httpAuth(req);\n\n  if (basicAuth) {\n    var basicAuthAppId = basicAuth.appId;\n    if (AppCache.get(basicAuthAppId)) {\n      info.appId = basicAuthAppId;\n      info.masterKey = basicAuth.masterKey || info.masterKey;\n      info.javascriptKey = basicAuth.javascriptKey || info.javascriptKey;\n    }\n  }\n\n  if (req.body) {\n    // Unity SDK sends a _noBody key which needs to be removed.\n    // Unclear at this point if action needs to be taken.\n    delete req.body._noBody;\n  }\n\n  var fileViaJSON = false;\n\n  if (!info.appId || !AppCache.get(info.appId)) {\n    // See if we can find the app id on the body.\n    if (req.body instanceof Buffer) {\n      // The only chance to find the app id is if this is a file\n      // upload that actually is a JSON body. So try to parse it.\n      req.body = JSON.parse(req.body);\n      fileViaJSON = true;\n    }\n\n    if (req.body) {\n      delete req.body._RevocableSession;\n    }\n\n    if (\n      req.body &&\n      req.body._ApplicationId &&\n      AppCache.get(req.body._ApplicationId) &&\n      (!info.masterKey ||\n        AppCache.get(req.body._ApplicationId).masterKey === info.masterKey)\n    ) {\n      info.appId = req.body._ApplicationId;\n      info.javascriptKey = req.body._JavaScriptKey || '';\n      delete req.body._ApplicationId;\n      delete req.body._JavaScriptKey;\n      // TODO: test that the REST API formats generated by the other\n      // SDKs are handled ok\n      if (req.body._ClientVersion) {\n        info.clientVersion = req.body._ClientVersion;\n        delete req.body._ClientVersion;\n      }\n      if (req.body._InstallationId) {\n        info.installationId = req.body._InstallationId;\n        delete req.body._InstallationId;\n      }\n      if (req.body._SessionToken) {\n        info.sessionToken = req.body._SessionToken;\n        delete req.body._SessionToken;\n      }\n      if (req.body._MasterKey) {\n        info.masterKey = req.body._MasterKey;\n        delete req.body._MasterKey;\n      }\n      if (req.body._ContentType) {\n        req.headers['content-type'] = req.body._ContentType;\n        delete req.body._ContentType;\n      }\n    } else {\n      return invalidRequest(req, res);\n    }\n  }\n\n  if (info.sessionToken && typeof info.sessionToken !== 'string') {\n    info.sessionToken = info.sessionToken.toString();\n  }\n\n  if (info.clientVersion) {\n    info.clientSDK = ClientSDK.fromString(info.clientVersion);\n  }\n\n  if (fileViaJSON) {\n    // We need to repopulate req.body with a buffer\n    var base64 = req.body.base64;\n    req.body = Buffer.from(base64, 'base64');\n  }\n\n  const clientIp = getClientIp(req);\n\n  info.app = AppCache.get(info.appId);\n  req.config = Config.get(info.appId, mount);\n  req.config.headers = req.headers || {};\n  req.config.ip = clientIp;\n  req.info = info;\n\n  if (\n    info.masterKey &&\n    req.config.masterKeyIps &&\n    req.config.masterKeyIps.length !== 0 &&\n    req.config.masterKeyIps.indexOf(clientIp) === -1\n  ) {\n    return invalidRequest(req, res);\n  }\n\n  var isMaster = info.masterKey === req.config.masterKey;\n\n  if (isMaster) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n    });\n    next();\n    return;\n  }\n\n  var isReadOnlyMaster = info.masterKey === req.config.readOnlyMasterKey;\n  if (\n    typeof req.config.readOnlyMasterKey != 'undefined' &&\n    req.config.readOnlyMasterKey &&\n    isReadOnlyMaster\n  ) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n      isReadOnly: true,\n    });\n    next();\n    return;\n  }\n\n  // Client keys are not required in parse-server, but if any have been configured in the server, validate them\n  //  to preserve original behavior.\n  const keys = ['clientKey', 'javascriptKey', 'dotNetKey', 'restAPIKey'];\n  const oneKeyConfigured = keys.some(function(key) {\n    return req.config[key] !== undefined;\n  });\n  const oneKeyMatches = keys.some(function(key) {\n    return req.config[key] !== undefined && info[key] === req.config[key];\n  });\n\n  if (oneKeyConfigured && !oneKeyMatches) {\n    return invalidRequest(req, res);\n  }\n\n  if (req.url == '/login') {\n    delete info.sessionToken;\n  }\n\n  if (!info.sessionToken) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n    });\n    next();\n    return;\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // handle the upgradeToRevocableSession path on it's own\n      if (\n        info.sessionToken &&\n        req.url === '/upgradeToRevocableSession' &&\n        info.sessionToken.indexOf('r:') != 0\n      ) {\n        return auth.getAuthForLegacySessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      } else {\n        return auth.getAuthForSessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      }\n    })\n    .then(auth => {\n      if (auth) {\n        req.auth = auth;\n        next();\n      }\n    })\n    .catch(error => {\n      if (error instanceof Parse.Error) {\n        next(error);\n        return;\n      } else {\n        // TODO: Determine the correct error scenario.\n        req.config.loggerController.error(\n          'error getting auth for sessionToken',\n          error\n        );\n        throw new Parse.Error(Parse.Error.UNKNOWN_ERROR, error);\n      }\n    });\n}\n\nfunction getClientIp(req) {\n  if (req.headers['x-forwarded-for']) {\n    // try to get from x-forwared-for if it set (behind reverse proxy)\n    return req.headers['x-forwarded-for'].split(',')[0];\n  } else if (req.connection && req.connection.remoteAddress) {\n    // no proxy, try getting from connection.remoteAddress\n    return req.connection.remoteAddress;\n  } else if (req.socket) {\n    // try to get it from req.socket\n    return req.socket.remoteAddress;\n  } else if (req.connection && req.connection.socket) {\n    // try to get it form the connection.socket\n    return req.connection.socket.remoteAddress;\n  } else {\n    // if non above, fallback.\n    return req.ip;\n  }\n}\n\nfunction httpAuth(req) {\n  if (!(req.req || req).headers.authorization) return;\n\n  var header = (req.req || req).headers.authorization;\n  var appId, masterKey, javascriptKey;\n\n  // parse header\n  var authPrefix = 'basic ';\n\n  var match = header.toLowerCase().indexOf(authPrefix);\n\n  if (match == 0) {\n    var encodedAuth = header.substring(authPrefix.length, header.length);\n    var credentials = decodeBase64(encodedAuth).split(':');\n\n    if (credentials.length == 2) {\n      appId = credentials[0];\n      var key = credentials[1];\n\n      var jsKeyPrefix = 'javascript-key=';\n\n      var matchKey = key.indexOf(jsKeyPrefix);\n      if (matchKey == 0) {\n        javascriptKey = key.substring(jsKeyPrefix.length, key.length);\n      } else {\n        masterKey = key;\n      }\n    }\n  }\n\n  return { appId: appId, masterKey: masterKey, javascriptKey: javascriptKey };\n}\n\nfunction decodeBase64(str) {\n  return Buffer.from(str, 'base64').toString();\n}\n\nexport function allowCrossDomain(appId) {\n  return (req, res, next) => {\n    const config = Config.get(appId, getMountForRequest(req));\n    let allowHeaders = DEFAULT_ALLOWED_HEADERS;\n    if (config && config.allowHeaders) {\n      allowHeaders += `, ${config.allowHeaders.join(', ')}`;\n    }\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', allowHeaders);\n    res.header(\n      'Access-Control-Expose-Headers',\n      'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id'\n    );\n    // intercept OPTIONS method\n    if ('OPTIONS' == req.method) {\n      res.sendStatus(200);\n    } else {\n      next();\n    }\n  };\n}\n\nexport function allowMethodOverride(req, res, next) {\n  if (req.method === 'POST' && req.body._method) {\n    req.originalMethod = req.method;\n    req.method = req.body._method;\n    delete req.body._method;\n  }\n  next();\n}\n\nexport function handleParseErrors(err, req, res, next) {\n  const log = (req.config && req.config.loggerController) || defaultLogger;\n  if (err instanceof Parse.Error) {\n    let httpStatus;\n    // TODO: fill out this mapping\n    switch (err.code) {\n      case Parse.Error.INTERNAL_SERVER_ERROR:\n        httpStatus = 500;\n        break;\n      case Parse.Error.OBJECT_NOT_FOUND:\n        httpStatus = 404;\n        break;\n      default:\n        httpStatus = 400;\n    }\n\n    res.status(httpStatus);\n    res.json({ code: err.code, error: err.message });\n    log.error('Parse error: ', err);\n    if (req.config && req.config.enableExpressErrorHandler) {\n      next(err);\n    }\n  } else if (err.status && err.message) {\n    res.status(err.status);\n    res.json({ error: err.message });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  } else {\n    log.error('Uncaught internal server error.', err, err.stack);\n    res.status(500);\n    res.json({\n      code: Parse.Error.INTERNAL_SERVER_ERROR,\n      message: 'Internal server error.',\n    });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  }\n}\n\nexport function enforceMasterKeyAccess(req, res, next) {\n  if (!req.auth.isMaster) {\n    res.status(403);\n    res.end('{\"error\":\"unauthorized: master key is required\"}');\n    return;\n  }\n  next();\n}\n\nexport function promiseEnforceMasterKeyAccess(request) {\n  if (!request.auth.isMaster) {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized: master key is required';\n    throw error;\n  }\n  return Promise.resolve();\n}\n\nfunction invalidRequest(req, res) {\n  res.status(403);\n  res.end('{\"error\":\"unauthorized\"}');\n}\n"], "buggy_code_start_loc": [1, 14, 105], "buggy_code_end_loc": [2, 162, 105], "fixing_code_start_loc": [1, 14, 106], "fixing_code_end_loc": [199, 169, 110], "type": "CWE-863", "message": "In parser-server before version 4.1.0, you can fetch all the users objects, by using regex in the NoSQL query. Using the NoSQL, you can use a regex on sessionToken and find valid accounts this way.", "other": {"cve": {"id": "CVE-2020-5251", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-04T15:15:13.210", "lastModified": "2020-03-06T00:03:35.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In parser-server before version 4.1.0, you can fetch all the users objects, by using regex in the NoSQL query. Using the NoSQL, you can use a regex on sessionToken and find valid accounts this way."}, {"lang": "es", "value": "En parser-server versiones anteriores a 4.1.0, pueden obtener todos los objetos de los usuarios, mediante el uso de regex en la consulta NoSQL. Usando el NoSQL, pueden usar un regex en sessionToken y encontrar cuentas v\u00e1lidas de esta manera."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "0C25D021-10D0-4A49-B022-BCC1961A873C"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269"}}