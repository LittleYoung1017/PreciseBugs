diff --git a/psi/zcfont.c b/psi/zcfont.c
index 1ef99e367..e1758261f 100644
--- a/psi/zcfont.c
+++ b/psi/zcfont.c
@@ -64,7 +64,7 @@ zcshow(i_ctx_t *i_ctx_p)
         return code;
     }
     sslot = *proc_op;		/* save kerning proc */
-    pop(2);
+    ref_stack_pop(&o_stack, 2);
     return cshow_continue(i_ctx_p);
 }
 static int
diff --git a/psi/zchar1.c b/psi/zchar1.c
index c289b3e25..064b909a3 100644
--- a/psi/zchar1.c
+++ b/psi/zchar1.c
@@ -557,7 +557,7 @@ bbox_finish(i_ctx_t *i_ctx_p, op_proc_t cont, op_proc_t *exec_cont)
         case 0:		/* all done */
             /* Call the continuation now. */
             if (psbpt)
-                pop(2);
+                ref_stack_pop(&o_stack, 2);
             *exec_cont = cont;
             return 0;
         case type1_result_callothersubr:	/* unknown OtherSubr */
diff --git a/psi/zcolor.c b/psi/zcolor.c
index 0b71b934a..64e0b8d0a 100644
--- a/psi/zcolor.c
+++ b/psi/zcolor.c
@@ -688,7 +688,7 @@ zsettransfer(i_ctx_t * i_ctx_p)
     if ((code = gs_settransfer_remap(igs, gs_mapped_transfer, false)) < 0)
         return code;
     push_op_estack(zcolor_reset_transfer);
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     return zcolor_remap_one( i_ctx_p,
                              &istate->transfer_procs.gray,
                              igs->set_transfer.gray,
@@ -1051,7 +1051,7 @@ static int setgrayspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CI
                     *stage = 1;
                     break;
                 }
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *cont = 1;
                 *stage = 3;
                 code = setcolorspace_nosubst(i_ctx_p);
@@ -1075,7 +1075,7 @@ static int setgrayspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CI
                  */
                 if (!r_has_type(op, t_boolean))
                     return_error(gs_error_typecheck);
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *stage = 1;
                 *cont = 1;
                 if (op->value.boolval) {
@@ -1276,7 +1276,7 @@ static int setrgbspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIE
                     *stage = 1;
                     break;
                 }
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *stage = 3;
                 code = setcolorspace_nosubst(i_ctx_p);
                 if (code != 0)
@@ -1299,7 +1299,7 @@ static int setrgbspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIE
                  */
                 if (!r_has_type(op, t_boolean))
                     return_error(gs_error_typecheck);
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *stage = 1;
                 *cont = 1;
                 if (op->value.boolval) {
@@ -1391,7 +1391,7 @@ static int rgbbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int
 
             switch (base) {
                 case 0:
-                    pop(2);
+                    ref_stack_pop(&o_stack, 2);
                     op = osp;
                     /* If R == G == B, then this is gray, so just use it. Avoids
                      * rounding errors.
@@ -1500,7 +1500,7 @@ static int rgbbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int
                     return_error(gs_error_typecheck);
             } else
                 BG = (float)op->value.intval;
-            pop(1);
+            ref_stack_pop(&o_stack, 1);
             op = osp;
             if (BG < 0)
                 BG = 0;
@@ -1628,7 +1628,7 @@ static int setcmykspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CI
                     *stage = 1;
                     break;
                 }
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *stage = 3;
                 code = setcolorspace_nosubst(i_ctx_p);
                 if (code != 0)
@@ -1651,7 +1651,7 @@ static int setcmykspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CI
                  */
                 if (!r_has_type(op, t_boolean))
                     return_error(gs_error_typecheck);
-                pop(1);
+                ref_stack_pop(&o_stack, 1);
                 *stage = 1;
                 *cont = 1;
                 if (op->value.boolval) {
@@ -1741,7 +1741,7 @@ static int cmykbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, in
 
     switch (base) {
         case 0:
-            pop(3);
+            ref_stack_pop(&o_stack, 3);
             op = osp;
             Gray = (0.3 * CMYK[0]) + (0.59 * CMYK[1]) + (0.11 * CMYK[2]) + CMYK[3];
             if (Gray > 1.0)
@@ -1752,7 +1752,7 @@ static int cmykbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, in
             break;
         case 1:
         case 2:
-            pop(1);
+            ref_stack_pop(&o_stack, 1);
             op = osp;
             RGB[0] = 1.0 - (CMYK[0] + CMYK[3]);
             if (RGB[0] < 0)
@@ -3320,7 +3320,7 @@ static int ciebasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int
             break;
     }
     /* Remove teh requisite number of values */
-    pop(components);
+    ref_stack_pop(&o_stack, components);
     op = osp;
     /* Find out how many values we need to return, which
      * depends on the requested space.
@@ -3645,7 +3645,7 @@ static int sepbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int
         if (!use) {
             *stage = 0;
             *cont = 0;
-            pop(1);
+            ref_stack_pop(&o_stack, 1);
             op = osp;
             switch(base) {
                 case 0:
@@ -4475,7 +4475,7 @@ static int devicenbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage,
         if (code < 0)
             return code;
         n_comp = r_size(&narray);
-        pop(n_comp);
+        ref_stack_pop(&o_stack, n_comp);
         op = osp;
         switch(base) {
         case 0:
@@ -4618,7 +4618,7 @@ indexed_cont(i_ctx_t *i_ctx_p)
             esp -= num_csme;
             return code;
         }
-        pop(m);
+        ref_stack_pop(&o_stack, m);
         op -= m;
         if (i == (int)ep[csme_hival].value.intval) {	/* All done. */
             esp -= num_csme;
@@ -4878,7 +4878,7 @@ static int indexedbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage,
                 return_error (gs_error_typecheck);
             index = op->value.intval;
             /* And remove it from the stack. */
-            pop(1);
+            ref_stack_pop(&o_stack, 1);
             op = osp;
 
             /* Make sure we have enough space on the op stack to hold
@@ -5094,7 +5094,7 @@ static int patternbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage,
          */
     }
 
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     op = osp;
     switch(base) {
         case 0:
@@ -5428,7 +5428,7 @@ static int labbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int
     int i, components=1;
 
     components = 3;
-    pop(components);
+    ref_stack_pop(&o_stack, components);
     op = osp;
     components = 3;
     push(components);
@@ -5953,7 +5953,7 @@ static int seticcspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIE
                                 return code;
                             *stage = 0;
                         }
-                        pop(1);
+                        ref_stack_pop(&o_stack, 1);
                     }
                     if (code != 0)
                         return code;
diff --git a/psi/zcolor1.c b/psi/zcolor1.c
index e33c4377f..8c6c2bf8a 100644
--- a/psi/zcolor1.c
+++ b/psi/zcolor1.c
@@ -82,7 +82,7 @@ zsetblackgeneration(i_ctx_t *i_ctx_p)
     if (code < 0)
         return code;
     istate->black_generation = *op;
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     push_op_estack(zcolor_remap_color);
     return zcolor_remap_one(i_ctx_p, &istate->black_generation,
                             igs->black_generation, igs,
@@ -114,7 +114,7 @@ zsetcolortransfer(i_ctx_t *i_ctx_p)
         )
         return code;
     /* Use osp rather than op here, because zcolor_remap_one pushes. */
-    pop(4);
+    ref_stack_pop(&o_stack, 4);
     push_op_estack(zcolor_reset_transfer);
     if ((code = zcolor_remap_one(i_ctx_p,
                                  &istate->transfer_procs.red,
@@ -156,7 +156,7 @@ zsetundercolorremoval(i_ctx_t *i_ctx_p)
     if (code < 0)
         return code;
     istate->undercolor_removal = *op;
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     push_op_estack(zcolor_remap_color);
     return zcolor_remap_one(i_ctx_p, &istate->undercolor_removal,
                             igs->undercolor_removal, igs,
diff --git a/psi/zdevice.c b/psi/zdevice.c
index a9d4e8a14..3ba01fc35 100644
--- a/psi/zdevice.c
+++ b/psi/zdevice.c
@@ -289,7 +289,7 @@ zget_device_params(i_ctx_t *i_ctx_p, bool is_hardware)
     if (op[-1].value.pdevice == NULL)
         /* This can happen if we invalidated devices on the stack by calling nulldevice after they were pushed */
         return_error(gs_error_undefined);
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     stack_param_list_write(&list, &o_stack, &rkeys, iimemory);
     code = gs_get_device_or_hardware_params(dev, (gs_param_list *) & list,
                                             is_hardware);
@@ -628,7 +628,7 @@ zspec_op(i_ctx_t *i_ctx_p)
     if (proc < 0)
         return_error(gs_error_undefined);
 
-    pop(1);     /* We don't need the name of the spec_op any more */
+    ref_stack_pop(&o_stack, 1);     /* We don't need the name of the spec_op any more */
     op = osp;
 
     switch(proc) {
diff --git a/psi/zfile.c b/psi/zfile.c
index 11fd6f8e6..46040701a 100644
--- a/psi/zfile.c
+++ b/psi/zfile.c
@@ -412,7 +412,7 @@ zfilenameforall(i_ctx_t *i_ctx_p)
     ++esp;
     make_istruct(esp, 0, pfen);
     *++esp = op[-1];
-    pop(3);
+    ref_stack_pop(&o_stack, 3);
     code = file_continue(i_ctx_p);
     return (code == o_pop_estack ? o_push_estack : code);
 }
diff --git a/psi/zfunc.c b/psi/zfunc.c
index 97d576569..2a289f10d 100644
--- a/psi/zfunc.c
+++ b/psi/zfunc.c
@@ -140,7 +140,7 @@ zexecfunction(i_ctx_t *i_ctx_p)
                 if (diff > 0)
                     push(diff);	/* can't fail */
                 else if (diff < 0) {
-                    pop(-diff);
+                    ref_stack_pop(&o_stack, -diff);
                     op = osp;
                 }
                 code = make_floats(op + 1 - n, out, n);
diff --git a/psi/zgeneric.c b/psi/zgeneric.c
index 26d9fa229..098df52d6 100644
--- a/psi/zgeneric.c
+++ b/psi/zgeneric.c
@@ -450,7 +450,7 @@ zforall(i_ctx_t *i_ctx_p)
     ep[2] = *obj;
     ep[3] = *op;
     esp = cproc - 1;
-    pop(2);
+    ref_stack_pop(&o_stack, 2);
     return (*real_opproc(cproc))(i_ctx_p);
 }
 /* Continuation operator for arrays */
diff --git a/psi/zht.c b/psi/zht.c
index 6f707a3fc..f1cc8d94d 100644
--- a/psi/zht.c
+++ b/psi/zht.c
@@ -221,7 +221,7 @@ set_screen_continue(i_ctx_t *i_ctx_p)
     code = gs_screen_next(senum, value);
     if (code < 0)
         return code;
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     return screen_sample(i_ctx_p);
 }
 /* Finish setscreen. */
diff --git a/psi/zht2.c b/psi/zht2.c
index de60c53bc..f42a08218 100644
--- a/psi/zht2.c
+++ b/psi/zht2.c
@@ -351,7 +351,7 @@ zsethalftone5(i_ctx_t *i_ctx_p)
 
         odict = op[-1];
         odict5 = *op;
-        pop(2);
+        ref_stack_pop(&o_stack, 2);
         op = osp;
         esp += 5;
         make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
diff --git a/psi/zicc.c b/psi/zicc.c
index 91f1c41c9..2eda1c981 100644
--- a/psi/zicc.c
+++ b/psi/zicc.c
@@ -68,7 +68,7 @@ int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
             /* Set the color space.  We are done. */
             code = gs_setcolorspace(igs, pcs);
             /* Remove the ICC dict from the stack */
-            pop(1);
+            ref_stack_pop(&o_stack, 1);
             return code;
         }
     }
@@ -235,7 +235,7 @@ int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
         }
     }
     /* Remove the ICC dict from the stack */
-    pop(1);
+    ref_stack_pop(&o_stack, 1);
     return code;
 }
 
diff --git a/psi/ziodev.c b/psi/ziodev.c
index c75ecc62e..9d30f9625 100644
--- a/psi/ziodev.c
+++ b/psi/ziodev.c
@@ -293,7 +293,7 @@ sc:
         return_error(gs_error_VMerror);
     }
 
-    pop(3);
+    ref_stack_pop(&o_stack, 3);
     make_stream_file(osp, s, "r");
 
     return code;
diff --git a/psi/ziodev2.c b/psi/ziodev2.c
index 3e8198d81..fa827d8ee 100644
--- a/psi/ziodev2.c
+++ b/psi/ziodev2.c
@@ -75,7 +75,7 @@ zgetdevparams(i_ctx_t *i_ctx_p)
         return_error(gs_error_undefined);
     stack_param_list_write(&list, &o_stack, NULL, iimemory);
     if ((code = gs_getdevparams(iodev, plist)) < 0) {
-        ref_stack_pop(&o_stack, list.count * 2);
+        pop(list.count * 2);
         return code;
     }
     pmark = ref_stack_index(&o_stack, list.count * 2);
@@ -114,7 +114,7 @@ zputdevparams(i_ctx_t *i_ctx_p)
     iparam_list_release(&list);
     if (code < 0)
         return code;
-    ref_stack_pop(&o_stack, list.count * 2 + 2);
+    pop(list.count * 2 + 2);
     return 0;
 }
 
diff --git a/psi/zpcolor.c b/psi/zpcolor.c
index 26e15dd2e..aef5374b1 100644
--- a/psi/zpcolor.c
+++ b/psi/zpcolor.c
@@ -387,6 +387,9 @@ pattern_paint_finish(i_ctx_t *i_ctx_p)
 #if 0
         dmlprintf1(imemory, "PaintProc left %d extra on operator stack!\n", o_stack_adjust);
 #endif
+        /* Take care here: if anything is added after this that may access the op stack,
+           this needs to be ref_stack_pop() rather than pop().
+         */
         pop(o_stack_adjust);
     }
     esp -= 5;
diff --git a/psi/zpdf_r6.c b/psi/zpdf_r6.c
index 218e45401..6da5007f3 100644
--- a/psi/zpdf_r6.c
+++ b/psi/zpdf_r6.c
@@ -185,7 +185,7 @@ zcheck_r6_password(i_ctx_t * i_ctx_p)
     if (r_size(UEref) < 32)
         return_error(gs_error_invalidaccess);
 
-    pop(2);
+    ref_stack_pop(&o_stack, 2);
     op = osp;
 
     PWlen = r_size(Pref);
diff --git a/psi/zpdfops.c b/psi/zpdfops.c
index 0707dd5b4..2539c275c 100644
--- a/psi/zpdfops.c
+++ b/psi/zpdfops.c
@@ -164,7 +164,7 @@ zpdfinkpath(i_ctx_t *i_ctx_p)
         y0 = y1, y1 = y2, y2 = y3;
     }
   pop:
-    ref_stack_pop(&o_stack, 1);
+    pop(1);
     return 0;
 }
 
@@ -185,7 +185,7 @@ zpdfFormName(i_ctx_t *i_ctx_p)
     if (code < 0)
         return code;
 
-    ref_stack_pop(&o_stack, 1);
+    pop(1);
     return 0;
 }
 
diff --git a/psi/zupath.c b/psi/zupath.c
index 8a1095cef..fb60443df 100644
--- a/psi/zupath.c
+++ b/psi/zupath.c
@@ -228,7 +228,7 @@ in_path_result(i_ctx_t *i_ctx_p, int npop, int code)
     else			/* error */
         return code;
     npop--;
-    pop(npop);
+    ref_stack_pop(&o_stack, npop);
     op -= npop;
     make_bool(op, result);
     return 0;
