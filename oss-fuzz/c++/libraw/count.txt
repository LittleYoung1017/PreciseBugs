ce2250c6	b979a78c	Tue Aug 30 16:51:32 2022 +0100	Fixes Use-of-uninitialized-value in LibRaw::phase_one_flat_field	commit ce2250c6645897d1ff6a44c8167dde76730a0372Author: Alex <93376818+sashashura@users.noreply.github.com>Date:   Tue Aug 30 16:51:32 2022 +0100    Fixes Use-of-uninitialized-value in LibRaw::phase_one_flat_field        https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46615        When `LibRaw::read_shorts` fails to read from stream because it is already `eof` it doesn't initialize the output `pixel` buffer.    The the unitialized buffer is used like:    ```cpp      ushort head[8];    ...      read_shorts(head, 8);      if (head[2] == 0 || head[3] == 0 || head[4] == 0 || head[5] == 0)        return;      wide = head[2] / head[4] + (head[2] % head[4] != 0);      high = head[3] / head[5] + (head[3] % head[5] != 0);    ```    The stream reaches eof higher in the stack in `phase_one_correct`.
aa61a015	dd1df9bc	Sun Jul 24 15:21:43 2022 +0100	Fixes Use-of-uninitialized-value in LibRaw::parse_fuji_compressed_header	commit aa61a015845d12e19e5ee5fcfca28ef6b5cebf55Author: Aleks L <93376818+sashashura@users.noreply.github.com>Date:   Sun Jul 24 15:21:43 2022 +0100    Fixes Use-of-uninitialized-value in LibRaw::parse_fuji_compressed_header        https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46224        The `uchar header[16];` in `LibRaw::parse_fuji_compressed_header` is not initialized (contains garbage) because the stream is eof.
963446e2	dd1df9bc	Sun Jul 24 15:08:56 2022 +0100	Fixes Use-of-uninitialized-value in LibRaw::init_fuji_block	commit 963446e229c96cbeed59265bb9fde624b2e3e99cAuthor: Aleks L <93376818+sashashura@users.noreply.github.com>Date:   Sun Jul 24 15:08:56 2022 +0100    Fixes Use-of-uninitialized-value in LibRaw::init_fuji_block        https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46244        The root cause is up in the stack. The `unsigned *block_sizes` in the `LibRaw::fuji_compressed_load_raw` is allocated with memory for one `unsigned` integer.    Then it is initialized from the stream `libraw_internal_data.internal_data.input->read(block_sizes, 1, sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);`    However if the stream position is close to the end and there is no enough data to fill all buffer, some bytes are left uninitialized.
