{"buggy_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [3.1.0] - 2022-09-30\n\n### Changed\n\n- Update TypeScript declaration for `PDFStreamForResponse` to accept any writable stream as an argument, not just `PDFRStreamForFile`\n\n### Added\n\n- Node 18\n- Electron 20.0, 20.1, 20.2\n- Prettier as dev dependency and basics\n- Electron 19.1\n\n## [3.0.0] - 2022-07-19\n\n### Fixed\n\n- Links in docs\n\n### Added\n\n- drawPath can now be used differently and this new way can be described with ts.\n  The old style is `drawPath(x1, y1, x2, y2..., options)` we now allow `drawPath([[x1, y1], [x2, y2]...], options)` too\n- scn and SCN can now be used differently and this new way can be described with ts.\n  The old style is `scn(c1, c2, c3, c4, ..., 'patternName')` we now allow `scn([[c1, c2, c3, c4, ...], 'patternName')` too\n\n### Changed\n\n- Bump dev dependency versions s\n\n### Breaking\n\n- Node < 11 and Electron < 11 removed\n- Renamed typo exported value from eTokenSeprator to eTokenSeparator\n\n## [2.6.0] - 2022-06-30\n\n### Changed\n\n- Fixes hard crash to exception when creating a stream with null object and calling createWriter with it\n- Fixes missing buffer information for recrypt typescript definition\n- Fixes missing options for append pdf pages\n- Fixes NPE when stream is not readable in write stream object (PDFDocumentHandler)\n\n## [2.5.0] - 2022-06-23\n\n### Added\n\n- Electron 17.2.0, 17.3, 17.4\n- Typescript definitions\n- Add test for recrypt with streams\n\n## [2.4.0] - 2022-06-08\n\n### Added\n\n- Electron 18.1, 18.2, 18.3\n- Electron 19.0\n\n### Changed\n\n- Update npm dist url to the new url for electron builds\n\n## [2.3.0] - 2022-05-04\n\n### Added\n\n- Builds for node and electron with arm64 on darwin (Apple M1)\n- Add electron 18\n\n## [2.2.0] - 2022-03-05\n\n### Changed\n\n- Update PDFWriter dependency to the newest available versoin\n\n### Added\n\n- Electron version: 17.0, 17.1\n- NodeJs 17.6.0\n\n## [2.1.0] - 2021-12-03\n\n### Added\n\n- Electron versions: 16.0, 15.3, 15.2, 14.2, 13.6, 13.3\n\n## [2.0.0] - 2021-10-22\n\n### Removed\n\n- Electron 2.0.7\n- Node 6.14.1 and 7.10.1\n\n### Added\n\n- Add Electron 13.3.0\n- Documentation (copy of the wiki)\n- Add Electron 13.2.3\n- Add Electron 13.5.0\n- Add Electron 14.0.1\n- Add Electron 14.1.0\n- Add Electron 15.0.0\n- Add Electron 15.1.2\n- Add Node 16.11.1\n\n### Fixed\n\n- Dependency to node-pre-gyp moved from deprecated to scoped package\n\n## [1.10.0] - 2021-07-12\n\n### Added\n\n- Add Electron 13.1\n- Disable NEON on arm builds\n\n## [1.9.0] - 2021-06-30\n\n### Fixed\n\n- Yarn v2 incompatibiliy\n- Build issues on mac OS big sur\n\n## [1.8.0] - 2021-05-28\n\n### Added\n\n- Add Electron 13.0\n- Add missing typescript declaration of the PDFWStreamForBuffer\n- Add Electron 11.4\n- Add electron 10.4\n\n## [1.7.0] - 2021-03-08\n\n### Added\n\n- More electron 11.x releases\n- Add electron 12.0.0\n- Add electron 10.2, 10.3\n- Add electron 9.4, 9.3\n\n## [1.6.0] - 2021-02-17\n\n### Fixed\n\n- Update the g++ compiler from 4.8 to 5.4 (default on xenial) for linux builds\n- Changed builds from travis and app veyor to github\n\n### Added\n\n- Electron 11\n- Added Node 15\n\n## [1.5.1] - 2020-10-10\n\n### Added\n\n- Added manual workflow to reduce release errors\n\n### Fixed\n\n- Huge package size as npm publish does not use .gitignore or .npmignore locally\n\n## [1.5.0] - 2020-10-10\n\n### Added\n\n- Electron 7.3, 8.3, 8.4, 8.5 and 9.3\n\n## [1.4.3] - 2020-10-09\n\n### Fixed\n\n- Return code fixed for builds on app veyor.\n- Winwdows builds successfully with electron 10.x\n- NPM version on app veyor fixed to build electron 2.x again\n\n### Added\n\n- Add electron 10.1.3\n\n## [1.4.2] - 2020-08-27\n\n### Added\n\n- Add electron 10.0\n\n## [1.4.1] - 2020-08-13\n\nThis is a special release no code has been changed.\nThe packaged module included (in version muhammara@1.4.0) a bundled dependency with a\ndebug output.\n\n### Fixed\n\n- Removed debug output from packaged dependency `node-pre-gyp`\n\n## [1.4.0] - 2020-08-10\n\n### Added\n\n- Add electron 9.2\n\n## [1.3.0] - 2020-08-06\n\n### Added\n\n- Add electron-9.1 pre built\n\n### Fixed\n\n- Add missing typescript declaration files to published packages\n\n## [1.2.0] - 2020-06-01\n\n### Fixed\n\n- Updated freetype to 2.10.0\n- Updated libpng dependency to 1.6.37\n- Updated libaesgm dependency\n- Update libjpeg dependency to 9d\n- Updated libtiff dependency to 3.9.7\n\n## [1.1.0] - 2020-05-27\n\n### Added\n\n- Added infos about being hummusjs drop in replacement\n- Added electron v9.0.0\n\n### Fixed\n\n- Updated dependencies and dev dependencies\n\n## [1.0.1] - 2020-05-08\n\n### Fixed\n\n- Fixed readme to include infos about muhammaraJS and hummus\n- Fixed node-pre-gyp binary download links\n\n### Removed\n\n- Unecessary dependency on aws-sdk\n\n## [1.0.0] - 2020-05-07\n\nBasically this is [HummusJS v1.0.108](https://github.com/galkahana/HummusJS/commit/772bd561f02433bf1a602135f53c7c17f8072450)\nwith the following changes.\n\n### Added\n\n- Store releases @github\n- Listen for tags instead of a commit message\n- Added node v13, v14, electron 6.1, 7.1, 7.2, 8.0, 8.1, 8.2\n\n### Fixed\n\n- Updated v8:GET / v8:SET calls which are incompatible with newer node version (>13)\n\n### Removed\n\n- Dropped support for electron 1.8\n\n- Initial release\n\n[unreleased]: https://github.com/julianhille/MuhammaraJS/compare/3.1.0...HEAD\n[3.1.0]: https://github.com/julianhille/MuhammaraJS/compare/3.0.0...3.1.0\n[3.0.0]: https://github.com/julianhille/MuhammaraJS/compare/2.6.0...3.0.0\n[2.6.0]: https://github.com/julianhille/MuhammaraJS/compare/2.5.0...2.6.0\n[2.5.0]: https://github.com/julianhille/MuhammaraJS/compare/2.4.0...2.5.0\n[2.4.0]: https://github.com/julianhille/MuhammaraJS/compare/2.3.0...2.4.0\n[2.3.0]: https://github.com/julianhille/MuhammaraJS/compare/2.2.0...2.3.0\n[2.2.0]: https://github.com/julianhille/MuhammaraJS/compare/2.1.0...2.2.0\n[2.1.0]: https://github.com/julianhille/MuhammaraJS/compare/2.0.0...2.1.0\n[2.0.0]: https://github.com/julianhille/MuhammaraJS/compare/1.10.0...2.0.0\n[1.10.0]: https://github.com/julianhille/MuhammaraJS/compare/1.9.0...1.10.0\n[1.9.0]: https://github.com/julianhille/MuhammaraJS/compare/1.8.0...1.9.0\n[1.8.0]: https://github.com/julianhille/MuhammaraJS/compare/1.7.0...1.8.0\n[1.7.0]: https://github.com/julianhille/MuhammaraJS/compare/1.6.0...1.7.0\n[1.6.0]: https://github.com/julianhille/MuhammaraJS/compare/1.5.1...1.6.0\n[1.5.1]: https://github.com/julianhille/MuhammaraJS/compare/1.5.0...1.5.1\n[1.5.0]: https://github.com/julianhille/MuhammaraJS/compare/1.4.3...1.5.0\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.2]: https://github.com/julianhille/MuhammaraJS/compare/1.4.1...1.4.2\n[1.4.1]: https://github.com/julianhille/MuhammaraJS/compare/1.4.0...1.4.1\n[1.4.0]: https://github.com/julianhille/MuhammaraJS/compare/1.3.0...1.4.0\n[1.3.0]: https://github.com/julianhille/MuhammaraJS/compare/1.2.0...1.3.0\n[1.2.0]: https://github.com/julianhille/MuhammaraJS/compare/1.1.0...1.2.0\n[1.1.0]: https://github.com/julianhille/MuhammaraJS/compare/1.0.1...1.1.0\n[1.0.1]: https://github.com/julianhille/MuhammaraJS/compare/1.0.0...1.0.1\n[1.0.0]: https://github.com/julianhille/MuhammaraJS/tree/1.0.0\n", "/*\n   Source File : PDFParser.cpp\n\n\n   Copyright 2011 Gal Kahana PDFWriter\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n\n*/\n#include \"PDFParser.h\"\n#include \"IByteReaderWithPosition.h\"\n#include \"PDFParserTokenizer.h\"\n#include \"Trace.h\"\n#include \"PDFInteger.h\"\n#include \"PDFObject.h\"\n#include \"PDFSymbol.h\"\n#include \"BoxingBase.h\"\n#include \"PDFDictionary.h\"\n#include \"BoxingBase.h\"\n#include \"PDFIndirectObjectReference.h\"\n#include \"PDFName.h\"\n#include \"PDFArray.h\"\n#include \"RefCountPtr.h\"\n#include \"PDFObjectCast.h\"\n#include \"PDFStreamInput.h\"\n#include \"InputLimitedStream.h\"\n#include \"InputFlateDecodeStream.h\"\n#include \"InputLZWDecodeStream.h\"\n#include \"InputStreamSkipperStream.h\"\n#include \"InputPredictorPNGOptimumStream.h\"\n#include \"InputPredictorTIFFSubStream.h\"\n#include \"InputAscii85DecodeStream.h\"\n#include \"InputAsciiHexDecodeStream.h\"\n#include \"IPDFParserExtender.h\"\n#include \"InputDCTDecodeStream.h\"\n#include \"ArrayOfInputStreamsStream.h\"\n\n#include  <algorithm>\nusing namespace PDFHummus;\n\nPDFParser::PDFParser(void)\n{\n\tmStream = NULL;\n\tmTrailer = NULL;\n\tmXrefTable = NULL;\n\tmPagesObjectIDs = NULL;\n\tmParserExtender = NULL;\n    mAllowExtendingSegments = true; // Gal 19.9.2013: here's some policy changer. basically i'm supposed to ignore all segments that declare objects past the trailer\n                                    // declared size. but i would like to allow files that do extend. as this is incompatible with the specs, i'll make\n                                    // this boolean dendent. i will sometimes make it public so ppl can actually modify this policy. for now, it's internal\n\tmObjectParser.SetDecryptionHelper(&mDecryptionHelper);\n}\n\nPDFParser::~PDFParser(void)\n{\n\tResetParser();\n}\n\nvoid PDFParser::ResetParser()\n{\n\tmTrailer = NULL;\n\tdelete[] mXrefTable;\n\tmXrefTable = NULL;\n\tdelete[] mPagesObjectIDs;\n\tmPagesObjectIDs = NULL;\n\tmStream = NULL;\n\tmCurrentPositionProvider.Assign(NULL);\n\n\tObjectIDTypeToObjectStreamHeaderEntryMap::iterator it = mObjectStreamsCache.begin();\n\tfor(; it != mObjectStreamsCache.end();++it)\n\t\tdelete[] it->second;\n\tmObjectStreamsCache.clear();\n\tmDecryptionHelper.Reset();\n\n}\n\nEStatusCode PDFParser::StartPDFParsing(IByteReaderWithPosition* inSourceStream, const PDFParsingOptions& inOptions)\n{\n\tEStatusCode status;\n\n\tResetParser();\n\n\tmStream = inSourceStream;\n\tmCurrentPositionProvider.Assign(mStream);\n\tmObjectParser.SetReadStream(inSourceStream,&mCurrentPositionProvider);\n\n\tdo\n\t{\n\t\tstatus = ParseHeaderLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\t// initialize reading from end\n\t\tmLastReadPositionFromEnd = 0;\n\t\tmEncounteredFileStart = false;\n\t\tmLastAvailableIndex = mCurrentBufferIndex = mLinesBuffer;\n\n\t\tstatus = ParseEOFLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseLastXrefPosition();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseFileDirectory(); // that would be the xref and trailer\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = SetupDecryptionHelper(inOptions.Password);\n\t\tif (status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif (IsEncrypted() && !IsEncryptionSupported())\n\t\t{\n\t\t\t// not parsing pages for encrypted docs that the lib cant decrypt.\n\t\t\t// not commiting..and there's a practical reason.\n\t\t\t// lower level objects will be in object streams (for those PDFs that have them)\n\t\t\t// and the may not be accessed\n\t\t\tmPagesCount = 0;\n\t\t\tmPagesObjectIDs = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = ParsePagesObjectIDs();\n\t\t\tif (status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n\t}while(false);\n\n\treturn status;\n}\n\nPDFObjectParser& PDFParser::GetObjectParser()\n{\n\treturn mObjectParser;\n}\n\nDecryptionHelper& PDFParser::GetDecryptionHelper() {\n\treturn mDecryptionHelper;\n}\n\nstatic const std::string scPDFMagic = \"%PDF-\";\nEStatusCode PDFParser::ParseHeaderLine()\n{\n\tPDFParserTokenizer tokenizer;\n\n\ttokenizer.SetReadStream(mStream);\n\tBoolAndString tokenizerResult = tokenizer.GetNextToken();\n\n\tif(!tokenizerResult.first)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ParseHeaderLine, no tokens in PDF input. in other words - it's empty.\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tif(tokenizerResult.second.compare(0,scPDFMagic.size(),scPDFMagic) != 0)\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParseHeaderLine, file does not begin as a PDF file. a PDF file should start with \\\"%%PDF-\\\". file header = %s\",tokenizerResult.second.substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tmPDFLevel = Double(tokenizerResult.second.substr(scPDFMagic.size()));\n\treturn PDFHummus::eSuccess;\n}\n\nstatic const std::string scEOF = \"%%EOF\";\nEStatusCode PDFParser::ParseEOFLine()\n{\n\t/* go back till you hit token. this should be the EOF. go back till line start and get the token...if it's not EOF, fail.\n\t   since EOF is a comment, then if there's anything else in that line it will either be before %%EOF, which means %%EOF won't be taken, or after -\n\t   in which case it'd be part of the comment. in any case - if it's not exactly EOF, there will be a failure. but i am allowing\n\t   extra empty lines after %%EOF\n\t*/\n\n\tbool foundEOF = false,canRead = true;\n\twhile (!foundEOF && canRead) {\n\t\tif (GoBackTillToken())\n\t\t{\n\t\t\tGoBackTillLineStart();\n\t\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\t\tPDFParserTokenizer aTokenizer;\n\t\t\taTokenizer.SetReadStream(mStream);\n\t\t\tBoolAndString token = aTokenizer.GetNextToken();\n\n\t\t\tif (token.first && (token.second.substr(0, scEOF.length()) == scEOF))\n\t\t\t{\n\t\t\t\tfoundEOF = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseEOFLine, Couldn't find tokens in file\");\n\t\t\tcanRead = false;\n\t\t}\n\t}\n\n\treturn foundEOF ? PDFHummus::eSuccess : PDFHummus::eFailure;\n}\n\nLongBufferSizeType PDFParser::GetCurrentPositionFromEnd()\n{\n\treturn mLastReadPositionFromEnd-(mCurrentBufferIndex-mLinesBuffer);\n}\n\nbool PDFParser::GoBackTillToken()\n{\n\tByte buffer;\n\tbool foundToken = false;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(!IsPDFWhiteSpace(buffer))\n\t\t{\n\t\t\tfoundToken = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn foundToken;\n}\n\nbool PDFParser::GoBackTillNonToken()\n{\n\tByte buffer;\n\tbool foundNonToken = false;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(IsPDFWhiteSpace(buffer))\n\t\t{\n\t\t\tfoundNonToken = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn foundNonToken;\n}\n\nstatic const Byte scWhiteSpaces[] = {0,0x9,0xA,0xC,0xD,0x20};\nbool PDFParser::IsPDFWhiteSpace(Byte inCharacter)\n{\n\tbool isWhiteSpace = false;\n\tfor(int i=0; i < 6 && !isWhiteSpace; ++i)\n\t\tisWhiteSpace =  (scWhiteSpaces[i] == inCharacter);\n\treturn isWhiteSpace;\n}\n\n\nstatic const char scCR = '\\r';\nstatic const char scLN = '\\n';\nvoid PDFParser::GoBackTillLineStart()\n{\n\tByte buffer;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(scLN == buffer || scCR == buffer)\n\t\t\tbreak;\n\t}\n}\n\nbool PDFParser::ReadBack(Byte& outValue)\n{\n\tif(IsBeginOfFile())\n\t\treturn false;\n\n\tif(mCurrentBufferIndex > mLinesBuffer)\n\t{\n\t\t--mCurrentBufferIndex;\n\t\toutValue = *mCurrentBufferIndex;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tReadNextBufferFromEnd(); // must be able to read...but could be 0 bytes\n\t\tif(mCurrentBufferIndex > mLinesBuffer)\n\t\t{\n\t\t\t--mCurrentBufferIndex;\n\t\t\toutValue = *mCurrentBufferIndex;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\nbool PDFParser::ReadNextBufferFromEnd()\n{\n\tif(mEncounteredFileStart)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tmStream->SetPositionFromEnd(mLastReadPositionFromEnd); // last known position that worked.\n\t\tLongFilePositionType positionBefore = mStream->GetCurrentPosition();\n\t\tmStream->SetPositionFromEnd(mLastReadPositionFromEnd + LINE_BUFFER_SIZE); // try earlier one\n\t\tLongFilePositionType positionAfter = mStream->GetCurrentPosition();\n\t\tLongBufferSizeType readAmount = positionBefore - positionAfter; // check if got to start by testing position\n\t\tif(readAmount != 0)\n\t\t\treadAmount = mStream->Read(mLinesBuffer,readAmount);\n\t\tmEncounteredFileStart = readAmount < LINE_BUFFER_SIZE;\n\t\tif(0 == readAmount)\n\t\t\treturn false;\n\t\tmLastAvailableIndex = mLinesBuffer + readAmount;\n\t\tmCurrentBufferIndex = mLastAvailableIndex;\n\t\tmLastReadPositionFromEnd+= readAmount;\n\t\treturn true;\n\t}\n}\n\nbool PDFParser::IsBeginOfFile()\n{\n\treturn mEncounteredFileStart && (mCurrentBufferIndex == mLinesBuffer);\n}\n\nstatic const std::string scStartxref = \"startxref\";\nEStatusCode PDFParser::ParseLastXrefPosition()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\t// next two lines should be the xref position and then \"startxref\"\n\n\tdo\n\t{\n\n\t\t// find and read xref position\n\t\tif(!GoBackTillToken())\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find xref position token\");\n\t\t\tbreak;\n\t\t}\n\n\t\tGoBackTillLineStart();\n\n\t\t// now go forward, and here i'm guessing a bit, till you get to either and integer, or the startxref keyword\n\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\tmObjectParser.ResetReadState();\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectInteger)\n\t\t{\n\t\t\tmLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();\n\n\t\t\t// find and read startxref keyword\n\t\t\tif(!GoBackTillToken())\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tGoBackTillLineStart();\n\t\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\t\tmObjectParser.ResetReadState();\n\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\n\t\t\tif(!startxRef || startxRef->GetValue() != scStartxref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse // this means that the line is not only integer, a bit more complicated path, look for startxref and then the next would be the number\n\t\t{\n\t\t\tbool foundStartXref = (anObject->GetType() == PDFObject::ePDFObjectSymbol) && (((PDFSymbol*)anObject.GetPtr())->GetValue() == scStartxref);\n\n\t\t\twhile(!foundStartXref && mStream->NotEnded())\n\t\t\t{\n\t\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\t\t\t\tfoundStartXref = startxRef.GetPtr() && (startxRef->GetValue() == scStartxref);\n\t\t\t}\n\n\t\t\tif(!foundStartXref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, could not find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefPosition(mObjectParser.ParseNewObject());\n\t\t\tif(!xrefPosition)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmLastXrefPosition = xrefPosition->GetValue();\n\t\t}\n\n\t}while(false);\n\n\treturn status;\n\n}\n\nstatic const std::string scTrailer = \"trailer\";\nEStatusCode PDFParser::ParseTrailerDictionary(PDFDictionary** outTrailer)\n{\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\tbool foundTrailer = false;\n\n\tdo\n\t{\n\t\tPDFParserTokenizer aTokenizer;\n\t\taTokenizer.SetReadStream(mStream);\n\n\t\tdo\n\t\t{\n\t\t\tBoolAndString token = aTokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t\tbreak;\n\t\t\tfoundTrailer = (scTrailer == token.second);\n\t\t}while(!foundTrailer);\n\n\n\t\tif(!foundTrailer)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseTrailerDictionary, trailer not found...\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// k. now that all is well, just parse the damn dictionary, which is actually...the easiest part.\n\t\tmObjectParser.ResetReadState(aTokenizer);\n\t\tPDFObjectCastPtr<PDFDictionary> trailerDictionary(mObjectParser.ParseNewObject());\n\t\tif(!trailerDictionary)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseTrailerDictionary, failure to parse trailer dictionary\");\n\t\t\tbreak;\n\t\t}\n\n\t\ttrailerDictionary->AddRef();\n\t\t*outTrailer = trailerDictionary.GetPtr();\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::BuildXrefTableFromTable()\n{\n\tEStatusCode status;\n\n\tdo\n\t{\n\t\tstatus = DetermineXrefSize();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = InitializeXref();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tbool hasPrev = mTrailer->Exists(\"Prev\");\n\t\tif(hasPrev)\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(mTrailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParseXrefFromXrefTable(mXrefTable,mXrefSize,mLastXrefPosition,!hasPrev, &extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n        // Table may have been extended, in which case replace the pointer and current size\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\n\t\t// For hybrids, check also XRefStm entry\n\t\tPDFObjectCastPtr<PDFInteger> xrefStmReference(mTrailer->QueryDirectObject(\"XRefStm\"));\n\t\tif(!xrefStmReference)\n\t\t\tbreak;\n\t\t// if exists, merge update xref\n\t\tstatus = ParseXrefFromXrefStream(mXrefTable,mXrefSize,xrefStmReference->GetValue(),&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failure to parse xref in hybrid mode\");\n\t\t\tbreak;\n\t\t}\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::DetermineXrefSize()\n{\n\tPDFObjectCastPtr<PDFInteger> aSize(mTrailer->QueryDirectObject(\"Size\"));\n\n\tif(!aSize)\n\t{\n\t\treturn PDFHummus::eFailure;\n\t}\n\telse\n\t{\n\t\tmXrefSize = (ObjectIDType)aSize->GetValue();\n\t\treturn PDFHummus::eSuccess;\n\t}\n}\n\nEStatusCode PDFParser::InitializeXref()\n{\n\tmXrefTable = new XrefEntryInput[mXrefSize];\n\treturn PDFHummus::eSuccess;\n}\n\ntypedef BoxingBaseWithRW<ObjectIDType> ObjectIDTypeBox;\ntypedef BoxingBaseWithRW<unsigned long> ULong;\ntypedef BoxingBaseWithRW<LongFilePositionType> LongFilePositionTypeBox;\n\nstatic const std::string scXref = \"xref\";\nEStatusCode PDFParser::ParseXrefFromXrefTable(XrefEntryInput* inXrefTable,\n                                              ObjectIDType inXrefSize,\n                                              LongFilePositionType inXrefPosition,\n\t\t\t\t\t\t\t\t\t\t\t  bool inIsFirstXref,\n                                              XrefEntryInput** outExtendedTable,\n                                              ObjectIDType* outExtendedTableSize)\n{\n\t// K. cross ref starts at  xref position\n\t// and ends with trailer (or when exahausted the number of objects...whichever first)\n\t// i'm gonna tokanize them, for easier reading\n\tPDFParserTokenizer tokenizer;\n\tBoolAndString token;\n\tEStatusCode status = PDFHummus::eSuccess;\n\tObjectIDType firstNonSectionObject;\n\tByte entry[20];\n\n    *outExtendedTable = NULL;\n\n\ttokenizer.SetReadStream(mStream);\n\tMovePositionInStream(inXrefPosition);\n\n\t// Note that at times, the xref is being read \"on empty\". meaning - entries will be read but they will not affect the actual xref.\n\t// This is done because final xref might be smaller than the prev xrefs, and i'm only interested in objects that are in the final xref.\n\t// That said - i still want to be in the position of the trailer after this function is being executed.\n\n\tdo\n\t{\n\t\t// first token must be \"xref\", so just verify\n\t\ttoken = tokenizer.GetNextToken();\n\t\tif(!token.first || token.second != scXref)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXref, error in parsing xref, expected to find \\\"xref\\\" keyword, found = %s\",token.second.substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tObjectIDType currentObject = 0;\n\n\t\twhile(PDFHummus::eSuccess == status)\n\t\t{\n\t\t\ttoken = tokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXref, failed to read tokens, while reading xref\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// token may be either start of section or \"trailer\"\n\t\t\tif(scTrailer == token.second)\n\t\t\t\tbreak;\n\n\t\t\t// parse segment start\n\t\t\tObjectIDType segmentStart = ObjectIDTypeBox(token.second);\n\t\t\t\n\t\t\t// for first xref (one with no Prev), first object must be 0. some files incorrectly start at 1.\n\t\t\t// this should take care of this, adding extra measure of safety when reading the first xref\n\t\t\tif (currentObject != 0 || !inIsFirstXref)\n\t\t\t\tcurrentObject = segmentStart;\n\t\t\t\n\t\t\ttoken = tokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXref, unable to read section size, while reading xref\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// parse segment size\n\t\t\tif(ObjectIDTypeBox(token.second) == 0)\n\t\t\t\tcontinue; // probably will never happen\n\t\t\tfirstNonSectionObject = currentObject + ObjectIDTypeBox(token.second);\n\n            // if the segment declared objects above the xref size, consult policy on what to do\n            if(firstNonSectionObject > inXrefSize && mAllowExtendingSegments)\n            {\n                inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,firstNonSectionObject);\n                inXrefSize = firstNonSectionObject;\n                if(*outExtendedTable)\n                    delete[] *outExtendedTable;\n                *outExtendedTable = inXrefTable;\n                *outExtendedTableSize = firstNonSectionObject;\n            }\n\n\t\t\t// now parse the section.\n\t\t\twhile(currentObject < firstNonSectionObject)\n\t\t\t{\n\t\t\t\tstatus = ReadNextXrefEntry(entry);\n\t\t\t\tif (status != eSuccess)\n\t\t\t\t\tbreak;\n\t\t\t\tif(currentObject < inXrefSize)\n\t\t\t\t{\n\t\t\t\t\tinXrefTable[currentObject].mObjectPosition = LongFilePositionTypeBox(std::string((const char*)entry, 10));\n\t\t\t\t\tinXrefTable[currentObject].mRivision = ULong(std::string((const char*)(entry + 11), 5));\n\t\t\t\t\tinXrefTable[currentObject].mType = entry[17] == 'n' ? eXrefEntryExisting:eXrefEntryDelete;\n\t\t\t\t}\n\t\t\t\t++currentObject;\n\t\t\t}\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t}while(false);\n\tmObjectParser.ResetReadState(tokenizer); // reset with tokenizer in case got extra token.s\n\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadNextXrefEntry(Byte inBuffer[20]) {\n\tEStatusCode status = eSuccess;\n\n\tdo\n\t{\n\t\tif (mStream->Read(inBuffer, 1) != 1)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ReadNextXrefEntry, failed to read xref entry\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t} while (IsPDFWhiteSpace(inBuffer[0]));\n\tif (status != eSuccess)\n\t\treturn status;\n\n\t// now read extra 19\n\tif (mStream->Read(inBuffer + 1, 19) != 19)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ReadNextXrefEntry, failed to read xref entry\");\n\t\tstatus = PDFHummus::eFailure;\n\t}\n\t// set position if the EOL is 1 char instead of 2 (some documents may not follow the standard!)\n\tif ((inBuffer[19] != scLN && inBuffer[19] != scCR) && (inBuffer[18] == scLN || inBuffer[18] == scCR))\n\t{\n\t\tmStream->SetPosition(mStream->GetCurrentPosition() - 1);\n\t}\n\treturn status;\n}\n\nXrefEntryInput* PDFParser::ExtendXrefTableToSize(XrefEntryInput* inXrefTable,ObjectIDType inOldSize,ObjectIDType inNewSize)\n{\n    XrefEntryInput* newTable = new XrefEntryInput[inNewSize];\n\n\tfor(ObjectIDType i = 0; i < inOldSize; ++i)\n        newTable[i] =\tinXrefTable[i];\n    return newTable;\n}\n\nPDFDictionary* PDFParser::GetTrailer()\n{\n\treturn mTrailer.GetPtr();\n}\n\ndouble PDFParser::GetPDFLevel()\n{\n\treturn mPDFLevel;\n}\n\nPDFObject* PDFParser::ParseNewObject(ObjectIDType inObjectId)\n{\n\tif(inObjectId >= mXrefSize)\n\t{\n\t\treturn NULL;\n\t}\n\telse if(eXrefEntryExisting == mXrefTable[inObjectId].mType)\n\t{\n\t\treturn ParseExistingInDirectObject(inObjectId);\n\t}\n\telse if(eXrefEntryStreamObject == mXrefTable[inObjectId].mType)\n\t{\n\t\treturn ParseExistingInDirectStreamObject(inObjectId);\n\t}\n\telse\n\t\treturn NULL;\n}\n\nObjectIDType PDFParser::GetObjectsCount()\n{\n\treturn mXrefSize;\n}\n\nstatic const std::string scObj = \"obj\";\nPDFObject* PDFParser::ParseExistingInDirectObject(ObjectIDType inObjectID)\n{\n\tPDFObject* readObject = NULL;\n\n\tMovePositionInStream(mXrefTable[inObjectID].mObjectPosition);\n\n\tdo\n\t{\n\t\t// should get us to the ObjectNumber ObjectVersion obj section\n\t\t// verify that it's good and if so continue to parse the object itself\n\n\t\t// verify object ID\n\t\tPDFObjectCastPtr<PDFInteger> idObject(mObjectParser.ParseNewObject());\n\n\t\tif(!idObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, ID\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif((ObjectIDType)idObject->GetValue() != inObjectID)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, exepected ID = %ld, found %ld\",\n\t\t\t\tinObjectID,idObject->GetValue());\n\t\t\tbreak;\n\t\t}\n\n\t\t// verify object Version\n\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, Version\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif((unsigned long)versionObject->GetValue() != mXrefTable[inObjectID].mRivision)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, exepected version = %ld, found %ld\",\n\t\t\t\tmXrefTable[inObjectID].mRivision,versionObject->GetValue());\n\t\t\tbreak;\n\t\t}\n\n\t\t// now the obj keyword\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, obj keyword\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectStart(inObjectID, versionObject->GetValue());\n\t\treadObject = mObjectParser.ParseNewObject();\n\t\tNotifyIndirectObjectEnd(readObject);\n\t}while(false);\n\n\treturn readObject;\n}\n\nEStatusCode PDFParser::SetupDecryptionHelper(const std::string& inPassword) {\n\treturn mDecryptionHelper.Setup(this,inPassword);\n}\n\nEStatusCode PDFParser::ParsePagesObjectIDs()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\t// m.k plan is to look for the catalog, then find the pages, then initialize the array to the count at the root, and then just recursively loop\n\t// the pages by order of pages and fill up the IDs. easy.\n\n\tdo\n\t{\n\t\t// get catalogue, verify indirect reference\n\t\tPDFObjectCastPtr<PDFIndirectObjectReference> catalogReference(mTrailer->QueryDirectObject(\"Root\"));\n\t\tif(!catalogReference)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read catalog reference in trailer\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFDictionary> catalog(ParseNewObject(catalogReference->mObjectID));\n\t\tif(!catalog)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read catalog\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// get pages, verify indirect reference\n\t\tPDFObjectCastPtr<PDFIndirectObjectReference> pagesReference(catalog->QueryDirectObject(\"Pages\"));\n\t\tif(!pagesReference)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages reference in catalog\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFDictionary> pages(ParseNewObject(pagesReference->mObjectID));\n\t\tif(!pages)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> totalPagesCount(QueryDictionaryObject(pages.GetPtr(),\"Count\"));\n\t\tif(!totalPagesCount)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages count\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tmPagesCount = (unsigned long)totalPagesCount->GetValue();\n\t\tmPagesObjectIDs = new ObjectIDType[mPagesCount];\n\n\t\t// now iterate through pages objects, and fill up the IDs [don't really need the object ID for the root pages tree...but whatever\n\t\tstatus = ParsePagesIDs(pages.GetPtr(),pagesReference->mObjectID);\n\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::ParsePagesIDs(PDFDictionary* inPageNode,ObjectIDType inNodeObjectID)\n{\n\tunsigned long currentPageIndex = 0;\n\n\treturn ParsePagesIDs(inPageNode,inNodeObjectID,currentPageIndex);\n}\n\nstatic const std::string scPage = \"Page\";\nstatic const std::string scPages = \"Pages\";\nEStatusCode PDFParser::ParsePagesIDs(PDFDictionary* inPageNode,ObjectIDType inNodeObjectID,unsigned long& ioCurrentPageIndex)\n{\n\t// recursion.\n\t// if this is a page, write it's node object ID in the current page index and +1\n\t// if this is a pagetree, loop it's kids, for each parsing the kid, running the recursion on it, and deleting\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\t\tPDFObjectCastPtr<PDFName> objectType(inPageNode->QueryDirectObject(\"Type\"));\n\t\tif(!objectType)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, can't read object type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(scPage == objectType->GetValue())\n\t\t{\n\t\t\t// a Page\n\t\t\tif(ioCurrentPageIndex >= mPagesCount)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, there are more pages than the page count specifies. fail.\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmPagesObjectIDs[ioCurrentPageIndex] = inNodeObjectID;\n\t\t\t++ioCurrentPageIndex;\n\t\t}\n\t\telse if(scPages == objectType->GetValue())\n\t\t{\n\t\t\t// a Page tree node\n\t\t\tPDFObject* pKids= inPageNode->QueryDirectObject(\"Kids\");\n\t\t\tif (pKids && pKids->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t\t\t\tpKids= ParseNewObject(((PDFIndirectObjectReference*)pKids)->mObjectID);\n\t\t\tPDFObjectCastPtr<PDFArray> kidsObject(pKids);\n\t\t\tif(!kidsObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, unable to find page kids array\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSingleValueContainerIterator<PDFObjectVector> it = kidsObject->GetIterator();\n\n\t\t\twhile(it.MoveNext() && PDFHummus::eSuccess == status)\n\t\t\t{\n\t\t\t\tif (it.GetItem()->GetType() == PDFObject::ePDFObjectNull) {\n\t\t\t\t\t// null pointer. mark as empty page\n\t\t\t\t\tmPagesObjectIDs[ioCurrentPageIndex] = 0;\n\t\t\t\t\t++ioCurrentPageIndex;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(it.GetItem()->GetType() != PDFObject::ePDFObjectIndirectObjectReference)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG1(\"PDFParser::ParsePagesIDs, unexpected type for a Kids array object, type = %s\",PDFObject::scPDFObjectTypeLabel(it.GetItem()->GetType()));\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPDFObjectCastPtr<PDFDictionary> pageNodeObject(ParseNewObject(((PDFIndirectObjectReference*)it.GetItem())->mObjectID));\n\t\t\t\tif(!pageNodeObject)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, unable to parse page node object from kids reference\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstatus = ParsePagesIDs(pageNodeObject.GetPtr(),((PDFIndirectObjectReference*)it.GetItem())->mObjectID,ioCurrentPageIndex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParsePagesIDs, unexpected object type. should be either Page or Pages, found %s\",objectType->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t}while(false);\n\n\treturn status;\n}\n\nunsigned long  PDFParser::GetPagesCount()\n{\n\treturn mPagesCount;\n}\n\nObjectIDType PDFParser::GetPageObjectID(unsigned long inPageIndex)\n{\n\tif(mPagesCount <= inPageIndex)\n\t\treturn 0;\n\n\treturn mPagesObjectIDs[inPageIndex];\n}\n\n\nPDFDictionary* PDFParser::ParsePage(unsigned long inPageIndex)\n{\n\tif(mPagesCount <= inPageIndex)\n\t\treturn NULL;\n\n\tif (mPagesObjectIDs[inPageIndex] == 0) {\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, page marked as null at index %ld\", inPageIndex);\n\t\treturn NULL;\n\t}\n\n\tPDFObjectCastPtr<PDFDictionary> pageObject(ParseNewObject(mPagesObjectIDs[inPageIndex]));\n\n\tif(!pageObject)\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, couldn't find page object for index %ld\",inPageIndex);\n\t\treturn NULL;\n\t}\n\n\tPDFObjectCastPtr<PDFName> objectType(pageObject->QueryDirectObject(\"Type\"));\n\n\tif(scPage == objectType->GetValue())\n\t{\n\t\tpageObject->AddRef();\n\t\treturn pageObject.GetPtr();\n\t}\n\telse\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, page object listed in page array for %ld is actually not a page\",inPageIndex);\n\t\treturn NULL;\n\t}\n}\n\nPDFObject* PDFParser::QueryDictionaryObject(PDFDictionary* inDictionary,const std::string& inName)\n{\n\tRefCountPtr<PDFObject> anObject(inDictionary->QueryDirectObject(inName));\n\n\tif(anObject.GetPtr() == NULL)\n\t\treturn NULL;\n\n\tif(anObject->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t{\n\t\tPDFObject* theActualObject = ParseNewObject(((PDFIndirectObjectReference*)anObject.GetPtr())->mObjectID);\n\t\treturn theActualObject;\n\t}\n\telse\n\t{\n\t\tanObject->AddRef(); // adding ref to increase owners\n\t\treturn anObject.GetPtr();\n\t}\n}\n\nPDFObject* PDFParser::QueryArrayObject(PDFArray* inArray,unsigned long inIndex)\n{\n\tRefCountPtr<PDFObject> anObject(inArray->QueryObject(inIndex));\n\n\tif(anObject.GetPtr() == NULL)\n\t\treturn NULL;\n\n\tif(anObject->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t{\n\t\tPDFObject* theActualObject = ParseNewObject(((PDFIndirectObjectReference*)anObject.GetPtr())->mObjectID);\n\t\treturn theActualObject;\n\t}\n\telse\n\t{\n\t\tanObject->AddRef(); // adding ref to increase owners\n\t\treturn anObject.GetPtr();\n\t}\n\n}\n\nEStatusCode PDFParser::ParsePreviousXrefs(PDFDictionary* inTrailer)\n{\n\tPDFObjectCastPtr<PDFInteger> previousPosition(inTrailer->QueryDirectObject(\"Prev\"));\n\tif(!previousPosition)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ParsePreviousXrefs, unexpected, prev is not integer\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tEStatusCode status;\n\n\tXrefEntryInput* aTable = new XrefEntryInput[mXrefSize];\n\tdo\n\t{\n\t\tPDFDictionary* trailerP = NULL;\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParsePreviousFileDirectory(previousPosition->GetValue(),aTable,mXrefSize,&trailerP,&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tRefCountPtr<PDFDictionary> trailer(trailerP);\n\n\t\tif(trailer->Exists(\"Prev\"))\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(trailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n\n        // Table may have been extended, in which case replace the pointer and current size\n        ObjectIDType newTableSize;\n        if(extendedTable)\n        {\n            newTableSize = extendedTableSize;\n            delete[] aTable;\n            aTable = extendedTable;\n        }\n        else\n            newTableSize = mXrefSize;\n        MergeXrefWithMainXref(aTable,newTableSize);\n\t}\n\twhile(false);\n\n\tdelete[] aTable;\n\treturn status;\n}\n\nEStatusCode PDFParser::ParsePreviousFileDirectory(LongFilePositionType inXrefPosition,\n\t\t\t\t\t\t\t\t\t  XrefEntryInput* inXrefTable,\n\t\t\t\t\t\t\t\t\t  ObjectIDType inXrefSize,\n\t\t\t\t\t\t\t\t\t  PDFDictionary** outTrailer,\n                                      XrefEntryInput** outExtendedTable,\n                                      ObjectIDType* outExtendedTableSize)\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tMovePositionInStream(inXrefPosition);\n\n\tdo\n\t{\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectSymbol && ((PDFSymbol*)anObject.GetPtr())->GetValue() == scXref)\n\t\t{\n\t\t\t// xref table case\n\n\t\t\t// Parsing trailer. this is not really necessary at this point, but for faulty PDFs which first xref may incorrectly skip 0 entry.\n\t\t\t// A simple correction is possible, but it is required to know whether the to-be-parsed xref is the first one, or not.\n\t\t\tPDFDictionary* trailerDictionary = NULL;\n\t\t\tstatus = ParseTrailerDictionary(&trailerDictionary);\n\t\t\tif (status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\n\t\t\tbool hasPrev = trailerDictionary->Exists(\"Prev\");\n\n\t\t\tstatus = ParseXrefFromXrefTable(inXrefTable,inXrefSize,inXrefPosition,!hasPrev,outExtendedTable,outExtendedTableSize);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::ParseDirectory, failed to parse xref table in %ld\",inXrefPosition);\n\t\t\t\tbreak;\n\t\t\t}\n\n            if(*outExtendedTable)\n            {\n                inXrefTable = *outExtendedTable;\n                inXrefSize = *outExtendedTableSize;\n            }\n\n\n\t\t\t// For hybrids, check also XRefStm entry\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefStmReference(trailerDictionary->QueryDirectObject(\"XRefStm\"));\n\t\t\tif(xrefStmReference.GetPtr())\n\t\t\t{\n\t\t\t\t// if exists, merge update xref\n\t\t\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStmReference->GetValue(),outExtendedTable,outExtendedTableSize);\n\t\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failure to parse xref in hybrid mode\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*outTrailer = trailerDictionary;\n\t\t}\n\t\telse if(anObject->GetType() == PDFObject::ePDFObjectInteger && ((PDFInteger*)anObject.GetPtr())->GetValue() > 0)\n\t\t{\n\t\t\t// Xref stream case. make some validations, grab the xref stream object details, and parse it\n\n\t\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\t\tif(!versionObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failed to read xref object declaration, Version\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\t\tif(!objKeyword)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failed to read xref object declaration, obj keyword\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(objKeyword->GetValue() != scObj)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::ParseDirectory, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNotifyIndirectObjectStart(((PDFInteger*)anObject.GetPtr())->GetValue(), versionObject->GetValue());\n\n\t\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\t\tif(!xrefStream)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failure to parse xref stream\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\t\t*outTrailer = xrefStream->QueryStreamDictionary();\n\n\t\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStream.GetPtr(),outExtendedTable,outExtendedTableSize);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory,Unexpected object at xref start\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t}\n\t}while(false);\n\treturn status;\n}\n\nvoid PDFParser::MergeXrefWithMainXref(XrefEntryInput* inTableToMerge,ObjectIDType inMergedTableSize)\n{\n    if(inMergedTableSize > mXrefSize)\n    {\n        XrefEntryInput* newTable = ExtendXrefTableToSize(mXrefTable, mXrefSize, inMergedTableSize);\n        mXrefSize = inMergedTableSize;\n        delete[] mXrefTable;\n        mXrefTable = newTable;\n    }\n\n\tfor(ObjectIDType i = 0; i < mXrefSize; ++i)\n\t{\n\t\tif(inTableToMerge[i].mType != eXrefEntryUndefined)\n\t\t\tmXrefTable[i] =\tinTableToMerge[i];\n\t}\n}\n\n\nEStatusCode PDFParser::ParseFileDirectory()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\n\tMovePositionInStream(mLastXrefPosition);\n\n\tdo\n\t{\n\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectSymbol && ((PDFSymbol*)anObject.GetPtr())->GetValue() == scXref)\n\t\t{\n\t\t\t// this would be a normal xref case\n\t\t\t// jump lines till you get to a line where the token is \"trailer\". then parse.\n\t\t\tPDFDictionary* trailerP = NULL;\n\t\t\tstatus = ParseTrailerDictionary(&trailerP);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t\tRefCountPtr<PDFDictionary> trailer(trailerP); // this should take care of the internally added ref...minor technicality\n\t\t\tmTrailer = trailer;\n\n\t\t\tstatus = BuildXrefTableFromTable();\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if(anObject->GetType() == PDFObject::ePDFObjectInteger && ((PDFInteger*)anObject.GetPtr())->GetValue() > 0)\n\t\t{\n\t\t\t// Xref stream case\n\t\t\tstatus = BuildXrefTableAndTrailerFromXrefStream(((PDFInteger*)anObject.GetPtr())->GetValue());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseFileDirectory,Unexpected object at xref start\");\n\t\t\tstatus = eFailure;\n\t\t}\n\n\n\t}while(false);\n\n\n\n\treturn status;\n}\n\nEStatusCode PDFParser::BuildXrefTableAndTrailerFromXrefStream(long long inXrefStreamObjectID)\n{\n\t// xref stream is trailer and stream togather. need to parse them both.\n\t// the object parser is now after the object ID. so verify that next we goot a version and the obj keyword\n\t// then parse the xref stream\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\tdo\n\t{\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, Version\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, obj keyword\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// k. now just parse the object which should be a stream\n\n\t\tNotifyIndirectObjectStart(inXrefStreamObjectID, versionObject->GetValue());\n\n\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\tif(!xrefStream)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failure to parse xref stream\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\tRefCountPtr<PDFDictionary> xrefDictionary(xrefStream->QueryStreamDictionary());\n\t\tmTrailer = xrefDictionary;\n\n\t\tstatus = DetermineXrefSize();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = InitializeXref();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(mTrailer->Exists(\"Prev\"))\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(mTrailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParseXrefFromXrefStream(mXrefTable,mXrefSize,xrefStream.GetPtr(),&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n        // Table may have been extended, in which case replace the pointer and current size\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\n\t}while(false);\n\n\treturn status;\n\n}\n\nEStatusCode PDFParser::ParseXrefFromXrefStream(XrefEntryInput* inXrefTable,\n                                               ObjectIDType inXrefSize,\n                                               LongFilePositionType inXrefPosition,\n                                               XrefEntryInput** outExtendedTable,\n                                               ObjectIDType* outExtendedTableSize)\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tMovePositionInStream(inXrefPosition);\n\n\tdo\n\t{\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tPDFObjectCastPtr<PDFInteger> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject || anObject->GetValue() <= 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXrefFromXrefStream, expecting object number for xref stream at %ld\",inXrefPosition);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, Version\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectStart(anObject->GetValue(), versionObject->GetValue());\n\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, obj keyword\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\tif(!xrefStream)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failure to parse xref stream\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStream.GetPtr(),outExtendedTable,outExtendedTableSize);\n\t}while(false);\n\treturn status;\n}\n\nEStatusCode PDFParser::ParseXrefFromXrefStream(XrefEntryInput* inXrefTable,\n                                               ObjectIDType inXrefSize,\n                                               PDFStreamInput* inXrefStream,\n                                               XrefEntryInput** outExtendedTable,\n                                               ObjectIDType* outExtendedTableSize)\n{\n\t// 1. Setup the stream to read from the stream start location\n\t// 2. Set it up with an input stream to decode if required\n\t// 3. if there are subsections, loop them, otherwise assume a single section of 0..size\n\t// 4. for each subsection use the base number as starting, and count as well, to read the stream entries to the right position in the table\n\t//    The entries are read using the \"W\" value. make sure to read even values that you don't need.\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\n    outExtendedTable = NULL;\n\n\tIByteReader* xrefStreamSource = CreateInputStreamReader(inXrefStream);\n\tint* widthsArray = NULL;\n\n\tdo\n\t{\n\t\tif(!xrefStreamSource)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tRefCountPtr<PDFDictionary> streamDictionary(inXrefStream->QueryStreamDictionary());\n\n\t\t// setup w array\n\t\tPDFObjectCastPtr<PDFArray> wArray(QueryDictionaryObject(streamDictionary.GetPtr(),\"W\"));\n\t\tif(!wArray)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, W array not available. failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\twidthsArray = new int[wArray->GetLength()];\n\t\tfor(unsigned long i=0;i <wArray->GetLength();++i)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFInteger> widthObject(wArray->QueryObject(i));\n\t\t\tif(!widthObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, wrong items in width array (supposed to have only integers)\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidthsArray[i] = (int)widthObject->GetValue();\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\t// read the segments from the stream\n\t\tPDFObjectCastPtr<PDFArray> subsectionsIndex(QueryDictionaryObject(streamDictionary.GetPtr(),\"Index\"));\n\t\tMovePositionInStream(inXrefStream->GetStreamContentStart());\n\n\t\tif(!subsectionsIndex)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefSize(QueryDictionaryObject(streamDictionary.GetPtr(),\"Size\"));\n\t\t\tif(!xrefSize)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, xref size does not exist for this stream\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n            // if reading objects past expected range interesting consult policy\n            ObjectIDType readXrefSize = (ObjectIDType)xrefSize->GetValue();\n            if(readXrefSize > inXrefSize)\n            {\n                if(mAllowExtendingSegments)\n                {\n                    inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,readXrefSize);\n                    inXrefSize = readXrefSize;\n                    if(*outExtendedTable)\n                        delete[] *outExtendedTable;\n                    *outExtendedTable = inXrefTable;\n                    *outExtendedTableSize = readXrefSize;\n                }\n                else\n                    break;\n            }\n\t\t\tstatus = ReadXrefStreamSegment(inXrefTable,0,readXrefSize,xrefStreamSource,widthsArray,wArray->GetLength());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSingleValueContainerIterator<PDFObjectVector> segmentsIterator  = subsectionsIndex->GetIterator();\n\t\t\tPDFObjectCastPtr<PDFInteger> segmentValue;\n\t\t\twhile(segmentsIterator.MoveNext() && PDFHummus::eSuccess == status)\n\t\t\t{\n\t\t\t\tsegmentValue = segmentsIterator.GetItem();\n\t\t\t\tif(!segmentValue)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, found non integer value in Index array of xref stream\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tObjectIDType startObject = (ObjectIDType)segmentValue->GetValue();\n\t\t\t\tif(!segmentsIterator.MoveNext())\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream,Index array of xref stream should have an even number of values\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsegmentValue = segmentsIterator.GetItem();\n\t\t\t\tif(!segmentValue)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, found non integer value in Index array of xref stream\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tObjectIDType objectsCount = (ObjectIDType)segmentValue->GetValue();\n\t\t\t\t// if reading objects past expected range interesting consult policy\n\t\t\t\tif(startObject +  objectsCount > inXrefSize)\n                {\n                    if(mAllowExtendingSegments)\n                    {\n                        inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,startObject +  objectsCount);\n                        inXrefSize = startObject +  objectsCount;\n                        if(*outExtendedTable)\n                            delete[] *outExtendedTable;\n                        *outExtendedTable = inXrefTable;\n                        *outExtendedTableSize = startObject +  objectsCount;\n                    }\n                    else\n                        break;\n                }\n\t\t\t\tstatus = ReadXrefStreamSegment(inXrefTable,startObject,std::min<ObjectIDType>(objectsCount,inXrefSize - startObject),xrefStreamSource,widthsArray,wArray->GetLength());\n\t\t\t}\n\t\t}\n\t}while(false);\n\n\tdelete xrefStreamSource;\n\tdelete[] widthsArray;\n\treturn status;\n}\n\nvoid PDFParser::MovePositionInStream(LongFilePositionType inPosition)\n{\n\tmStream->SetPosition(inPosition);\n\tmObjectParser.ResetReadState();\n}\n\nEStatusCode PDFParser::ReadXrefStreamSegment(XrefEntryInput* inXrefTable,\n\t\t\t\t\t\t\t\t\t\t\t ObjectIDType inSegmentStartObject,\n\t\t\t\t\t\t\t\t\t\t\t ObjectIDType inSegmentCount,\n\t\t\t\t\t\t\t\t\t\t\t IByteReader* inReadFrom,\n\t\t\t\t\t\t\t\t\t\t\t int* inEntryWidths,\n\t\t\t\t\t\t\t\t\t\t\t unsigned long inEntryWidthsSize)\n{\n\tObjectIDType objectToRead = inSegmentStartObject;\n\tEStatusCode status = PDFHummus::eSuccess;\n\tif(inEntryWidthsSize != 3)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ReadXrefStreamSegment, can handle only 3 length entries\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\t// Note - i'm also checking that the stream is not ended. in non-finite segments, it could be that the particular\n\t// stream does no define all objects...just the \"updated\" ones\n\tfor(; (objectToRead < inSegmentStartObject + inSegmentCount) && PDFHummus::eSuccess == status && inReadFrom->NotEnded();++objectToRead)\n\t{\n\t\tlong long entryType;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[0],entryType);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[1],inXrefTable[objectToRead].mObjectPosition);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[2],inXrefTable[objectToRead].mRivision);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(0 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryDelete;\n\t\t}\n\t\telse if (1 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryExisting;\n\t\t}\n\t\telse if(2 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryStreamObject;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ReadXrefStreamSegment, unfamiliar entry type. must be either 0,1 or 2\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t}\n\t}\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadXrefSegmentValue(IByteReader* inSource,int inEntrySize,long long& outValue)\n{\n\toutValue = 0;\n\tByte buffer;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tfor(int i=0;i<inEntrySize && PDFHummus::eSuccess == status;++i)\n\t{\n\t\tstatus = (inSource->Read(&buffer,1) == 1 ? PDFHummus::eSuccess : PDFHummus::eFailure);\n\t\tif(status != PDFHummus::eFailure)\n\t\t\toutValue = (outValue<<8) + buffer;\n\t}\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadXrefSegmentValue(IByteReader* inSource,int inEntrySize,ObjectIDType& outValue)\n{\n\toutValue = 0;\n\tByte buffer;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tfor(int i=0;i<inEntrySize && PDFHummus::eSuccess == status;++i)\n\t{\n\t\tstatus = (inSource->Read(&buffer,1) == 1 ? PDFHummus::eSuccess : PDFHummus::eFailure);\n\t\tif(status != PDFHummus::eFailure)\n\t\t\toutValue = (outValue<<8) + buffer;\n\t}\n\treturn status;\n}\n\nPDFObject* PDFParser::ParseExistingInDirectStreamObject(ObjectIDType inObjectId)\n{\n\t// parsing an object in an object stream requires the following:\n\t// 1. Setting the position to this object stream\n\t// 2. Reading the stream First and N. store.\n\t// 3. Creating a stream reader for the initial stream position and length, possibly decoding with flate\n\t// 4. Read the stream header. store.\n\t// 5. Jump to the right object position (or decode till its position)\n\t// 6. Read the object\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\tObjectStreamHeaderEntry* objectStreamHeader;\n\tIByteReader* objectSource = NULL;\n\n\tInputStreamSkipperStream skipperStream;\n\tObjectIDType objectStreamID;\n\tPDFObject* anObject = NULL;\n\n\tdo\n\t{\n\t\tobjectStreamID = (ObjectIDType)mXrefTable[inObjectId].mObjectPosition;\n\t\tPDFObjectCastPtr<PDFStreamInput> objectStream(ParseNewObject(objectStreamID));\n\t\tif(!objectStream)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectStreamObject, failed to parse object %ld. failed to find object stream for it, which should be %ld\",\n\t\t\t\t\t\tinObjectId,mXrefTable[inObjectId].mObjectPosition);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tRefCountPtr<PDFDictionary> streamDictionary(objectStream->QueryStreamDictionary());\n\n\t\tPDFObjectCastPtr<PDFInteger> streamObjectsCount(QueryDictionaryObject(streamDictionary.GetPtr(),\"N\"));\n\t\tif(!streamObjectsCount)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectStreamObject, no N key in stream dictionary %ld\",objectStreamID);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tObjectIDType objectsCount = (ObjectIDType)streamObjectsCount->GetValue();\n\n\t\tPDFObjectCastPtr<PDFInteger> firstStreamObjectPosition(QueryDictionaryObject(streamDictionary.GetPtr(),\"First\"));\n\t\tif(!streamObjectsCount)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectStreamObject, no First key in stream dictionary %ld\",objectStreamID);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectSource = CreateInputStreamReader(objectStream.GetPtr());\n\t\tskipperStream.Assign(objectSource);\n\t\tMovePositionInStream(objectStream->GetStreamContentStart());\n\n\t\tmObjectParser.SetReadStream(&skipperStream,&skipperStream);\n\n\t\tObjectIDTypeToObjectStreamHeaderEntryMap::iterator it = mObjectStreamsCache.find(objectStreamID);\n\n\t\tif(it == mObjectStreamsCache.end())\n\t\t{\n\t\t\tobjectStreamHeader = new ObjectStreamHeaderEntry[objectsCount];\n\t\t\tstatus = ParseObjectStreamHeader(objectStreamHeader,objectsCount);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t{\n\t\t\t\tdelete[] objectStreamHeader;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit = mObjectStreamsCache.insert(ObjectIDTypeToObjectStreamHeaderEntryMap::value_type(objectStreamID,objectStreamHeader)).first;\n\t\t}\n\t\tobjectStreamHeader = it->second;\n\n\t\t// verify that i got the right object ID\n\t\tif(objectsCount <= mXrefTable[inObjectId].mRivision || objectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectNumber != inObjectId)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseXrefFromXrefStream, wrong object. expecting to find object ID %ld, and found %ld\",\n\t\t\t\t\t\tinObjectId,\n\t\t\t\t\t\tobjectsCount <= mXrefTable[inObjectId].mRivision ?\n\t\t\t\t\t\t\t-1 :\n\t\t\t\t\t\t\tobjectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectNumber);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// when parsing the header, should be at position already..so don't skip if already there [using GetCurrentPosition to see if parsed some]\n\t\tif(mXrefTable[inObjectId].mRivision != 0 || skipperStream.GetCurrentPosition() == 0)\n\t\t{\n\t\t\tLongFilePositionType objectPositionInStream = objectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectOffset +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  firstStreamObjectPosition->GetValue();\n\t\t\tskipperStream.SkipTo(objectPositionInStream);\n\t\t\tmObjectParser.ResetReadState();\n\t\t}\n\n\t\tmDecryptionHelper.PauseDecryption(); // objects within objects stream already enjoy the object stream protection, and so are no longer encrypted\n\t\tNotifyIndirectObjectStart(inObjectId,0);\n\t\tanObject = mObjectParser.ParseNewObject();\n\t\tNotifyIndirectObjectEnd(anObject);\n\t\tmDecryptionHelper.ReleaseDecryption();\n\n\t}while(false);\n\n\tmObjectParser.SetReadStream(mStream,&mCurrentPositionProvider);\n\n\treturn anObject;\n}\n\nvoid PDFParser::NotifyIndirectObjectStart(long long inObjectID, long long inGenerationNumber) {\n\tif (mParserExtender)\n\t\tmParserExtender->OnObjectStart(inObjectID, inGenerationNumber);\n\n\tmDecryptionHelper.OnObjectStart(inObjectID, inGenerationNumber);\n}\n\nvoid PDFParser::NotifyIndirectObjectEnd(PDFObject* inObject) {\n\tif (mParserExtender)\n\t\tmParserExtender->OnObjectEnd(inObject);\n\n\tmDecryptionHelper.OnObjectEnd(inObject);\n\n}\n\n\nEStatusCode PDFParser::ParseObjectStreamHeader(ObjectStreamHeaderEntry* inHeaderInfo,ObjectIDType inObjectsCount)\n{\n\tObjectIDType currentObject = 0;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\twhile(currentObject < inObjectsCount && (PDFHummus::eSuccess == status))\n\t{\n\t\tPDFObjectCastPtr<PDFInteger> objectNumber(mObjectParser.ParseNewObject());\n\t\tif(!objectNumber)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseObjectStreamHeader, parsing failed when reading object number. either not enough objects, or of the wrong type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> objectPosition(mObjectParser.ParseNewObject());\n\t\tif(!objectPosition)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseObjectStreamHeader, parsing failed when reading object position. either not enough objects, or of the wrong type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tinHeaderInfo[currentObject].mObjectNumber = (ObjectIDType)(objectNumber->GetValue());\n\t\tinHeaderInfo[currentObject].mObjectOffset = objectPosition->GetValue();\n\t\t++currentObject;\n\t}\n\treturn status;\n}\n\nIByteReader* PDFParser::WrapWithDecryptionFilter(PDFStreamInput* inStream, IByteReader* inToWrapStream) {\n\tif (IsEncrypted() && IsEncryptionSupported()) {\n\t\t// try with decryption helper\n\t\tIByteReader*  result = \tmDecryptionHelper.CreateDefaultDecryptionFilterForStream(inStream, inToWrapStream);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\t// try with extender\n\t\tif(mParserExtender)\n\t\t\tresult = mParserExtender->CreateDefaultDecryptionFilterForStream(inStream, inToWrapStream);\n\n\t\tif (result)\n\t\t\treturn result;\n\t\telse\n\t\t\treturn inToWrapStream;\n\t}\n\telse {\n\t\treturn inToWrapStream;\n\t}\n}\n\nIByteReader* PDFParser::CreateInputStreamReader(PDFStreamInput* inStream)\n{\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tIByteReader* result = NULL;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\n\t\t// setup stream according to length and possible filter\n\t\tPDFObjectCastPtr<PDFInteger> lengthObject(QueryDictionaryObject(streamDictionary.GetPtr(),\"Length\"));\n\t\tif(!lengthObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, stream does not have length, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = new InputLimitedStream(mStream,lengthObject->GetValue(),false);\n\n\t\tresult = WrapWithDecryptionFilter(inStream,result);\n\n\t\tRefCountPtr<PDFObject> filterObject(QueryDictionaryObject(streamDictionary.GetPtr(),\"Filter\"));\n\t\tif(!filterObject)\n\t\t{\n\t\t\t// no filter, so stop here\n\t\t\tbreak;\n\t\t}\n\n\t\tif(filterObject->GetType() == PDFObject::ePDFObjectArray)\n\t\t{\n\t\t\tPDFArray* filterObjectArray = (PDFArray*)filterObject.GetPtr();\n\t\t\tPDFObjectCastPtr<PDFArray> decodeParams(QueryDictionaryObject(streamDictionary.GetPtr(),\"DecodeParms\"));\n\t\t\tfor(unsigned long i=0; i < filterObjectArray->GetLength() && eSuccess == status;++i)\n\t\t\t{\n\t\t\t\tPDFObjectCastPtr<PDFName> filterObjectItem(filterObjectArray->QueryObject(i));\n\t\t\t\tif(!filterObjectItem)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, filter item in an array is not a name. should be a name\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tEStatusCodeAndIByteReader createStatus;\n\t\t\t\tif(!decodeParams)\n\t\t\t\t{\n\t\t\t\t\t createStatus = CreateFilterForStream(result,filterObjectItem.GetPtr(), NULL, inStream);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPDFObjectCastPtr<PDFDictionary> decodeParamsItem(QueryArrayObject(decodeParams.GetPtr(),i));\n\n\t\t\t\t\tcreateStatus = CreateFilterForStream(result,(PDFName*)filterObject.GetPtr(), !decodeParamsItem ? NULL: decodeParamsItem.GetPtr(), inStream);\n\t\t\t\t}\n\n\t\t\t\tif(createStatus.first != eSuccess)\n\t\t\t\t{\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresult = createStatus.second;\n\t\t\t}\n\t\t}\n\t\telse if(filterObject->GetType() == PDFObject::ePDFObjectName)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFDictionary> decodeParams(QueryDictionaryObject(streamDictionary.GetPtr(),\"DecodeParms\"));\n\n\t\t\tEStatusCodeAndIByteReader createStatus = CreateFilterForStream(result,(PDFName*)filterObject.GetPtr(), !decodeParams ? NULL: decodeParams.GetPtr(), inStream);\n\t\t\tif(createStatus.first != eSuccess)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult = createStatus.second;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, filter parameter is of unkown type. only array and name are supported.\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t}while(false);\n\n\n\tif(status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn result;\n}\n\nEStatusCodeAndIByteReader PDFParser::CreateFilterForStream(IByteReader* inStream,PDFName* inFilterName,PDFDictionary* inDecodeParams, PDFStreamInput* inPDFStream)\n{\n\tEStatusCode status = eSuccess;\n\tIByteReader* result = NULL;\n\n\tdo\n\t{\n\n\t\tif(inFilterName->GetValue() == \"FlateDecode\" || inFilterName->GetValue() == \"LZWDecode\")\n\t\t{\n\t\t\tif (inFilterName->GetValue() == \"FlateDecode\")\n\t\t\t{\n\t\t\t\tInputFlateDecodeStream* flateStream;\n\t\t\t\tflateStream = new InputFlateDecodeStream(NULL); // assigning null, so later delete, if failure occurs won't delete the input stream\n\t\t\t\tflateStream->Assign(inStream);\n\t\t\t\tresult = flateStream;\n\t\t\t}\n\t\t\telse if (inFilterName->GetValue() == \"LZWDecode\")\n\t\t\t{\n\t\t\t\tInputLZWDecodeStream* lzwStream;\n\t\t\t\tint early = 1;\n\t\t\t\tif (inDecodeParams)\n\t\t\t\t{\n\t\t\t\t\tPDFObjectCastPtr<PDFInteger> earlyObj(QueryDictionaryObject(inDecodeParams, \"EarlyChange\"));\n\t\t\t\t\tearly = earlyObj->GetValue();\n\t\t\t\t}\n\t\t\t\tlzwStream = new InputLZWDecodeStream(early);\n\t\t\t\tlzwStream->Assign(inStream);\n\t\t\t\tresult = lzwStream;\n\t\t\t}\n\n\t\t\t// check for predictor n' such\n\t\t\tif (!inDecodeParams)\n\t\t\t\t// no predictor, stop here\n\t\t\t\tbreak;\t\t\t\n\n\t\t\t// read predictor, and apply the relevant predictor function\n\t\t\tPDFObjectCastPtr<PDFInteger> predictor(QueryDictionaryObject(inDecodeParams,\"Predictor\"));\n\n\t\t\tif(!predictor || predictor->GetValue() == 1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFInteger> columns(QueryDictionaryObject(inDecodeParams,\"Columns\"));\n\t\t\tPDFObjectCastPtr<PDFInteger> colors(QueryDictionaryObject(inDecodeParams,\"Colors\"));\n\t\t\tPDFObjectCastPtr<PDFInteger> bitsPerComponent(QueryDictionaryObject(inDecodeParams,\"BitsPerComponent\"));\n\t\t\tLongBufferSizeType columnsValue = columns.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)columns->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1;\n\t\t\tLongBufferSizeType colorsValue = colors.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)colors->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1;\n\t\t\tLongBufferSizeType bitsPerComponentValue = bitsPerComponent.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)bitsPerComponent->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t8;\n\n\t\t\tswitch(predictor->GetValue())\n\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tresult = new InputPredictorTIFFSubStream(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t colorsValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitsPerComponentValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnsValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 10:\n\t\t\t\tcase 11:\n\t\t\t\tcase 12:\n\t\t\t\tcase 13:\n\t\t\t\tcase 14:\n\t\t\t\tcase 15:\n\t\t\t\t{\n\t\t\t\t\t// Gal: optimum can handle all presets, because non-optimum presets still require a function sign flag\n\t\t\t\t\t// at line start...so optimum can handle them.\n\t\t\t\t\tresult =  new InputPredictorPNGOptimumStream(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t colorsValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitsPerComponentValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnsValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::CreateFilterForStream, supporting only predictor of types 1,2,10,11,12,13,14,15, failing\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (inFilterName->GetValue() == \"ASCIIHexDecode\")\n\t\t{\n\t\t\tresult = new InputAsciiHexDecodeStream(inStream);\n\t\t}\n\t\telse if(inFilterName->GetValue() == \"ASCII85Decode\")\n\t\t{\n\t\t\tresult = new InputAscii85DecodeStream(inStream);\n\t\t}\n#ifndef PDFHUMMUS_NO_DCT\n        else if(inFilterName->GetValue() == \"DCTDecode\")\n        {\n            result = new InputDCTDecodeStream(inStream);\n        }\n#endif\n\t\telse if (inFilterName->GetValue() == \"Crypt\")\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFName> cryptFilterName(QueryDictionaryObject(inDecodeParams, \"Name\"));\n\n\t\t\tresult = mDecryptionHelper.CreateDecryptionFilterForStream(inPDFStream, inStream, cryptFilterName->GetValue());\n\t\t}\n\t\telse if(mParserExtender)\n\t\t{\n\t\t\tresult = mParserExtender->CreateFilterForStream(inStream,inFilterName,inDecodeParams, inPDFStream);\n\t\t\tif(result == inStream)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::CreateFilterForStream, filter is not supported by extender - %s\",inFilterName->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateFilterForStream, supporting only flate decode, lzw, dct, crypt and ascii 85+hex decode, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t}while(false);\n\n\tif(status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn EStatusCodeAndIByteReader(status,result);\n\n}\n\nIByteReader* PDFParser::StartReadingFromStream(PDFStreamInput* inStream)\n{\n    IByteReader* result = CreateInputStreamReader(inStream);\n    if(result)\n        MovePositionInStream(inStream->GetStreamContentStart());\n    return result;\n}\n\nPDFObjectParser* PDFParser::StartReadingObjectsFromStream(PDFStreamInput* inStream) {\n\tIByteReader* readStream = StartReadingFromStream(inStream);\n\tif(!readStream)\n\t\treturn NULL;\n\n\tPDFObjectParser* objectsParser = new PDFObjectParser();\n\tInputStreamSkipperStream* source = new InputStreamSkipperStream(readStream);\n\tobjectsParser->SetReadStream(source,source,true);\n\t// Not setting decryption filter cause shuoldnt decrypt at lower level. if at all - the stream is encrypted already\n\tobjectsParser->SetParserExtender(mParserExtender);\n\n\treturn objectsParser;\n}\n\nPDFObjectParser* PDFParser::StartReadingObjectsFromStreams(PDFArray* inArrayOfStreams) {\n\tIByteReader* readStream = new ArrayOfInputStreamsStream(inArrayOfStreams,this);\n\n\tPDFObjectParser* objectsParser = new PDFObjectParser();\n\tInputStreamSkipperStream* source = new InputStreamSkipperStream(readStream);\n\tobjectsParser->SetReadStream(source, source, true);\n\t// Not setting decryption filter cause shuoldnt decrypt at lower level. if at all - the stream is encrypted already\n\tobjectsParser->SetParserExtender(mParserExtender);\n\n\treturn objectsParser;\n}\n\nIByteReader* PDFParser::CreateInputStreamReaderForPlainCopying(PDFStreamInput* inStream) {\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tIByteReader* result = NULL;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\n\t\t// setup stream according to length and possible filter\n\t\tPDFObjectCastPtr<PDFInteger> lengthObject(QueryDictionaryObject(streamDictionary.GetPtr(), \"Length\"));\n\t\tif (!lengthObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReaderForPlainCopying, stream does not have length, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = new InputLimitedStream(mStream, lengthObject->GetValue(), false);\n\n\t\tresult = WrapWithDecryptionFilter(inStream, result);\n\n\t} while (false);\n\n\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn result;\n}\n\nIByteReader* PDFParser::StartReadingFromStreamForPlainCopying(PDFStreamInput* inStream) {\n\tIByteReader* result = CreateInputStreamReaderForPlainCopying(inStream);\n\tif (result)\n\t\tMovePositionInStream(inStream->GetStreamContentStart());\n\treturn result;\n}\n\nEStatusCode PDFParser::StartStateFileParsing(IByteReaderWithPosition* inSourceStream)\n{\n\tEStatusCode status;\n\n\tResetParser();\n\n\tmStream = inSourceStream;\n\tmCurrentPositionProvider.Assign(mStream);\n\tmObjectParser.SetReadStream(inSourceStream,&mCurrentPositionProvider);\n\n\tdo\n\t{\n\t\t// initialize reading from end\n\t\tmLastReadPositionFromEnd = 0;\n\t\tmEncounteredFileStart = false;\n\t\tmLastAvailableIndex = mCurrentBufferIndex = mLinesBuffer;\n\n\t\tstatus = ParseEOFLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseLastXrefPosition();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseFileDirectory(); // that would be the xref and trailer\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t}while(false);\n\n\treturn status;\n}\n\nbool PDFParser::IsEncrypted()\n{\n\treturn mDecryptionHelper.IsEncrypted();\n}\n\nvoid PDFParser::SetParserExtender(IPDFParserExtender* inParserExtender)\n{\n\tmParserExtender = inParserExtender;\n\tmObjectParser.SetParserExtender(inParserExtender);\n}\n\nbool PDFParser::IsEncryptionSupported()\n{\n    return mDecryptionHelper.CanDecryptDocument() || (mParserExtender && mParserExtender->DoesSupportEncryption());\n}\n\nObjectIDType PDFParser::GetXrefSize()\n{\n    return mXrefSize;\n}\n\nXrefEntryInput* PDFParser::GetXrefEntry(ObjectIDType inObjectID)\n{\n    return (inObjectID < mXrefSize) ? mXrefTable+inObjectID : NULL;\n}\n\nLongFilePositionType PDFParser::GetXrefPosition()\n{\n    return mLastXrefPosition;\n}\n\nIByteReaderWithPosition* PDFParser::GetParserStream()\n{\n    return mStream;\n}\n\n\n\n\n\n\n\n", "Couldn't find the requested file /tests/SigSeg.js in julianhille/MuhammaraJS.", "Couldn't find the requested file /tests/TestMaterials/BrokenPdfBadHeader.txt in julianhille/MuhammaraJS."], "fixing_code": ["# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Fixed\n\n- NPE in parser when file ends before it really starts\n\n## [3.1.0] - 2022-09-30\n\n### Changed\n\n- Update TypeScript declaration for `PDFStreamForResponse` to accept any writable stream as an argument, not just `PDFRStreamForFile`\n\n### Added\n\n- Node 18\n- Electron 20.0, 20.1, 20.2\n- Prettier as dev dependency and basics\n- Electron 19.1\n\n## [3.0.0] - 2022-07-19\n\n### Fixed\n\n- Links in docs\n\n### Added\n\n- drawPath can now be used differently and this new way can be described with ts.\n  The old style is `drawPath(x1, y1, x2, y2..., options)` we now allow `drawPath([[x1, y1], [x2, y2]...], options)` too\n- scn and SCN can now be used differently and this new way can be described with ts.\n  The old style is `scn(c1, c2, c3, c4, ..., 'patternName')` we now allow `scn([[c1, c2, c3, c4, ...], 'patternName')` too\n\n### Changed\n\n- Bump dev dependency versions s\n\n### Breaking\n\n- Node < 11 and Electron < 11 removed\n- Renamed typo exported value from eTokenSeprator to eTokenSeparator\n\n## [2.6.0] - 2022-06-30\n\n### Changed\n\n- Fixes hard crash to exception when creating a stream with null object and calling createWriter with it\n- Fixes missing buffer information for recrypt typescript definition\n- Fixes missing options for append pdf pages\n- Fixes NPE when stream is not readable in write stream object (PDFDocumentHandler)\n\n## [2.5.0] - 2022-06-23\n\n### Added\n\n- Electron 17.2.0, 17.3, 17.4\n- Typescript definitions\n- Add test for recrypt with streams\n\n## [2.4.0] - 2022-06-08\n\n### Added\n\n- Electron 18.1, 18.2, 18.3\n- Electron 19.0\n\n### Changed\n\n- Update npm dist url to the new url for electron builds\n\n## [2.3.0] - 2022-05-04\n\n### Added\n\n- Builds for node and electron with arm64 on darwin (Apple M1)\n- Add electron 18\n\n## [2.2.0] - 2022-03-05\n\n### Changed\n\n- Update PDFWriter dependency to the newest available versoin\n\n### Added\n\n- Electron version: 17.0, 17.1\n- NodeJs 17.6.0\n\n## [2.1.0] - 2021-12-03\n\n### Added\n\n- Electron versions: 16.0, 15.3, 15.2, 14.2, 13.6, 13.3\n\n## [2.0.0] - 2021-10-22\n\n### Removed\n\n- Electron 2.0.7\n- Node 6.14.1 and 7.10.1\n\n### Added\n\n- Add Electron 13.3.0\n- Documentation (copy of the wiki)\n- Add Electron 13.2.3\n- Add Electron 13.5.0\n- Add Electron 14.0.1\n- Add Electron 14.1.0\n- Add Electron 15.0.0\n- Add Electron 15.1.2\n- Add Node 16.11.1\n\n### Fixed\n\n- Dependency to node-pre-gyp moved from deprecated to scoped package\n\n## [1.10.0] - 2021-07-12\n\n### Added\n\n- Add Electron 13.1\n- Disable NEON on arm builds\n\n## [1.9.0] - 2021-06-30\n\n### Fixed\n\n- Yarn v2 incompatibiliy\n- Build issues on mac OS big sur\n\n## [1.8.0] - 2021-05-28\n\n### Added\n\n- Add Electron 13.0\n- Add missing typescript declaration of the PDFWStreamForBuffer\n- Add Electron 11.4\n- Add electron 10.4\n\n## [1.7.0] - 2021-03-08\n\n### Added\n\n- More electron 11.x releases\n- Add electron 12.0.0\n- Add electron 10.2, 10.3\n- Add electron 9.4, 9.3\n\n## [1.6.0] - 2021-02-17\n\n### Fixed\n\n- Update the g++ compiler from 4.8 to 5.4 (default on xenial) for linux builds\n- Changed builds from travis and app veyor to github\n\n### Added\n\n- Electron 11\n- Added Node 15\n\n## [1.5.1] - 2020-10-10\n\n### Added\n\n- Added manual workflow to reduce release errors\n\n### Fixed\n\n- Huge package size as npm publish does not use .gitignore or .npmignore locally\n\n## [1.5.0] - 2020-10-10\n\n### Added\n\n- Electron 7.3, 8.3, 8.4, 8.5 and 9.3\n\n## [1.4.3] - 2020-10-09\n\n### Fixed\n\n- Return code fixed for builds on app veyor.\n- Winwdows builds successfully with electron 10.x\n- NPM version on app veyor fixed to build electron 2.x again\n\n### Added\n\n- Add electron 10.1.3\n\n## [1.4.2] - 2020-08-27\n\n### Added\n\n- Add electron 10.0\n\n## [1.4.1] - 2020-08-13\n\nThis is a special release no code has been changed.\nThe packaged module included (in version muhammara@1.4.0) a bundled dependency with a\ndebug output.\n\n### Fixed\n\n- Removed debug output from packaged dependency `node-pre-gyp`\n\n## [1.4.0] - 2020-08-10\n\n### Added\n\n- Add electron 9.2\n\n## [1.3.0] - 2020-08-06\n\n### Added\n\n- Add electron-9.1 pre built\n\n### Fixed\n\n- Add missing typescript declaration files to published packages\n\n## [1.2.0] - 2020-06-01\n\n### Fixed\n\n- Updated freetype to 2.10.0\n- Updated libpng dependency to 1.6.37\n- Updated libaesgm dependency\n- Update libjpeg dependency to 9d\n- Updated libtiff dependency to 3.9.7\n\n## [1.1.0] - 2020-05-27\n\n### Added\n\n- Added infos about being hummusjs drop in replacement\n- Added electron v9.0.0\n\n### Fixed\n\n- Updated dependencies and dev dependencies\n\n## [1.0.1] - 2020-05-08\n\n### Fixed\n\n- Fixed readme to include infos about muhammaraJS and hummus\n- Fixed node-pre-gyp binary download links\n\n### Removed\n\n- Unecessary dependency on aws-sdk\n\n## [1.0.0] - 2020-05-07\n\nBasically this is [HummusJS v1.0.108](https://github.com/galkahana/HummusJS/commit/772bd561f02433bf1a602135f53c7c17f8072450)\nwith the following changes.\n\n### Added\n\n- Store releases @github\n- Listen for tags instead of a commit message\n- Added node v13, v14, electron 6.1, 7.1, 7.2, 8.0, 8.1, 8.2\n\n### Fixed\n\n- Updated v8:GET / v8:SET calls which are incompatible with newer node version (>13)\n\n### Removed\n\n- Dropped support for electron 1.8\n\n- Initial release\n\n[unreleased]: https://github.com/julianhille/MuhammaraJS/compare/3.1.0...HEAD\n[3.1.0]: https://github.com/julianhille/MuhammaraJS/compare/3.0.0...3.1.0\n[3.0.0]: https://github.com/julianhille/MuhammaraJS/compare/2.6.0...3.0.0\n[2.6.0]: https://github.com/julianhille/MuhammaraJS/compare/2.5.0...2.6.0\n[2.5.0]: https://github.com/julianhille/MuhammaraJS/compare/2.4.0...2.5.0\n[2.4.0]: https://github.com/julianhille/MuhammaraJS/compare/2.3.0...2.4.0\n[2.3.0]: https://github.com/julianhille/MuhammaraJS/compare/2.2.0...2.3.0\n[2.2.0]: https://github.com/julianhille/MuhammaraJS/compare/2.1.0...2.2.0\n[2.1.0]: https://github.com/julianhille/MuhammaraJS/compare/2.0.0...2.1.0\n[2.0.0]: https://github.com/julianhille/MuhammaraJS/compare/1.10.0...2.0.0\n[1.10.0]: https://github.com/julianhille/MuhammaraJS/compare/1.9.0...1.10.0\n[1.9.0]: https://github.com/julianhille/MuhammaraJS/compare/1.8.0...1.9.0\n[1.8.0]: https://github.com/julianhille/MuhammaraJS/compare/1.7.0...1.8.0\n[1.7.0]: https://github.com/julianhille/MuhammaraJS/compare/1.6.0...1.7.0\n[1.6.0]: https://github.com/julianhille/MuhammaraJS/compare/1.5.1...1.6.0\n[1.5.1]: https://github.com/julianhille/MuhammaraJS/compare/1.5.0...1.5.1\n[1.5.0]: https://github.com/julianhille/MuhammaraJS/compare/1.4.3...1.5.0\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.3]: https://github.com/julianhille/MuhammaraJS/compare/1.4.2...1.4.3\n[1.4.2]: https://github.com/julianhille/MuhammaraJS/compare/1.4.1...1.4.2\n[1.4.1]: https://github.com/julianhille/MuhammaraJS/compare/1.4.0...1.4.1\n[1.4.0]: https://github.com/julianhille/MuhammaraJS/compare/1.3.0...1.4.0\n[1.3.0]: https://github.com/julianhille/MuhammaraJS/compare/1.2.0...1.3.0\n[1.2.0]: https://github.com/julianhille/MuhammaraJS/compare/1.1.0...1.2.0\n[1.1.0]: https://github.com/julianhille/MuhammaraJS/compare/1.0.1...1.1.0\n[1.0.1]: https://github.com/julianhille/MuhammaraJS/compare/1.0.0...1.0.1\n[1.0.0]: https://github.com/julianhille/MuhammaraJS/tree/1.0.0\n", "/*\n   Source File : PDFParser.cpp\n\n\n   Copyright 2011 Gal Kahana PDFWriter\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n\n*/\n#include \"PDFParser.h\"\n#include \"IByteReaderWithPosition.h\"\n#include \"PDFParserTokenizer.h\"\n#include \"Trace.h\"\n#include \"PDFInteger.h\"\n#include \"PDFObject.h\"\n#include \"PDFSymbol.h\"\n#include \"BoxingBase.h\"\n#include \"PDFDictionary.h\"\n#include \"BoxingBase.h\"\n#include \"PDFIndirectObjectReference.h\"\n#include \"PDFName.h\"\n#include \"PDFArray.h\"\n#include \"RefCountPtr.h\"\n#include \"PDFObjectCast.h\"\n#include \"PDFStreamInput.h\"\n#include \"InputLimitedStream.h\"\n#include \"InputFlateDecodeStream.h\"\n#include \"InputLZWDecodeStream.h\"\n#include \"InputStreamSkipperStream.h\"\n#include \"InputPredictorPNGOptimumStream.h\"\n#include \"InputPredictorTIFFSubStream.h\"\n#include \"InputAscii85DecodeStream.h\"\n#include \"InputAsciiHexDecodeStream.h\"\n#include \"IPDFParserExtender.h\"\n#include \"InputDCTDecodeStream.h\"\n#include \"ArrayOfInputStreamsStream.h\"\n\n#include  <algorithm>\nusing namespace PDFHummus;\n\nPDFParser::PDFParser(void)\n{\n\tmStream = NULL;\n\tmTrailer = NULL;\n\tmXrefTable = NULL;\n\tmPagesObjectIDs = NULL;\n\tmParserExtender = NULL;\n    mAllowExtendingSegments = true; // Gal 19.9.2013: here's some policy changer. basically i'm supposed to ignore all segments that declare objects past the trailer\n                                    // declared size. but i would like to allow files that do extend. as this is incompatible with the specs, i'll make\n                                    // this boolean dendent. i will sometimes make it public so ppl can actually modify this policy. for now, it's internal\n\tmObjectParser.SetDecryptionHelper(&mDecryptionHelper);\n}\n\nPDFParser::~PDFParser(void)\n{\n\tResetParser();\n}\n\nvoid PDFParser::ResetParser()\n{\n\tmTrailer = NULL;\n\tdelete[] mXrefTable;\n\tmXrefTable = NULL;\n\tdelete[] mPagesObjectIDs;\n\tmPagesObjectIDs = NULL;\n\tmStream = NULL;\n\tmCurrentPositionProvider.Assign(NULL);\n\n\tObjectIDTypeToObjectStreamHeaderEntryMap::iterator it = mObjectStreamsCache.begin();\n\tfor(; it != mObjectStreamsCache.end();++it)\n\t\tdelete[] it->second;\n\tmObjectStreamsCache.clear();\n\tmDecryptionHelper.Reset();\n\n}\n\nEStatusCode PDFParser::StartPDFParsing(IByteReaderWithPosition* inSourceStream, const PDFParsingOptions& inOptions)\n{\n\tEStatusCode status;\n\n\tResetParser();\n\n\tmStream = inSourceStream;\n\tmCurrentPositionProvider.Assign(mStream);\n\tmObjectParser.SetReadStream(inSourceStream,&mCurrentPositionProvider);\n\n\tdo\n\t{\n\t\tstatus = ParseHeaderLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\t// initialize reading from end\n\t\tmLastReadPositionFromEnd = 0;\n\t\tmEncounteredFileStart = false;\n\t\tmLastAvailableIndex = mCurrentBufferIndex = mLinesBuffer;\n\n\t\tstatus = ParseEOFLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseLastXrefPosition();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseFileDirectory(); // that would be the xref and trailer\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = SetupDecryptionHelper(inOptions.Password);\n\t\tif (status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif (IsEncrypted() && !IsEncryptionSupported())\n\t\t{\n\t\t\t// not parsing pages for encrypted docs that the lib cant decrypt.\n\t\t\t// not commiting..and there's a practical reason.\n\t\t\t// lower level objects will be in object streams (for those PDFs that have them)\n\t\t\t// and the may not be accessed\n\t\t\tmPagesCount = 0;\n\t\t\tmPagesObjectIDs = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = ParsePagesObjectIDs();\n\t\t\tif (status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n\t}while(false);\n\n\treturn status;\n}\n\nPDFObjectParser& PDFParser::GetObjectParser()\n{\n\treturn mObjectParser;\n}\n\nDecryptionHelper& PDFParser::GetDecryptionHelper() {\n\treturn mDecryptionHelper;\n}\n\nstatic const std::string scPDFMagic = \"%PDF-\";\nEStatusCode PDFParser::ParseHeaderLine()\n{\n\tPDFParserTokenizer tokenizer;\n\n\ttokenizer.SetReadStream(mStream);\n\tBoolAndString tokenizerResult = tokenizer.GetNextToken();\n\n\tif(!tokenizerResult.first)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ParseHeaderLine, no tokens in PDF input. in other words - it's empty.\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tif(tokenizerResult.second.compare(0,scPDFMagic.size(),scPDFMagic) != 0)\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParseHeaderLine, file does not begin as a PDF file. a PDF file should start with \\\"%%PDF-\\\". file header = %s\",tokenizerResult.second.substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tmPDFLevel = Double(tokenizerResult.second.substr(scPDFMagic.size()));\n\treturn PDFHummus::eSuccess;\n}\n\nstatic const std::string scEOF = \"%%EOF\";\nEStatusCode PDFParser::ParseEOFLine()\n{\n\t/* go back till you hit token. this should be the EOF. go back till line start and get the token...if it's not EOF, fail.\n\t   since EOF is a comment, then if there's anything else in that line it will either be before %%EOF, which means %%EOF won't be taken, or after -\n\t   in which case it'd be part of the comment. in any case - if it's not exactly EOF, there will be a failure. but i am allowing\n\t   extra empty lines after %%EOF\n\t*/\n\n\tbool foundEOF = false,canRead = true;\n\twhile (!foundEOF && canRead) {\n\t\tif (GoBackTillToken())\n\t\t{\n\t\t\tGoBackTillLineStart();\n\t\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\t\tPDFParserTokenizer aTokenizer;\n\t\t\taTokenizer.SetReadStream(mStream);\n\t\t\tBoolAndString token = aTokenizer.GetNextToken();\n\n\t\t\tif (token.first && (token.second.substr(0, scEOF.length()) == scEOF))\n\t\t\t{\n\t\t\t\tfoundEOF = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseEOFLine, Couldn't find tokens in file\");\n\t\t\tcanRead = false;\n\t\t}\n\t}\n\n\treturn foundEOF ? PDFHummus::eSuccess : PDFHummus::eFailure;\n}\n\nLongBufferSizeType PDFParser::GetCurrentPositionFromEnd()\n{\n\treturn mLastReadPositionFromEnd-(mCurrentBufferIndex-mLinesBuffer);\n}\n\nbool PDFParser::GoBackTillToken()\n{\n\tByte buffer;\n\tbool foundToken = false;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(!IsPDFWhiteSpace(buffer))\n\t\t{\n\t\t\tfoundToken = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn foundToken;\n}\n\nbool PDFParser::GoBackTillNonToken()\n{\n\tByte buffer;\n\tbool foundNonToken = false;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(IsPDFWhiteSpace(buffer))\n\t\t{\n\t\t\tfoundNonToken = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn foundNonToken;\n}\n\nstatic const Byte scWhiteSpaces[] = {0,0x9,0xA,0xC,0xD,0x20};\nbool PDFParser::IsPDFWhiteSpace(Byte inCharacter)\n{\n\tbool isWhiteSpace = false;\n\tfor(int i=0; i < 6 && !isWhiteSpace; ++i)\n\t\tisWhiteSpace =  (scWhiteSpaces[i] == inCharacter);\n\treturn isWhiteSpace;\n}\n\n\nstatic const char scCR = '\\r';\nstatic const char scLN = '\\n';\nvoid PDFParser::GoBackTillLineStart()\n{\n\tByte buffer;\n\n\twhile(ReadBack(buffer))\n\t{\n\t\tif(scLN == buffer || scCR == buffer)\n\t\t\tbreak;\n\t}\n}\n\nbool PDFParser::ReadBack(Byte& outValue)\n{\n\tif(IsBeginOfFile())\n\t\treturn false;\n\n\tif(mCurrentBufferIndex > mLinesBuffer)\n\t{\n\t\t--mCurrentBufferIndex;\n\t\toutValue = *mCurrentBufferIndex;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tReadNextBufferFromEnd(); // must be able to read...but could be 0 bytes\n\t\tif(mCurrentBufferIndex > mLinesBuffer)\n\t\t{\n\t\t\t--mCurrentBufferIndex;\n\t\t\toutValue = *mCurrentBufferIndex;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\nbool PDFParser::ReadNextBufferFromEnd()\n{\n\tif(mEncounteredFileStart)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tmStream->SetPositionFromEnd(mLastReadPositionFromEnd); // last known position that worked.\n\t\tLongFilePositionType positionBefore = mStream->GetCurrentPosition();\n\t\tmStream->SetPositionFromEnd(mLastReadPositionFromEnd + LINE_BUFFER_SIZE); // try earlier one\n\t\tLongFilePositionType positionAfter = mStream->GetCurrentPosition();\n\t\tLongBufferSizeType readAmount = positionBefore - positionAfter; // check if got to start by testing position\n\t\tif(readAmount != 0)\n\t\t\treadAmount = mStream->Read(mLinesBuffer,readAmount);\n\t\tmEncounteredFileStart = readAmount < LINE_BUFFER_SIZE;\n\t\tif(0 == readAmount)\n\t\t\treturn false;\n\t\tmLastAvailableIndex = mLinesBuffer + readAmount;\n\t\tmCurrentBufferIndex = mLastAvailableIndex;\n\t\tmLastReadPositionFromEnd+= readAmount;\n\t\treturn true;\n\t}\n}\n\nbool PDFParser::IsBeginOfFile()\n{\n\treturn mEncounteredFileStart && (mCurrentBufferIndex == mLinesBuffer);\n}\n\nstatic const std::string scStartxref = \"startxref\";\nEStatusCode PDFParser::ParseLastXrefPosition()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\t// next two lines should be the xref position and then \"startxref\"\n\n\tdo\n\t{\n\n\t\t// find and read xref position\n\t\tif(!GoBackTillToken())\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find xref position token\");\n\t\t\tbreak;\n\t\t}\n\n\t\tGoBackTillLineStart();\n\n\t\t// now go forward, and here i'm guessing a bit, till you get to either and integer, or the startxref keyword\n\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\tmObjectParser.ResetReadState();\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\n\t\tif (!anObject) {\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition: Unable to find any object\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectInteger)\n\t\t{\n\t\t\tmLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();\n\n\t\t\t// find and read startxref keyword\n\t\t\tif(!GoBackTillToken())\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tGoBackTillLineStart();\n\t\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\t\tmObjectParser.ResetReadState();\n\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\n\t\t\tif(!startxRef || startxRef->GetValue() != scStartxref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse // this means that the line is not only integer, a bit more complicated path, look for startxref and then the next would be the number\n\t\t{\n\t\t\tbool foundStartXref = (anObject->GetType() == PDFObject::ePDFObjectSymbol) && (((PDFSymbol*)anObject.GetPtr())->GetValue() == scStartxref);\n\n\t\t\twhile(!foundStartXref && mStream->NotEnded())\n\t\t\t{\n\t\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\t\t\t\tfoundStartXref = startxRef.GetPtr() && (startxRef->GetValue() == scStartxref);\n\t\t\t}\n\n\t\t\tif(!foundStartXref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, could not find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefPosition(mObjectParser.ParseNewObject());\n\t\t\tif(!xrefPosition)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmLastXrefPosition = xrefPosition->GetValue();\n\t\t}\n\n\t}while(false);\n\n\treturn status;\n\n}\n\nstatic const std::string scTrailer = \"trailer\";\nEStatusCode PDFParser::ParseTrailerDictionary(PDFDictionary** outTrailer)\n{\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\tbool foundTrailer = false;\n\n\tdo\n\t{\n\t\tPDFParserTokenizer aTokenizer;\n\t\taTokenizer.SetReadStream(mStream);\n\n\t\tdo\n\t\t{\n\t\t\tBoolAndString token = aTokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t\tbreak;\n\t\t\tfoundTrailer = (scTrailer == token.second);\n\t\t}while(!foundTrailer);\n\n\n\t\tif(!foundTrailer)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseTrailerDictionary, trailer not found...\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// k. now that all is well, just parse the damn dictionary, which is actually...the easiest part.\n\t\tmObjectParser.ResetReadState(aTokenizer);\n\t\tPDFObjectCastPtr<PDFDictionary> trailerDictionary(mObjectParser.ParseNewObject());\n\t\tif(!trailerDictionary)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseTrailerDictionary, failure to parse trailer dictionary\");\n\t\t\tbreak;\n\t\t}\n\n\t\ttrailerDictionary->AddRef();\n\t\t*outTrailer = trailerDictionary.GetPtr();\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::BuildXrefTableFromTable()\n{\n\tEStatusCode status;\n\n\tdo\n\t{\n\t\tstatus = DetermineXrefSize();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = InitializeXref();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tbool hasPrev = mTrailer->Exists(\"Prev\");\n\t\tif(hasPrev)\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(mTrailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParseXrefFromXrefTable(mXrefTable,mXrefSize,mLastXrefPosition,!hasPrev, &extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n        // Table may have been extended, in which case replace the pointer and current size\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\n\t\t// For hybrids, check also XRefStm entry\n\t\tPDFObjectCastPtr<PDFInteger> xrefStmReference(mTrailer->QueryDirectObject(\"XRefStm\"));\n\t\tif(!xrefStmReference)\n\t\t\tbreak;\n\t\t// if exists, merge update xref\n\t\tstatus = ParseXrefFromXrefStream(mXrefTable,mXrefSize,xrefStmReference->GetValue(),&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failure to parse xref in hybrid mode\");\n\t\t\tbreak;\n\t\t}\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::DetermineXrefSize()\n{\n\tPDFObjectCastPtr<PDFInteger> aSize(mTrailer->QueryDirectObject(\"Size\"));\n\n\tif(!aSize)\n\t{\n\t\treturn PDFHummus::eFailure;\n\t}\n\telse\n\t{\n\t\tmXrefSize = (ObjectIDType)aSize->GetValue();\n\t\treturn PDFHummus::eSuccess;\n\t}\n}\n\nEStatusCode PDFParser::InitializeXref()\n{\n\tmXrefTable = new XrefEntryInput[mXrefSize];\n\treturn PDFHummus::eSuccess;\n}\n\ntypedef BoxingBaseWithRW<ObjectIDType> ObjectIDTypeBox;\ntypedef BoxingBaseWithRW<unsigned long> ULong;\ntypedef BoxingBaseWithRW<LongFilePositionType> LongFilePositionTypeBox;\n\nstatic const std::string scXref = \"xref\";\nEStatusCode PDFParser::ParseXrefFromXrefTable(XrefEntryInput* inXrefTable,\n                                              ObjectIDType inXrefSize,\n                                              LongFilePositionType inXrefPosition,\n\t\t\t\t\t\t\t\t\t\t\t  bool inIsFirstXref,\n                                              XrefEntryInput** outExtendedTable,\n                                              ObjectIDType* outExtendedTableSize)\n{\n\t// K. cross ref starts at  xref position\n\t// and ends with trailer (or when exahausted the number of objects...whichever first)\n\t// i'm gonna tokanize them, for easier reading\n\tPDFParserTokenizer tokenizer;\n\tBoolAndString token;\n\tEStatusCode status = PDFHummus::eSuccess;\n\tObjectIDType firstNonSectionObject;\n\tByte entry[20];\n\n    *outExtendedTable = NULL;\n\n\ttokenizer.SetReadStream(mStream);\n\tMovePositionInStream(inXrefPosition);\n\n\t// Note that at times, the xref is being read \"on empty\". meaning - entries will be read but they will not affect the actual xref.\n\t// This is done because final xref might be smaller than the prev xrefs, and i'm only interested in objects that are in the final xref.\n\t// That said - i still want to be in the position of the trailer after this function is being executed.\n\n\tdo\n\t{\n\t\t// first token must be \"xref\", so just verify\n\t\ttoken = tokenizer.GetNextToken();\n\t\tif(!token.first || token.second != scXref)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXref, error in parsing xref, expected to find \\\"xref\\\" keyword, found = %s\",token.second.substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tObjectIDType currentObject = 0;\n\n\t\twhile(PDFHummus::eSuccess == status)\n\t\t{\n\t\t\ttoken = tokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXref, failed to read tokens, while reading xref\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// token may be either start of section or \"trailer\"\n\t\t\tif(scTrailer == token.second)\n\t\t\t\tbreak;\n\n\t\t\t// parse segment start\n\t\t\tObjectIDType segmentStart = ObjectIDTypeBox(token.second);\n\t\t\t\n\t\t\t// for first xref (one with no Prev), first object must be 0. some files incorrectly start at 1.\n\t\t\t// this should take care of this, adding extra measure of safety when reading the first xref\n\t\t\tif (currentObject != 0 || !inIsFirstXref)\n\t\t\t\tcurrentObject = segmentStart;\n\t\t\t\n\t\t\ttoken = tokenizer.GetNextToken();\n\t\t\tif(!token.first)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXref, unable to read section size, while reading xref\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// parse segment size\n\t\t\tif(ObjectIDTypeBox(token.second) == 0)\n\t\t\t\tcontinue; // probably will never happen\n\t\t\tfirstNonSectionObject = currentObject + ObjectIDTypeBox(token.second);\n\n            // if the segment declared objects above the xref size, consult policy on what to do\n            if(firstNonSectionObject > inXrefSize && mAllowExtendingSegments)\n            {\n                inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,firstNonSectionObject);\n                inXrefSize = firstNonSectionObject;\n                if(*outExtendedTable)\n                    delete[] *outExtendedTable;\n                *outExtendedTable = inXrefTable;\n                *outExtendedTableSize = firstNonSectionObject;\n            }\n\n\t\t\t// now parse the section.\n\t\t\twhile(currentObject < firstNonSectionObject)\n\t\t\t{\n\t\t\t\tstatus = ReadNextXrefEntry(entry);\n\t\t\t\tif (status != eSuccess)\n\t\t\t\t\tbreak;\n\t\t\t\tif(currentObject < inXrefSize)\n\t\t\t\t{\n\t\t\t\t\tinXrefTable[currentObject].mObjectPosition = LongFilePositionTypeBox(std::string((const char*)entry, 10));\n\t\t\t\t\tinXrefTable[currentObject].mRivision = ULong(std::string((const char*)(entry + 11), 5));\n\t\t\t\t\tinXrefTable[currentObject].mType = entry[17] == 'n' ? eXrefEntryExisting:eXrefEntryDelete;\n\t\t\t\t}\n\t\t\t\t++currentObject;\n\t\t\t}\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t}while(false);\n\tmObjectParser.ResetReadState(tokenizer); // reset with tokenizer in case got extra token.s\n\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadNextXrefEntry(Byte inBuffer[20]) {\n\tEStatusCode status = eSuccess;\n\n\tdo\n\t{\n\t\tif (mStream->Read(inBuffer, 1) != 1)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ReadNextXrefEntry, failed to read xref entry\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t} while (IsPDFWhiteSpace(inBuffer[0]));\n\tif (status != eSuccess)\n\t\treturn status;\n\n\t// now read extra 19\n\tif (mStream->Read(inBuffer + 1, 19) != 19)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ReadNextXrefEntry, failed to read xref entry\");\n\t\tstatus = PDFHummus::eFailure;\n\t}\n\t// set position if the EOL is 1 char instead of 2 (some documents may not follow the standard!)\n\tif ((inBuffer[19] != scLN && inBuffer[19] != scCR) && (inBuffer[18] == scLN || inBuffer[18] == scCR))\n\t{\n\t\tmStream->SetPosition(mStream->GetCurrentPosition() - 1);\n\t}\n\treturn status;\n}\n\nXrefEntryInput* PDFParser::ExtendXrefTableToSize(XrefEntryInput* inXrefTable,ObjectIDType inOldSize,ObjectIDType inNewSize)\n{\n    XrefEntryInput* newTable = new XrefEntryInput[inNewSize];\n\n\tfor(ObjectIDType i = 0; i < inOldSize; ++i)\n        newTable[i] =\tinXrefTable[i];\n    return newTable;\n}\n\nPDFDictionary* PDFParser::GetTrailer()\n{\n\treturn mTrailer.GetPtr();\n}\n\ndouble PDFParser::GetPDFLevel()\n{\n\treturn mPDFLevel;\n}\n\nPDFObject* PDFParser::ParseNewObject(ObjectIDType inObjectId)\n{\n\tif(inObjectId >= mXrefSize)\n\t{\n\t\treturn NULL;\n\t}\n\telse if(eXrefEntryExisting == mXrefTable[inObjectId].mType)\n\t{\n\t\treturn ParseExistingInDirectObject(inObjectId);\n\t}\n\telse if(eXrefEntryStreamObject == mXrefTable[inObjectId].mType)\n\t{\n\t\treturn ParseExistingInDirectStreamObject(inObjectId);\n\t}\n\telse\n\t\treturn NULL;\n}\n\nObjectIDType PDFParser::GetObjectsCount()\n{\n\treturn mXrefSize;\n}\n\nstatic const std::string scObj = \"obj\";\nPDFObject* PDFParser::ParseExistingInDirectObject(ObjectIDType inObjectID)\n{\n\tPDFObject* readObject = NULL;\n\n\tMovePositionInStream(mXrefTable[inObjectID].mObjectPosition);\n\n\tdo\n\t{\n\t\t// should get us to the ObjectNumber ObjectVersion obj section\n\t\t// verify that it's good and if so continue to parse the object itself\n\n\t\t// verify object ID\n\t\tPDFObjectCastPtr<PDFInteger> idObject(mObjectParser.ParseNewObject());\n\n\t\tif(!idObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, ID\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif((ObjectIDType)idObject->GetValue() != inObjectID)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, exepected ID = %ld, found %ld\",\n\t\t\t\tinObjectID,idObject->GetValue());\n\t\t\tbreak;\n\t\t}\n\n\t\t// verify object Version\n\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, Version\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif((unsigned long)versionObject->GetValue() != mXrefTable[inObjectID].mRivision)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, exepected version = %ld, found %ld\",\n\t\t\t\tmXrefTable[inObjectID].mRivision,versionObject->GetValue());\n\t\t\tbreak;\n\t\t}\n\n\t\t// now the obj keyword\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, obj keyword\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectObject, failed to read object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectStart(inObjectID, versionObject->GetValue());\n\t\treadObject = mObjectParser.ParseNewObject();\n\t\tNotifyIndirectObjectEnd(readObject);\n\t}while(false);\n\n\treturn readObject;\n}\n\nEStatusCode PDFParser::SetupDecryptionHelper(const std::string& inPassword) {\n\treturn mDecryptionHelper.Setup(this,inPassword);\n}\n\nEStatusCode PDFParser::ParsePagesObjectIDs()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\t// m.k plan is to look for the catalog, then find the pages, then initialize the array to the count at the root, and then just recursively loop\n\t// the pages by order of pages and fill up the IDs. easy.\n\n\tdo\n\t{\n\t\t// get catalogue, verify indirect reference\n\t\tPDFObjectCastPtr<PDFIndirectObjectReference> catalogReference(mTrailer->QueryDirectObject(\"Root\"));\n\t\tif(!catalogReference)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read catalog reference in trailer\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFDictionary> catalog(ParseNewObject(catalogReference->mObjectID));\n\t\tif(!catalog)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read catalog\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// get pages, verify indirect reference\n\t\tPDFObjectCastPtr<PDFIndirectObjectReference> pagesReference(catalog->QueryDirectObject(\"Pages\"));\n\t\tif(!pagesReference)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages reference in catalog\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFDictionary> pages(ParseNewObject(pagesReference->mObjectID));\n\t\tif(!pages)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> totalPagesCount(QueryDictionaryObject(pages.GetPtr(),\"Count\"));\n\t\tif(!totalPagesCount)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesObjectIDs, failed to read pages count\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tmPagesCount = (unsigned long)totalPagesCount->GetValue();\n\t\tmPagesObjectIDs = new ObjectIDType[mPagesCount];\n\n\t\t// now iterate through pages objects, and fill up the IDs [don't really need the object ID for the root pages tree...but whatever\n\t\tstatus = ParsePagesIDs(pages.GetPtr(),pagesReference->mObjectID);\n\n\t}while(false);\n\n\treturn status;\n}\n\nEStatusCode PDFParser::ParsePagesIDs(PDFDictionary* inPageNode,ObjectIDType inNodeObjectID)\n{\n\tunsigned long currentPageIndex = 0;\n\n\treturn ParsePagesIDs(inPageNode,inNodeObjectID,currentPageIndex);\n}\n\nstatic const std::string scPage = \"Page\";\nstatic const std::string scPages = \"Pages\";\nEStatusCode PDFParser::ParsePagesIDs(PDFDictionary* inPageNode,ObjectIDType inNodeObjectID,unsigned long& ioCurrentPageIndex)\n{\n\t// recursion.\n\t// if this is a page, write it's node object ID in the current page index and +1\n\t// if this is a pagetree, loop it's kids, for each parsing the kid, running the recursion on it, and deleting\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\t\tPDFObjectCastPtr<PDFName> objectType(inPageNode->QueryDirectObject(\"Type\"));\n\t\tif(!objectType)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, can't read object type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(scPage == objectType->GetValue())\n\t\t{\n\t\t\t// a Page\n\t\t\tif(ioCurrentPageIndex >= mPagesCount)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, there are more pages than the page count specifies. fail.\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmPagesObjectIDs[ioCurrentPageIndex] = inNodeObjectID;\n\t\t\t++ioCurrentPageIndex;\n\t\t}\n\t\telse if(scPages == objectType->GetValue())\n\t\t{\n\t\t\t// a Page tree node\n\t\t\tPDFObject* pKids= inPageNode->QueryDirectObject(\"Kids\");\n\t\t\tif (pKids && pKids->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t\t\t\tpKids= ParseNewObject(((PDFIndirectObjectReference*)pKids)->mObjectID);\n\t\t\tPDFObjectCastPtr<PDFArray> kidsObject(pKids);\n\t\t\tif(!kidsObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, unable to find page kids array\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSingleValueContainerIterator<PDFObjectVector> it = kidsObject->GetIterator();\n\n\t\t\twhile(it.MoveNext() && PDFHummus::eSuccess == status)\n\t\t\t{\n\t\t\t\tif (it.GetItem()->GetType() == PDFObject::ePDFObjectNull) {\n\t\t\t\t\t// null pointer. mark as empty page\n\t\t\t\t\tmPagesObjectIDs[ioCurrentPageIndex] = 0;\n\t\t\t\t\t++ioCurrentPageIndex;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(it.GetItem()->GetType() != PDFObject::ePDFObjectIndirectObjectReference)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG1(\"PDFParser::ParsePagesIDs, unexpected type for a Kids array object, type = %s\",PDFObject::scPDFObjectTypeLabel(it.GetItem()->GetType()));\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPDFObjectCastPtr<PDFDictionary> pageNodeObject(ParseNewObject(((PDFIndirectObjectReference*)it.GetItem())->mObjectID));\n\t\t\t\tif(!pageNodeObject)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParsePagesIDs, unable to parse page node object from kids reference\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstatus = ParsePagesIDs(pageNodeObject.GetPtr(),((PDFIndirectObjectReference*)it.GetItem())->mObjectID,ioCurrentPageIndex);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParsePagesIDs, unexpected object type. should be either Page or Pages, found %s\",objectType->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t}while(false);\n\n\treturn status;\n}\n\nunsigned long  PDFParser::GetPagesCount()\n{\n\treturn mPagesCount;\n}\n\nObjectIDType PDFParser::GetPageObjectID(unsigned long inPageIndex)\n{\n\tif(mPagesCount <= inPageIndex)\n\t\treturn 0;\n\n\treturn mPagesObjectIDs[inPageIndex];\n}\n\n\nPDFDictionary* PDFParser::ParsePage(unsigned long inPageIndex)\n{\n\tif(mPagesCount <= inPageIndex)\n\t\treturn NULL;\n\n\tif (mPagesObjectIDs[inPageIndex] == 0) {\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, page marked as null at index %ld\", inPageIndex);\n\t\treturn NULL;\n\t}\n\n\tPDFObjectCastPtr<PDFDictionary> pageObject(ParseNewObject(mPagesObjectIDs[inPageIndex]));\n\n\tif(!pageObject)\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, couldn't find page object for index %ld\",inPageIndex);\n\t\treturn NULL;\n\t}\n\n\tPDFObjectCastPtr<PDFName> objectType(pageObject->QueryDirectObject(\"Type\"));\n\n\tif(scPage == objectType->GetValue())\n\t{\n\t\tpageObject->AddRef();\n\t\treturn pageObject.GetPtr();\n\t}\n\telse\n\t{\n\t\tTRACE_LOG1(\"PDFParser::ParsePage, page object listed in page array for %ld is actually not a page\",inPageIndex);\n\t\treturn NULL;\n\t}\n}\n\nPDFObject* PDFParser::QueryDictionaryObject(PDFDictionary* inDictionary,const std::string& inName)\n{\n\tRefCountPtr<PDFObject> anObject(inDictionary->QueryDirectObject(inName));\n\n\tif(anObject.GetPtr() == NULL)\n\t\treturn NULL;\n\n\tif(anObject->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t{\n\t\tPDFObject* theActualObject = ParseNewObject(((PDFIndirectObjectReference*)anObject.GetPtr())->mObjectID);\n\t\treturn theActualObject;\n\t}\n\telse\n\t{\n\t\tanObject->AddRef(); // adding ref to increase owners\n\t\treturn anObject.GetPtr();\n\t}\n}\n\nPDFObject* PDFParser::QueryArrayObject(PDFArray* inArray,unsigned long inIndex)\n{\n\tRefCountPtr<PDFObject> anObject(inArray->QueryObject(inIndex));\n\n\tif(anObject.GetPtr() == NULL)\n\t\treturn NULL;\n\n\tif(anObject->GetType() == PDFObject::ePDFObjectIndirectObjectReference)\n\t{\n\t\tPDFObject* theActualObject = ParseNewObject(((PDFIndirectObjectReference*)anObject.GetPtr())->mObjectID);\n\t\treturn theActualObject;\n\t}\n\telse\n\t{\n\t\tanObject->AddRef(); // adding ref to increase owners\n\t\treturn anObject.GetPtr();\n\t}\n\n}\n\nEStatusCode PDFParser::ParsePreviousXrefs(PDFDictionary* inTrailer)\n{\n\tPDFObjectCastPtr<PDFInteger> previousPosition(inTrailer->QueryDirectObject(\"Prev\"));\n\tif(!previousPosition)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ParsePreviousXrefs, unexpected, prev is not integer\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tEStatusCode status;\n\n\tXrefEntryInput* aTable = new XrefEntryInput[mXrefSize];\n\tdo\n\t{\n\t\tPDFDictionary* trailerP = NULL;\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParsePreviousFileDirectory(previousPosition->GetValue(),aTable,mXrefSize,&trailerP,&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tRefCountPtr<PDFDictionary> trailer(trailerP);\n\n\t\tif(trailer->Exists(\"Prev\"))\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(trailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n\n        // Table may have been extended, in which case replace the pointer and current size\n        ObjectIDType newTableSize;\n        if(extendedTable)\n        {\n            newTableSize = extendedTableSize;\n            delete[] aTable;\n            aTable = extendedTable;\n        }\n        else\n            newTableSize = mXrefSize;\n        MergeXrefWithMainXref(aTable,newTableSize);\n\t}\n\twhile(false);\n\n\tdelete[] aTable;\n\treturn status;\n}\n\nEStatusCode PDFParser::ParsePreviousFileDirectory(LongFilePositionType inXrefPosition,\n\t\t\t\t\t\t\t\t\t  XrefEntryInput* inXrefTable,\n\t\t\t\t\t\t\t\t\t  ObjectIDType inXrefSize,\n\t\t\t\t\t\t\t\t\t  PDFDictionary** outTrailer,\n                                      XrefEntryInput** outExtendedTable,\n                                      ObjectIDType* outExtendedTableSize)\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tMovePositionInStream(inXrefPosition);\n\n\tdo\n\t{\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectSymbol && ((PDFSymbol*)anObject.GetPtr())->GetValue() == scXref)\n\t\t{\n\t\t\t// xref table case\n\n\t\t\t// Parsing trailer. this is not really necessary at this point, but for faulty PDFs which first xref may incorrectly skip 0 entry.\n\t\t\t// A simple correction is possible, but it is required to know whether the to-be-parsed xref is the first one, or not.\n\t\t\tPDFDictionary* trailerDictionary = NULL;\n\t\t\tstatus = ParseTrailerDictionary(&trailerDictionary);\n\t\t\tif (status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\n\t\t\tbool hasPrev = trailerDictionary->Exists(\"Prev\");\n\n\t\t\tstatus = ParseXrefFromXrefTable(inXrefTable,inXrefSize,inXrefPosition,!hasPrev,outExtendedTable,outExtendedTableSize);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::ParseDirectory, failed to parse xref table in %ld\",inXrefPosition);\n\t\t\t\tbreak;\n\t\t\t}\n\n            if(*outExtendedTable)\n            {\n                inXrefTable = *outExtendedTable;\n                inXrefSize = *outExtendedTableSize;\n            }\n\n\n\t\t\t// For hybrids, check also XRefStm entry\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefStmReference(trailerDictionary->QueryDirectObject(\"XRefStm\"));\n\t\t\tif(xrefStmReference.GetPtr())\n\t\t\t{\n\t\t\t\t// if exists, merge update xref\n\t\t\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStmReference->GetValue(),outExtendedTable,outExtendedTableSize);\n\t\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failure to parse xref in hybrid mode\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*outTrailer = trailerDictionary;\n\t\t}\n\t\telse if(anObject->GetType() == PDFObject::ePDFObjectInteger && ((PDFInteger*)anObject.GetPtr())->GetValue() > 0)\n\t\t{\n\t\t\t// Xref stream case. make some validations, grab the xref stream object details, and parse it\n\n\t\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\t\tif(!versionObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failed to read xref object declaration, Version\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\t\tif(!objKeyword)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory, failed to read xref object declaration, obj keyword\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(objKeyword->GetValue() != scObj)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::ParseDirectory, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNotifyIndirectObjectStart(((PDFInteger*)anObject.GetPtr())->GetValue(), versionObject->GetValue());\n\n\t\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\t\tif(!xrefStream)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failure to parse xref stream\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\t\t*outTrailer = xrefStream->QueryStreamDictionary();\n\n\t\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStream.GetPtr(),outExtendedTable,outExtendedTableSize);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseDirectory,Unexpected object at xref start\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t}\n\t}while(false);\n\treturn status;\n}\n\nvoid PDFParser::MergeXrefWithMainXref(XrefEntryInput* inTableToMerge,ObjectIDType inMergedTableSize)\n{\n    if(inMergedTableSize > mXrefSize)\n    {\n        XrefEntryInput* newTable = ExtendXrefTableToSize(mXrefTable, mXrefSize, inMergedTableSize);\n        mXrefSize = inMergedTableSize;\n        delete[] mXrefTable;\n        mXrefTable = newTable;\n    }\n\n\tfor(ObjectIDType i = 0; i < mXrefSize; ++i)\n\t{\n\t\tif(inTableToMerge[i].mType != eXrefEntryUndefined)\n\t\t\tmXrefTable[i] =\tinTableToMerge[i];\n\t}\n}\n\n\nEStatusCode PDFParser::ParseFileDirectory()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\n\tMovePositionInStream(mLastXrefPosition);\n\n\tdo\n\t{\n\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectSymbol && ((PDFSymbol*)anObject.GetPtr())->GetValue() == scXref)\n\t\t{\n\t\t\t// this would be a normal xref case\n\t\t\t// jump lines till you get to a line where the token is \"trailer\". then parse.\n\t\t\tPDFDictionary* trailerP = NULL;\n\t\t\tstatus = ParseTrailerDictionary(&trailerP);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t\tRefCountPtr<PDFDictionary> trailer(trailerP); // this should take care of the internally added ref...minor technicality\n\t\t\tmTrailer = trailer;\n\n\t\t\tstatus = BuildXrefTableFromTable();\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if(anObject->GetType() == PDFObject::ePDFObjectInteger && ((PDFInteger*)anObject.GetPtr())->GetValue() > 0)\n\t\t{\n\t\t\t// Xref stream case\n\t\t\tstatus = BuildXrefTableAndTrailerFromXrefStream(((PDFInteger*)anObject.GetPtr())->GetValue());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseFileDirectory,Unexpected object at xref start\");\n\t\t\tstatus = eFailure;\n\t\t}\n\n\n\t}while(false);\n\n\n\n\treturn status;\n}\n\nEStatusCode PDFParser::BuildXrefTableAndTrailerFromXrefStream(long long inXrefStreamObjectID)\n{\n\t// xref stream is trailer and stream togather. need to parse them both.\n\t// the object parser is now after the object ID. so verify that next we goot a version and the obj keyword\n\t// then parse the xref stream\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\tdo\n\t{\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, Version\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, obj keyword\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// k. now just parse the object which should be a stream\n\n\t\tNotifyIndirectObjectStart(inXrefStreamObjectID, versionObject->GetValue());\n\n\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\tif(!xrefStream)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::BuildXrefTableAndTrailerFromXrefStream, failure to parse xref stream\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\tRefCountPtr<PDFDictionary> xrefDictionary(xrefStream->QueryStreamDictionary());\n\t\tmTrailer = xrefDictionary;\n\n\t\tstatus = DetermineXrefSize();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = InitializeXref();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(mTrailer->Exists(\"Prev\"))\n\t\t{\n\t\t\tstatus = ParsePreviousXrefs(mTrailer.GetPtr());\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        XrefEntryInput* extendedTable = NULL;\n        ObjectIDType extendedTableSize;\n\t\tstatus = ParseXrefFromXrefStream(mXrefTable,mXrefSize,xrefStream.GetPtr(),&extendedTable,&extendedTableSize);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n        // Table may have been extended, in which case replace the pointer and current size\n        if(extendedTable)\n        {\n            mXrefSize = extendedTableSize;\n            delete[] mXrefTable;\n            mXrefTable = extendedTable;\n        }\n\n\t}while(false);\n\n\treturn status;\n\n}\n\nEStatusCode PDFParser::ParseXrefFromXrefStream(XrefEntryInput* inXrefTable,\n                                               ObjectIDType inXrefSize,\n                                               LongFilePositionType inXrefPosition,\n                                               XrefEntryInput** outExtendedTable,\n                                               ObjectIDType* outExtendedTableSize)\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tMovePositionInStream(inXrefPosition);\n\n\tdo\n\t{\n\t\t// take the object, so that we can check whether this is an Xref or an Xref stream\n\t\tPDFObjectCastPtr<PDFInteger> anObject(mObjectParser.ParseNewObject());\n\t\tif(!anObject || anObject->GetValue() <= 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXrefFromXrefStream, expecting object number for xref stream at %ld\",inXrefPosition);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> versionObject(mObjectParser.ParseNewObject());\n\n\t\tif(!versionObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, Version\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectStart(anObject->GetValue(), versionObject->GetValue());\n\n\t\tPDFObjectCastPtr<PDFSymbol> objKeyword(mObjectParser.ParseNewObject());\n\n\t\tif(!objKeyword)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, obj keyword\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(objKeyword->GetValue() != scObj)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseXrefFromXrefStream, failed to read xref object declaration, expected obj keyword found %s\",\n\t\t\t\tobjKeyword->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFStreamInput> xrefStream(mObjectParser.ParseNewObject());\n\t\tif(!xrefStream)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, failure to parse xref stream\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tNotifyIndirectObjectEnd(xrefStream.GetPtr());\n\n\t\tstatus = ParseXrefFromXrefStream(inXrefTable,inXrefSize,xrefStream.GetPtr(),outExtendedTable,outExtendedTableSize);\n\t}while(false);\n\treturn status;\n}\n\nEStatusCode PDFParser::ParseXrefFromXrefStream(XrefEntryInput* inXrefTable,\n                                               ObjectIDType inXrefSize,\n                                               PDFStreamInput* inXrefStream,\n                                               XrefEntryInput** outExtendedTable,\n                                               ObjectIDType* outExtendedTableSize)\n{\n\t// 1. Setup the stream to read from the stream start location\n\t// 2. Set it up with an input stream to decode if required\n\t// 3. if there are subsections, loop them, otherwise assume a single section of 0..size\n\t// 4. for each subsection use the base number as starting, and count as well, to read the stream entries to the right position in the table\n\t//    The entries are read using the \"W\" value. make sure to read even values that you don't need.\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\n    outExtendedTable = NULL;\n\n\tIByteReader* xrefStreamSource = CreateInputStreamReader(inXrefStream);\n\tint* widthsArray = NULL;\n\n\tdo\n\t{\n\t\tif(!xrefStreamSource)\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tRefCountPtr<PDFDictionary> streamDictionary(inXrefStream->QueryStreamDictionary());\n\n\t\t// setup w array\n\t\tPDFObjectCastPtr<PDFArray> wArray(QueryDictionaryObject(streamDictionary.GetPtr(),\"W\"));\n\t\tif(!wArray)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, W array not available. failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\twidthsArray = new int[wArray->GetLength()];\n\t\tfor(unsigned long i=0;i <wArray->GetLength();++i)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFInteger> widthObject(wArray->QueryObject(i));\n\t\t\tif(!widthObject)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, wrong items in width array (supposed to have only integers)\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidthsArray[i] = (int)widthObject->GetValue();\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\t// read the segments from the stream\n\t\tPDFObjectCastPtr<PDFArray> subsectionsIndex(QueryDictionaryObject(streamDictionary.GetPtr(),\"Index\"));\n\t\tMovePositionInStream(inXrefStream->GetStreamContentStart());\n\n\t\tif(!subsectionsIndex)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefSize(QueryDictionaryObject(streamDictionary.GetPtr(),\"Size\"));\n\t\t\tif(!xrefSize)\n\t\t\t{\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, xref size does not exist for this stream\");\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\n            // if reading objects past expected range interesting consult policy\n            ObjectIDType readXrefSize = (ObjectIDType)xrefSize->GetValue();\n            if(readXrefSize > inXrefSize)\n            {\n                if(mAllowExtendingSegments)\n                {\n                    inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,readXrefSize);\n                    inXrefSize = readXrefSize;\n                    if(*outExtendedTable)\n                        delete[] *outExtendedTable;\n                    *outExtendedTable = inXrefTable;\n                    *outExtendedTableSize = readXrefSize;\n                }\n                else\n                    break;\n            }\n\t\t\tstatus = ReadXrefStreamSegment(inXrefTable,0,readXrefSize,xrefStreamSource,widthsArray,wArray->GetLength());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSingleValueContainerIterator<PDFObjectVector> segmentsIterator  = subsectionsIndex->GetIterator();\n\t\t\tPDFObjectCastPtr<PDFInteger> segmentValue;\n\t\t\twhile(segmentsIterator.MoveNext() && PDFHummus::eSuccess == status)\n\t\t\t{\n\t\t\t\tsegmentValue = segmentsIterator.GetItem();\n\t\t\t\tif(!segmentValue)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, found non integer value in Index array of xref stream\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tObjectIDType startObject = (ObjectIDType)segmentValue->GetValue();\n\t\t\t\tif(!segmentsIterator.MoveNext())\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream,Index array of xref stream should have an even number of values\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsegmentValue = segmentsIterator.GetItem();\n\t\t\t\tif(!segmentValue)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefFromXrefStream, found non integer value in Index array of xref stream\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tObjectIDType objectsCount = (ObjectIDType)segmentValue->GetValue();\n\t\t\t\t// if reading objects past expected range interesting consult policy\n\t\t\t\tif(startObject +  objectsCount > inXrefSize)\n                {\n                    if(mAllowExtendingSegments)\n                    {\n                        inXrefTable = ExtendXrefTableToSize(inXrefTable,inXrefSize,startObject +  objectsCount);\n                        inXrefSize = startObject +  objectsCount;\n                        if(*outExtendedTable)\n                            delete[] *outExtendedTable;\n                        *outExtendedTable = inXrefTable;\n                        *outExtendedTableSize = startObject +  objectsCount;\n                    }\n                    else\n                        break;\n                }\n\t\t\t\tstatus = ReadXrefStreamSegment(inXrefTable,startObject,std::min<ObjectIDType>(objectsCount,inXrefSize - startObject),xrefStreamSource,widthsArray,wArray->GetLength());\n\t\t\t}\n\t\t}\n\t}while(false);\n\n\tdelete xrefStreamSource;\n\tdelete[] widthsArray;\n\treturn status;\n}\n\nvoid PDFParser::MovePositionInStream(LongFilePositionType inPosition)\n{\n\tmStream->SetPosition(inPosition);\n\tmObjectParser.ResetReadState();\n}\n\nEStatusCode PDFParser::ReadXrefStreamSegment(XrefEntryInput* inXrefTable,\n\t\t\t\t\t\t\t\t\t\t\t ObjectIDType inSegmentStartObject,\n\t\t\t\t\t\t\t\t\t\t\t ObjectIDType inSegmentCount,\n\t\t\t\t\t\t\t\t\t\t\t IByteReader* inReadFrom,\n\t\t\t\t\t\t\t\t\t\t\t int* inEntryWidths,\n\t\t\t\t\t\t\t\t\t\t\t unsigned long inEntryWidthsSize)\n{\n\tObjectIDType objectToRead = inSegmentStartObject;\n\tEStatusCode status = PDFHummus::eSuccess;\n\tif(inEntryWidthsSize != 3)\n\t{\n\t\tTRACE_LOG(\"PDFParser::ReadXrefStreamSegment, can handle only 3 length entries\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\t// Note - i'm also checking that the stream is not ended. in non-finite segments, it could be that the particular\n\t// stream does no define all objects...just the \"updated\" ones\n\tfor(; (objectToRead < inSegmentStartObject + inSegmentCount) && PDFHummus::eSuccess == status && inReadFrom->NotEnded();++objectToRead)\n\t{\n\t\tlong long entryType;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[0],entryType);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[1],inXrefTable[objectToRead].mObjectPosition);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\t\tstatus = ReadXrefSegmentValue(inReadFrom,inEntryWidths[2],inXrefTable[objectToRead].mRivision);\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(0 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryDelete;\n\t\t}\n\t\telse if (1 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryExisting;\n\t\t}\n\t\telse if(2 == entryType)\n\t\t{\n\t\t\tinXrefTable[objectToRead].mType = eXrefEntryStreamObject;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ReadXrefStreamSegment, unfamiliar entry type. must be either 0,1 or 2\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t}\n\t}\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadXrefSegmentValue(IByteReader* inSource,int inEntrySize,long long& outValue)\n{\n\toutValue = 0;\n\tByte buffer;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tfor(int i=0;i<inEntrySize && PDFHummus::eSuccess == status;++i)\n\t{\n\t\tstatus = (inSource->Read(&buffer,1) == 1 ? PDFHummus::eSuccess : PDFHummus::eFailure);\n\t\tif(status != PDFHummus::eFailure)\n\t\t\toutValue = (outValue<<8) + buffer;\n\t}\n\treturn status;\n}\n\nEStatusCode PDFParser::ReadXrefSegmentValue(IByteReader* inSource,int inEntrySize,ObjectIDType& outValue)\n{\n\toutValue = 0;\n\tByte buffer;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tfor(int i=0;i<inEntrySize && PDFHummus::eSuccess == status;++i)\n\t{\n\t\tstatus = (inSource->Read(&buffer,1) == 1 ? PDFHummus::eSuccess : PDFHummus::eFailure);\n\t\tif(status != PDFHummus::eFailure)\n\t\t\toutValue = (outValue<<8) + buffer;\n\t}\n\treturn status;\n}\n\nPDFObject* PDFParser::ParseExistingInDirectStreamObject(ObjectIDType inObjectId)\n{\n\t// parsing an object in an object stream requires the following:\n\t// 1. Setting the position to this object stream\n\t// 2. Reading the stream First and N. store.\n\t// 3. Creating a stream reader for the initial stream position and length, possibly decoding with flate\n\t// 4. Read the stream header. store.\n\t// 5. Jump to the right object position (or decode till its position)\n\t// 6. Read the object\n\n\tEStatusCode status = PDFHummus::eSuccess;\n\tObjectStreamHeaderEntry* objectStreamHeader;\n\tIByteReader* objectSource = NULL;\n\n\tInputStreamSkipperStream skipperStream;\n\tObjectIDType objectStreamID;\n\tPDFObject* anObject = NULL;\n\n\tdo\n\t{\n\t\tobjectStreamID = (ObjectIDType)mXrefTable[inObjectId].mObjectPosition;\n\t\tPDFObjectCastPtr<PDFStreamInput> objectStream(ParseNewObject(objectStreamID));\n\t\tif(!objectStream)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseExistingInDirectStreamObject, failed to parse object %ld. failed to find object stream for it, which should be %ld\",\n\t\t\t\t\t\tinObjectId,mXrefTable[inObjectId].mObjectPosition);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tRefCountPtr<PDFDictionary> streamDictionary(objectStream->QueryStreamDictionary());\n\n\t\tPDFObjectCastPtr<PDFInteger> streamObjectsCount(QueryDictionaryObject(streamDictionary.GetPtr(),\"N\"));\n\t\tif(!streamObjectsCount)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectStreamObject, no N key in stream dictionary %ld\",objectStreamID);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tObjectIDType objectsCount = (ObjectIDType)streamObjectsCount->GetValue();\n\n\t\tPDFObjectCastPtr<PDFInteger> firstStreamObjectPosition(QueryDictionaryObject(streamDictionary.GetPtr(),\"First\"));\n\t\tif(!streamObjectsCount)\n\t\t{\n\t\t\tTRACE_LOG1(\"PDFParser::ParseExistingInDirectStreamObject, no First key in stream dictionary %ld\",objectStreamID);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectSource = CreateInputStreamReader(objectStream.GetPtr());\n\t\tskipperStream.Assign(objectSource);\n\t\tMovePositionInStream(objectStream->GetStreamContentStart());\n\n\t\tmObjectParser.SetReadStream(&skipperStream,&skipperStream);\n\n\t\tObjectIDTypeToObjectStreamHeaderEntryMap::iterator it = mObjectStreamsCache.find(objectStreamID);\n\n\t\tif(it == mObjectStreamsCache.end())\n\t\t{\n\t\t\tobjectStreamHeader = new ObjectStreamHeaderEntry[objectsCount];\n\t\t\tstatus = ParseObjectStreamHeader(objectStreamHeader,objectsCount);\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t{\n\t\t\t\tdelete[] objectStreamHeader;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit = mObjectStreamsCache.insert(ObjectIDTypeToObjectStreamHeaderEntryMap::value_type(objectStreamID,objectStreamHeader)).first;\n\t\t}\n\t\tobjectStreamHeader = it->second;\n\n\t\t// verify that i got the right object ID\n\t\tif(objectsCount <= mXrefTable[inObjectId].mRivision || objectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectNumber != inObjectId)\n\t\t{\n\t\t\tTRACE_LOG2(\"PDFParser::ParseXrefFromXrefStream, wrong object. expecting to find object ID %ld, and found %ld\",\n\t\t\t\t\t\tinObjectId,\n\t\t\t\t\t\tobjectsCount <= mXrefTable[inObjectId].mRivision ?\n\t\t\t\t\t\t\t-1 :\n\t\t\t\t\t\t\tobjectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectNumber);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\t// when parsing the header, should be at position already..so don't skip if already there [using GetCurrentPosition to see if parsed some]\n\t\tif(mXrefTable[inObjectId].mRivision != 0 || skipperStream.GetCurrentPosition() == 0)\n\t\t{\n\t\t\tLongFilePositionType objectPositionInStream = objectStreamHeader[mXrefTable[inObjectId].mRivision].mObjectOffset +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  firstStreamObjectPosition->GetValue();\n\t\t\tskipperStream.SkipTo(objectPositionInStream);\n\t\t\tmObjectParser.ResetReadState();\n\t\t}\n\n\t\tmDecryptionHelper.PauseDecryption(); // objects within objects stream already enjoy the object stream protection, and so are no longer encrypted\n\t\tNotifyIndirectObjectStart(inObjectId,0);\n\t\tanObject = mObjectParser.ParseNewObject();\n\t\tNotifyIndirectObjectEnd(anObject);\n\t\tmDecryptionHelper.ReleaseDecryption();\n\n\t}while(false);\n\n\tmObjectParser.SetReadStream(mStream,&mCurrentPositionProvider);\n\n\treturn anObject;\n}\n\nvoid PDFParser::NotifyIndirectObjectStart(long long inObjectID, long long inGenerationNumber) {\n\tif (mParserExtender)\n\t\tmParserExtender->OnObjectStart(inObjectID, inGenerationNumber);\n\n\tmDecryptionHelper.OnObjectStart(inObjectID, inGenerationNumber);\n}\n\nvoid PDFParser::NotifyIndirectObjectEnd(PDFObject* inObject) {\n\tif (mParserExtender)\n\t\tmParserExtender->OnObjectEnd(inObject);\n\n\tmDecryptionHelper.OnObjectEnd(inObject);\n\n}\n\n\nEStatusCode PDFParser::ParseObjectStreamHeader(ObjectStreamHeaderEntry* inHeaderInfo,ObjectIDType inObjectsCount)\n{\n\tObjectIDType currentObject = 0;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\twhile(currentObject < inObjectsCount && (PDFHummus::eSuccess == status))\n\t{\n\t\tPDFObjectCastPtr<PDFInteger> objectNumber(mObjectParser.ParseNewObject());\n\t\tif(!objectNumber)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseObjectStreamHeader, parsing failed when reading object number. either not enough objects, or of the wrong type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tPDFObjectCastPtr<PDFInteger> objectPosition(mObjectParser.ParseNewObject());\n\t\tif(!objectPosition)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::ParseObjectStreamHeader, parsing failed when reading object position. either not enough objects, or of the wrong type\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tinHeaderInfo[currentObject].mObjectNumber = (ObjectIDType)(objectNumber->GetValue());\n\t\tinHeaderInfo[currentObject].mObjectOffset = objectPosition->GetValue();\n\t\t++currentObject;\n\t}\n\treturn status;\n}\n\nIByteReader* PDFParser::WrapWithDecryptionFilter(PDFStreamInput* inStream, IByteReader* inToWrapStream) {\n\tif (IsEncrypted() && IsEncryptionSupported()) {\n\t\t// try with decryption helper\n\t\tIByteReader*  result = \tmDecryptionHelper.CreateDefaultDecryptionFilterForStream(inStream, inToWrapStream);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\t// try with extender\n\t\tif(mParserExtender)\n\t\t\tresult = mParserExtender->CreateDefaultDecryptionFilterForStream(inStream, inToWrapStream);\n\n\t\tif (result)\n\t\t\treturn result;\n\t\telse\n\t\t\treturn inToWrapStream;\n\t}\n\telse {\n\t\treturn inToWrapStream;\n\t}\n}\n\nIByteReader* PDFParser::CreateInputStreamReader(PDFStreamInput* inStream)\n{\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tIByteReader* result = NULL;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\n\t\t// setup stream according to length and possible filter\n\t\tPDFObjectCastPtr<PDFInteger> lengthObject(QueryDictionaryObject(streamDictionary.GetPtr(),\"Length\"));\n\t\tif(!lengthObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, stream does not have length, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = new InputLimitedStream(mStream,lengthObject->GetValue(),false);\n\n\t\tresult = WrapWithDecryptionFilter(inStream,result);\n\n\t\tRefCountPtr<PDFObject> filterObject(QueryDictionaryObject(streamDictionary.GetPtr(),\"Filter\"));\n\t\tif(!filterObject)\n\t\t{\n\t\t\t// no filter, so stop here\n\t\t\tbreak;\n\t\t}\n\n\t\tif(filterObject->GetType() == PDFObject::ePDFObjectArray)\n\t\t{\n\t\t\tPDFArray* filterObjectArray = (PDFArray*)filterObject.GetPtr();\n\t\t\tPDFObjectCastPtr<PDFArray> decodeParams(QueryDictionaryObject(streamDictionary.GetPtr(),\"DecodeParms\"));\n\t\t\tfor(unsigned long i=0; i < filterObjectArray->GetLength() && eSuccess == status;++i)\n\t\t\t{\n\t\t\t\tPDFObjectCastPtr<PDFName> filterObjectItem(filterObjectArray->QueryObject(i));\n\t\t\t\tif(!filterObjectItem)\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, filter item in an array is not a name. should be a name\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tEStatusCodeAndIByteReader createStatus;\n\t\t\t\tif(!decodeParams)\n\t\t\t\t{\n\t\t\t\t\t createStatus = CreateFilterForStream(result,filterObjectItem.GetPtr(), NULL, inStream);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPDFObjectCastPtr<PDFDictionary> decodeParamsItem(QueryArrayObject(decodeParams.GetPtr(),i));\n\n\t\t\t\t\tcreateStatus = CreateFilterForStream(result,(PDFName*)filterObject.GetPtr(), !decodeParamsItem ? NULL: decodeParamsItem.GetPtr(), inStream);\n\t\t\t\t}\n\n\t\t\t\tif(createStatus.first != eSuccess)\n\t\t\t\t{\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresult = createStatus.second;\n\t\t\t}\n\t\t}\n\t\telse if(filterObject->GetType() == PDFObject::ePDFObjectName)\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFDictionary> decodeParams(QueryDictionaryObject(streamDictionary.GetPtr(),\"DecodeParms\"));\n\n\t\t\tEStatusCodeAndIByteReader createStatus = CreateFilterForStream(result,(PDFName*)filterObject.GetPtr(), !decodeParams ? NULL: decodeParams.GetPtr(), inStream);\n\t\t\tif(createStatus.first != eSuccess)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult = createStatus.second;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReader, filter parameter is of unkown type. only array and name are supported.\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t}while(false);\n\n\n\tif(status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn result;\n}\n\nEStatusCodeAndIByteReader PDFParser::CreateFilterForStream(IByteReader* inStream,PDFName* inFilterName,PDFDictionary* inDecodeParams, PDFStreamInput* inPDFStream)\n{\n\tEStatusCode status = eSuccess;\n\tIByteReader* result = NULL;\n\n\tdo\n\t{\n\n\t\tif(inFilterName->GetValue() == \"FlateDecode\" || inFilterName->GetValue() == \"LZWDecode\")\n\t\t{\n\t\t\tif (inFilterName->GetValue() == \"FlateDecode\")\n\t\t\t{\n\t\t\t\tInputFlateDecodeStream* flateStream;\n\t\t\t\tflateStream = new InputFlateDecodeStream(NULL); // assigning null, so later delete, if failure occurs won't delete the input stream\n\t\t\t\tflateStream->Assign(inStream);\n\t\t\t\tresult = flateStream;\n\t\t\t}\n\t\t\telse if (inFilterName->GetValue() == \"LZWDecode\")\n\t\t\t{\n\t\t\t\tInputLZWDecodeStream* lzwStream;\n\t\t\t\tint early = 1;\n\t\t\t\tif (inDecodeParams)\n\t\t\t\t{\n\t\t\t\t\tPDFObjectCastPtr<PDFInteger> earlyObj(QueryDictionaryObject(inDecodeParams, \"EarlyChange\"));\n\t\t\t\t\tearly = earlyObj->GetValue();\n\t\t\t\t}\n\t\t\t\tlzwStream = new InputLZWDecodeStream(early);\n\t\t\t\tlzwStream->Assign(inStream);\n\t\t\t\tresult = lzwStream;\n\t\t\t}\n\n\t\t\t// check for predictor n' such\n\t\t\tif (!inDecodeParams)\n\t\t\t\t// no predictor, stop here\n\t\t\t\tbreak;\t\t\t\n\n\t\t\t// read predictor, and apply the relevant predictor function\n\t\t\tPDFObjectCastPtr<PDFInteger> predictor(QueryDictionaryObject(inDecodeParams,\"Predictor\"));\n\n\t\t\tif(!predictor || predictor->GetValue() == 1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFInteger> columns(QueryDictionaryObject(inDecodeParams,\"Columns\"));\n\t\t\tPDFObjectCastPtr<PDFInteger> colors(QueryDictionaryObject(inDecodeParams,\"Colors\"));\n\t\t\tPDFObjectCastPtr<PDFInteger> bitsPerComponent(QueryDictionaryObject(inDecodeParams,\"BitsPerComponent\"));\n\t\t\tLongBufferSizeType columnsValue = columns.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)columns->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1;\n\t\t\tLongBufferSizeType colorsValue = colors.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)colors->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1;\n\t\t\tLongBufferSizeType bitsPerComponentValue = bitsPerComponent.GetPtr() ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(IOBasicTypes::LongBufferSizeType)bitsPerComponent->GetValue() :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t8;\n\n\t\t\tswitch(predictor->GetValue())\n\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tresult = new InputPredictorTIFFSubStream(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t colorsValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitsPerComponentValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnsValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 10:\n\t\t\t\tcase 11:\n\t\t\t\tcase 12:\n\t\t\t\tcase 13:\n\t\t\t\tcase 14:\n\t\t\t\tcase 15:\n\t\t\t\t{\n\t\t\t\t\t// Gal: optimum can handle all presets, because non-optimum presets still require a function sign flag\n\t\t\t\t\t// at line start...so optimum can handle them.\n\t\t\t\t\tresult =  new InputPredictorPNGOptimumStream(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t colorsValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitsPerComponentValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnsValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG(\"PDFParser::CreateFilterForStream, supporting only predictor of types 1,2,10,11,12,13,14,15, failing\");\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (inFilterName->GetValue() == \"ASCIIHexDecode\")\n\t\t{\n\t\t\tresult = new InputAsciiHexDecodeStream(inStream);\n\t\t}\n\t\telse if(inFilterName->GetValue() == \"ASCII85Decode\")\n\t\t{\n\t\t\tresult = new InputAscii85DecodeStream(inStream);\n\t\t}\n#ifndef PDFHUMMUS_NO_DCT\n        else if(inFilterName->GetValue() == \"DCTDecode\")\n        {\n            result = new InputDCTDecodeStream(inStream);\n        }\n#endif\n\t\telse if (inFilterName->GetValue() == \"Crypt\")\n\t\t{\n\t\t\tPDFObjectCastPtr<PDFName> cryptFilterName(QueryDictionaryObject(inDecodeParams, \"Name\"));\n\n\t\t\tresult = mDecryptionHelper.CreateDecryptionFilterForStream(inPDFStream, inStream, cryptFilterName->GetValue());\n\t\t}\n\t\telse if(mParserExtender)\n\t\t{\n\t\t\tresult = mParserExtender->CreateFilterForStream(inStream,inFilterName,inDecodeParams, inPDFStream);\n\t\t\tif(result == inStream)\n\t\t\t{\n\t\t\t\tTRACE_LOG1(\"PDFParser::CreateFilterForStream, filter is not supported by extender - %s\",inFilterName->GetValue().substr(0, MAX_TRACE_SIZE - 200).c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateFilterForStream, supporting only flate decode, lzw, dct, crypt and ascii 85+hex decode, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t}while(false);\n\n\tif(status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn EStatusCodeAndIByteReader(status,result);\n\n}\n\nIByteReader* PDFParser::StartReadingFromStream(PDFStreamInput* inStream)\n{\n    IByteReader* result = CreateInputStreamReader(inStream);\n    if(result)\n        MovePositionInStream(inStream->GetStreamContentStart());\n    return result;\n}\n\nPDFObjectParser* PDFParser::StartReadingObjectsFromStream(PDFStreamInput* inStream) {\n\tIByteReader* readStream = StartReadingFromStream(inStream);\n\tif(!readStream)\n\t\treturn NULL;\n\n\tPDFObjectParser* objectsParser = new PDFObjectParser();\n\tInputStreamSkipperStream* source = new InputStreamSkipperStream(readStream);\n\tobjectsParser->SetReadStream(source,source,true);\n\t// Not setting decryption filter cause shuoldnt decrypt at lower level. if at all - the stream is encrypted already\n\tobjectsParser->SetParserExtender(mParserExtender);\n\n\treturn objectsParser;\n}\n\nPDFObjectParser* PDFParser::StartReadingObjectsFromStreams(PDFArray* inArrayOfStreams) {\n\tIByteReader* readStream = new ArrayOfInputStreamsStream(inArrayOfStreams,this);\n\n\tPDFObjectParser* objectsParser = new PDFObjectParser();\n\tInputStreamSkipperStream* source = new InputStreamSkipperStream(readStream);\n\tobjectsParser->SetReadStream(source, source, true);\n\t// Not setting decryption filter cause shuoldnt decrypt at lower level. if at all - the stream is encrypted already\n\tobjectsParser->SetParserExtender(mParserExtender);\n\n\treturn objectsParser;\n}\n\nIByteReader* PDFParser::CreateInputStreamReaderForPlainCopying(PDFStreamInput* inStream) {\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tIByteReader* result = NULL;\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\tdo\n\t{\n\n\t\t// setup stream according to length and possible filter\n\t\tPDFObjectCastPtr<PDFInteger> lengthObject(QueryDictionaryObject(streamDictionary.GetPtr(), \"Length\"));\n\t\tif (!lengthObject)\n\t\t{\n\t\t\tTRACE_LOG(\"PDFParser::CreateInputStreamReaderForPlainCopying, stream does not have length, failing\");\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = new InputLimitedStream(mStream, lengthObject->GetValue(), false);\n\n\t\tresult = WrapWithDecryptionFilter(inStream, result);\n\n\t} while (false);\n\n\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tdelete result;\n\t\tresult = NULL;\n\t}\n\treturn result;\n}\n\nIByteReader* PDFParser::StartReadingFromStreamForPlainCopying(PDFStreamInput* inStream) {\n\tIByteReader* result = CreateInputStreamReaderForPlainCopying(inStream);\n\tif (result)\n\t\tMovePositionInStream(inStream->GetStreamContentStart());\n\treturn result;\n}\n\nEStatusCode PDFParser::StartStateFileParsing(IByteReaderWithPosition* inSourceStream)\n{\n\tEStatusCode status;\n\n\tResetParser();\n\n\tmStream = inSourceStream;\n\tmCurrentPositionProvider.Assign(mStream);\n\tmObjectParser.SetReadStream(inSourceStream,&mCurrentPositionProvider);\n\n\tdo\n\t{\n\t\t// initialize reading from end\n\t\tmLastReadPositionFromEnd = 0;\n\t\tmEncounteredFileStart = false;\n\t\tmLastAvailableIndex = mCurrentBufferIndex = mLinesBuffer;\n\n\t\tstatus = ParseEOFLine();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseLastXrefPosition();\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tstatus = ParseFileDirectory(); // that would be the xref and trailer\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t}while(false);\n\n\treturn status;\n}\n\nbool PDFParser::IsEncrypted()\n{\n\treturn mDecryptionHelper.IsEncrypted();\n}\n\nvoid PDFParser::SetParserExtender(IPDFParserExtender* inParserExtender)\n{\n\tmParserExtender = inParserExtender;\n\tmObjectParser.SetParserExtender(inParserExtender);\n}\n\nbool PDFParser::IsEncryptionSupported()\n{\n    return mDecryptionHelper.CanDecryptDocument() || (mParserExtender && mParserExtender->DoesSupportEncryption());\n}\n\nObjectIDType PDFParser::GetXrefSize()\n{\n    return mXrefSize;\n}\n\nXrefEntryInput* PDFParser::GetXrefEntry(ObjectIDType inObjectID)\n{\n    return (inObjectID < mXrefSize) ? mXrefTable+inObjectID : NULL;\n}\n\nLongFilePositionType PDFParser::GetXrefPosition()\n{\n    return mLastXrefPosition;\n}\n\nIByteReaderWithPosition* PDFParser::GetParserStream()\n{\n    return mStream;\n}\n\n\n\n\n\n\n\n", "var muhammara = require(\"../muhammara\");\nconst { expect } = require(\"chai\");\n\ndescribe(\"SigSegv test\", function () {\n  it(\"should read fields correctly\", function () {\n    expect(() =>\n      muhammara.createReader(\n        __dirname + \"/TestMaterials/BrokenPdfBadHeader.txt\"\n      )\n    ).to.throw();\n  });\n});\n", "%PDF-1.4\n%%EOF"], "buggy_code_start_loc": [8, 353, 1, 1], "buggy_code_end_loc": [8, 353, 2, 2], "fixing_code_start_loc": [9, 354, 1, 1], "fixing_code_end_loc": [13, 360, 13, 3], "type": "NVD-CWE-noinfo", "message": "The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed.", "other": {"cve": {"id": "CVE-2022-25892", "sourceIdentifier": "report@snyk.io", "published": "2022-11-01T05:15:10.010", "lastModified": "2022-12-03T02:51:45.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:muhammara_project:muhammara:*:*:*:*:*:*:*:*", "matchCriteriaId": "5E0EDC24-CC73-4A1A-82F7-39A74BC94A63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:muhammara_project:muhammara:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.1", "matchCriteriaId": "55113790-F98F-4661-8F8F-5439621C1D39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:muhammara_project:muhammara:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "24D81ACA-912D-4B9E-BF1B-7DDB8E9AB38B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:muhammara_project:muhammara:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "ACD76EB9-64F6-42C0-81BF-00ABC0E6FABC"}]}]}], "references": [{"url": "https://github.com/galkahana/HummusJS/issues/463", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/julianhille/MuhammaraJS/commit/1890fb555eaf171db79b73fdc3ea543bbd63c002", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/julianhille/MuhammaraJS/commit/90b278d09f16062d93a4160ef0a54d449d739c51", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/julianhille/MuhammaraJS/issues/214", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-HUMMUS-3091138", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-MUHAMMARA-3060320", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/julianhille/MuhammaraJS/commit/1890fb555eaf171db79b73fdc3ea543bbd63c002"}}