diff --git a/base/stream.c b/base/stream.c
index 2073a12a6..22435e11b 100644
--- a/base/stream.c
+++ b/base/stream.c
@@ -112,6 +112,7 @@ s_init(stream *s, gs_memory_t * mem)
     s->file_name.size = 0;
     s->close_strm = false;	/* default */
     s->close_at_eod = true;	/* default */
+    s->cbuf_string_memory = NULL;
 }
 stream *
 s_alloc(gs_memory_t * mem, client_name_t cname)
@@ -179,6 +180,7 @@ s_std_init(register stream * s, byte * ptr, uint len, const stream_procs * pp,
     s->file = 0;
     s->file_name.data = 0;	/* in case stream is on stack */
     s->file_name.size = 0;
+    s->cbuf_string_memory = NULL;
     if (s->memory) {
         if_debug4m('s', s->memory, "[s]init "PRI_INTPTR", buf="PRI_INTPTR", len=%u, modes=%d\n",
                    (intptr_t) s, (intptr_t) ptr, len, modes);
@@ -1016,6 +1018,10 @@ static int
                            stream_cursor_write *, bool);
 
 /* Initialize a stream for reading a string. */
+/* String ownership retained by the caller, for example
+   Postscript string objects owned by the Postscript
+   interpreter
+ */
 void
 sread_string(register stream *s, const byte *ptr, uint len)
 {
@@ -1027,9 +1033,31 @@ sread_string(register stream *s, const byte *ptr, uint len)
     s_std_init(s, (byte *)ptr, len, &p, s_mode_read + s_mode_seek);
     s->cbuf_string.data = (byte *)ptr;
     s->cbuf_string.size = len;
+    s->cbuf_string_memory = NULL;
+    s->end_status = EOFC;
+    s->cursor.r.limit = s->cursor.w.limit;
+}
+
+/* The string ownership is transferred from caller to stream.
+   string_mem pointer must be allocator used to allocate the
+   "string" buffer.
+ */
+void
+sread_transient_string(register stream *s, gs_memory_t *string_mem, const byte *ptr, uint len)
+{
+    static const stream_procs p = {
+         s_string_available, s_string_read_seek, s_std_read_reset,
+         s_std_read_flush, s_std_null, s_string_read_process
+    };
+
+    s_std_init(s, (byte *)ptr, len, &p, s_mode_read + s_mode_seek);
+    s->cbuf_string.data = (byte *)ptr;
+    s->cbuf_string.size = len;
+    s->cbuf_string_memory = string_mem;
     s->end_status = EOFC;
     s->cursor.r.limit = s->cursor.w.limit;
 }
+
 /* Initialize a reusable stream for reading a string. */
 static void
 s_string_reusable_reset(stream *s)
@@ -1231,15 +1259,23 @@ s_close_filters(stream **ps, stream *target)
     while (*ps != target) {
         stream *s = *ps;
         gs_memory_t *mem = s->state->memory;
+        gs_memory_t *cbuf_string_memory = s->cbuf_string_memory;
         byte *sbuf = s->cbuf;
+        byte *cbuf = s->cbuf_string.data;
         stream *next = s->strm;
         int status = sclose(s);
         stream_state *ss = s->state; /* sclose may set this to s */
 
         if (status < 0)
             return status;
+
+        if (s->cbuf_string_memory != NULL) { /* stream owns string buffer, so free it */
+            gs_free_object(cbuf_string_memory, cbuf, "s_close_filters(cbuf)");
+        }
+
         if (mem) {
-            gs_free_object(mem, sbuf, "s_close_filters(buf)");
+            if (sbuf != cbuf)
+                gs_free_object(mem, sbuf, "s_close_filters(buf)");
             gs_free_object(mem, s, "s_close_filters(stream)");
             if (ss != (stream_state *)s)
                 gs_free_object(mem, ss, "s_close_filters(state)");
diff --git a/base/stream.h b/base/stream.h
index 04ef117d7..3c1aeebca 100644
--- a/base/stream.h
+++ b/base/stream.h
@@ -141,6 +141,7 @@ struct stream_s {
 #define s_can_seek(s) (((s)->modes & s_mode_seek) != 0)
     gs_string cbuf_string;	/* cbuf/cbsize if cbuf is a string, */
                                 /* 0/? if not */
+    gs_memory_t *cbuf_string_memory;  /* If != NULL, stream owns the string buffer */
     gs_offset_t position;		/* file position of beginning of */
                                 /* buffer */
     stream_procs procs;
@@ -372,9 +373,20 @@ int file_close_finish(stream *);
 int file_close_disable(stream *);
 
 /* Create a stream on a string or a file. */
-void sread_string(stream *, const byte *, uint),
-    sread_string_reusable(stream *, const byte *, uint),
-    swrite_string(stream *, byte *, uint);
+/* String ownership retained by the caller, for example
+   Postscript string objects owned by the Postscript
+   interpreter
+ */
+void sread_string(stream *, const byte *, uint);
+/* The string ownership is transferred from caller to stream.
+   string_mem pointer must be allocator used to allocate the
+   "string" buffer.
+ */
+void
+sread_transient_string(register stream *s, gs_memory_t *string_mem, const byte *ptr, uint len);
+
+void sread_string_reusable(stream *, const byte *, uint);
+void swrite_string(stream *, byte *, uint);
 void sread_file(stream *, gp_file *, byte *, uint),
     swrite_file(stream *, gp_file *, byte *, uint);
 int  sappend_file(stream *, gp_file *, byte *, uint);
