diff --git a/ChangeLog b/ChangeLog
index 4f42b7e..6f815f2 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -173,6 +173,10 @@ one: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES.
 35. A lookbehind assertion that had a zero-length branch caused undefined 
 behaviour when processed by pcre2_dfa_match(). This is oss-fuzz issue 1859.
 
+36. The match limit value now also applies to pcre2_dfa_match() as there are 
+patterns that can use up a lot of resources without necessarily recursing very 
+deeply. (Compare item 10.23/36.) This should fix oss-fuzz #1761.
+
 
 Version 10.23 14-February-2017
 ------------------------------
diff --git a/doc/html/pcre2_dfa_match.html b/doc/html/pcre2_dfa_match.html
index a038d27..36d7976 100644
--- a/doc/html/pcre2_dfa_match.html
+++ b/doc/html/pcre2_dfa_match.html
@@ -46,8 +46,9 @@ just once (except when processing lookaround assertions). This function is
   <i>wscount</i>      Number of elements in the vector
 </pre>
 For <b>pcre2_dfa_match()</b>, a match context is needed only if you want to set
-up a callout function or specify the recursion depth limit. The <i>length</i>
-and <i>startoffset</i> values are code units, not characters. The options are:
+up a callout function or specify the match and/or the recursion depth limits.
+The <i>length</i> and <i>startoffset</i> values are code units, not characters.
+The options are:
 <pre>
   PCRE2_ANCHORED          Match only at the first position
   PCRE2_ENDANCHORED       Pattern can match only at end of subject
diff --git a/doc/html/pcre2api.html b/doc/html/pcre2api.html
index 98323c6..7df6d49 100644
--- a/doc/html/pcre2api.html
+++ b/doc/html/pcre2api.html
@@ -329,7 +329,7 @@ document for an overview of all the PCRE2 documentation.
 <b>  void (*<i>private_free</i>)(void *, void *), void *<i>memory_data</i>);</b>
 <br>
 <br>
-These functions became obsolete at release 10.30 and are retained only for 
+These functions became obsolete at release 10.30 and are retained only for
 backward compatibility. They should not be used in new code. The first is
 replaced by <b>pcre2_set_depth_limit()</b>; the second is no longer needed and
 has no effect (it always returns zero).
@@ -428,10 +428,10 @@ documentation, and the
 documentation describes how to compile and run it.
 </P>
 <P>
-The compiling and matching functions recognize various options that are passed 
-as bits in an options argument. There are also some more complicated parameters 
-such as custom memory management functions and resource limits that are passed 
-in "contexts" (which are just memory blocks, described below). Simple 
+The compiling and matching functions recognize various options that are passed
+as bits in an options argument. There are also some more complicated parameters
+such as custom memory management functions and resource limits that are passed
+in "contexts" (which are just memory blocks, described below). Simple
 applications do not need to make use of contexts.
 </P>
 <P>
@@ -450,7 +450,7 @@ More complicated programs might need to make use of the specialist functions
 <P>
 JIT matching is automatically used by <b>pcre2_match()</b> if it is available,
 unless the PCRE2_NO_JIT option is set. There is also a direct interface for JIT
-matching, which gives improved performance at the expense of less sanity 
+matching, which gives improved performance at the expense of less sanity
 checking. The JIT-specific functions are discussed in the
 <a href="pcre2jit.html"><b>pcre2jit</b></a>
 documentation.
@@ -705,7 +705,7 @@ following compile-time parameters:
   The newline character sequence
   The compile time nested parentheses limit
   The maximum length of the pattern string
-  The extra options bits (none set by default) 
+  The extra options bits (none set by default)
 </pre>
 A compile context is also required if you are using custom memory management.
 If none of these apply, just pass NULL as the context argument of
@@ -757,9 +757,9 @@ in the current locale.
 <br>
 As PCRE2 has developed, almost all the 32 option bits that are available in
 the <i>options</i> argument of <b>pcre2_compile()</b> have been used up. To avoid
-running out, the compile context contains a set of extra option bits which are 
-used for some newer, assumed rarer, options. This function sets those bits. It 
-always sets all the bits (either on or off). It does not modify any existing 
+running out, the compile context contains a set of extra option bits which are
+used for some newer, assumed rarer, options. This function sets those bits. It
+always sets all the bits (either on or off). It does not modify any existing
 setting. The available options are defined in the section entitled "Extra
 compile options"
 <a href="#extracompileoptions">below.</a>
@@ -783,8 +783,8 @@ PCRE2_SIZE variable can hold, which is effectively unlimited.
 This specifies which characters or character sequences are to be recognized as
 newlines. The value must be one of PCRE2_NEWLINE_CR (carriage return only),
 PCRE2_NEWLINE_LF (linefeed only), PCRE2_NEWLINE_CRLF (the two-character
-sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of the above), 
-PCRE2_NEWLINE_ANY (any Unicode newline sequence), or PCRE2_NEWLINE_NUL (the 
+sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of the above),
+PCRE2_NEWLINE_ANY (any Unicode newline sequence), or PCRE2_NEWLINE_NUL (the
 NUL character, that is a binary zero).
 </P>
 <P>
@@ -837,7 +837,7 @@ A match context is required if you want to:
 <pre>
   Set up a callout function
   Set an offset limit for matching an unanchored pattern
-  Change the limit on the amount of heap used when matching 
+  Change the limit on the amount of heap used when matching
   Change the backtracking match limit
   Change the backtracking depth limit
   Set custom memory management specifically for the match
@@ -908,15 +908,15 @@ In other words, whichever limit comes first is used.
 <b>  uint32_t <i>value</i>);</b>
 <br>
 <br>
-The <i>heap_limit</i> parameter specifies, in units of kilobytes, the maximum 
+The <i>heap_limit</i> parameter specifies, in units of kilobytes, the maximum
 amount of heap memory that <b>pcre2_match()</b> may use to hold backtracking
 information when running an interpretive match. This limit does not apply to
 matching with the JIT optimization, which has its own memory control
 arrangements (see the
 <a href="pcre2jit.html"><b>pcre2jit</b></a>
 documentation for more details), nor does it apply to <b>pcre2_dfa_match()</b>.
-If the limit is reached, the negative error code PCRE2_ERROR_HEAPLIMIT is 
-returned. The default limit is set when PCRE2 is built; the default default is 
+If the limit is reached, the negative error code PCRE2_ERROR_HEAPLIMIT is
+returned. The default limit is set when PCRE2 is built; the default default is
 very large and is essentially "unlimited".
 </P>
 <P>
@@ -932,11 +932,11 @@ limit is set, less than the default.
 <P>
 The <b>pcre2_match()</b> function starts out using a 20K vector on the system
 stack for recording backtracking points. The more nested backtracking points
-there are (that is, the deeper the search tree), the more memory is needed. 
-Heap memory is used only if the initial vector is too small. If the heap limit 
-is set to a value less than 21 (in particular, zero) no heap memory will be 
-used. In this case, only patterns that do not have a lot of nested backtracking 
-can be successfully processed. 
+there are (that is, the deeper the search tree), the more memory is needed.
+Heap memory is used only if the initial vector is too small. If the heap limit
+is set to a value less than 21 (in particular, zero) no heap memory will be
+used. In this case, only patterns that do not have a lot of nested backtracking
+can be successfully processed.
 <br>
 <br>
 <b>int pcre2_set_match_limit(pcre2_match_context *<i>mcontext</i>,</b>
@@ -954,8 +954,8 @@ time round its main matching loop. If this value reaches the match limit,
 <b>pcre2_match()</b> returns the negative value PCRE2_ERROR_MATCHLIMIT. This has
 the effect of limiting the amount of backtracking that can take place. For
 patterns that are not anchored, the count restarts from zero for each position
-in the subject string. This limit is not relevant to <b>pcre2_dfa_match()</b>,
-which ignores it.
+in the subject string. This limit also applies to <b>pcre2_dfa_match()</b>,
+though the counting is done in a different way.
 </P>
 <P>
 When <b>pcre2_match()</b> is called with a pattern that was successfully
@@ -974,8 +974,8 @@ of the form
   (*LIMIT_MATCH=ddd)
 </pre>
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
-less than the limit set by the caller of <b>pcre2_match()</b> or, if no such
-limit is set, less than the default.
+less than the limit set by the caller of <b>pcre2_match()</b> or
+<b>pcre2_dfa_match()</b> or, if no such limit is set, less than the default.
 <br>
 <br>
 <b>int pcre2_set_depth_limit(pcre2_match_context *<i>mcontext</i>,</b>
@@ -983,7 +983,7 @@ limit is set, less than the default.
 <br>
 <br>
 This parameter limits the depth of nested backtracking in <b>pcre2_match()</b>.
-Each time a nested backtracking point is passed, a new memory "frame" is used 
+Each time a nested backtracking point is passed, a new memory "frame" is used
 to remember the state of matching at that point. Thus, this parameter
 indirectly limits the amount of memory that is used in a match. However,
 because the size of each memory "frame" depends on the number of capturing
@@ -1107,7 +1107,7 @@ sequence that is recognized as meaning "newline". The values are:
   PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
   PCRE2_NEWLINE_ANY      Any Unicode line ending
   PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
-  PCRE2_NEWLINE_NUL      The NUL character (binary zero) 
+  PCRE2_NEWLINE_NUL      The NUL character (binary zero)
 </pre>
 The default should normally correspond to the standard sequence for your
 operating system.
@@ -1334,7 +1334,7 @@ parenthesis. The name is not processed in any way, and it is not possible to
 include a closing parenthesis in the name. However, if the PCRE2_ALT_VERBNAMES
 option is set, normal backslash processing is applied to verb names and only an
 unescaped closing parenthesis terminates the name. A closing parenthesis can be
-included in a name either as \) or between \Q and \E. If the PCRE2_EXTENDED 
+included in a name either as \) or between \Q and \E. If the PCRE2_EXTENDED
 or PCRE2_EXTENDED_MORE option is set, unescaped whitespace in verb names is
 skipped and #-comments are recognized in this mode, exactly as in the rest of
 the pattern.
@@ -1352,12 +1352,12 @@ documentation.
 </pre>
 If this bit is set, letters in the pattern match both upper and lower case
 letters in the subject. It is equivalent to Perl's /i option, and it can be
-changed within a pattern by a (?i) option setting. If PCRE2_UTF is set, Unicode 
+changed within a pattern by a (?i) option setting. If PCRE2_UTF is set, Unicode
 properties are used for all characters with more than one other case, and for
-all characters whose code points are greater than U+007f. For lower valued 
-characters with only one other case, a lookup table is used for speed. When 
-PCRE2_UTF is not set, a lookup table is used for all code points less than 256, 
-and higher code points (available only in 16-bit or 32-bit mode) are treated as 
+all characters whose code points are greater than U+007f. For lower valued
+characters with only one other case, a lookup table is used for speed. When
+PCRE2_UTF is not set, a lookup table is used for all code points less than 256,
+and higher code points (available only in 16-bit or 32-bit mode) are treated as
 not having another case.
 <pre>
   PCRE2_DOLLAR_ENDONLY
@@ -1391,11 +1391,11 @@ documentation.
   PCRE2_ENDANCHORED
 </pre>
 If this bit is set, the end of any pattern match must be right at the end of
-the string being searched (the "subject string"). If the pattern match 
-succeeds by reaching (*ACCEPT), but does not reach the end of the subject, the 
-match fails at the current starting point. For unanchored patterns, a new match 
-is then tried at the next starting point. However, if the match succeeds by 
-reaching the end of the pattern, but not the end of the subject, backtracking 
+the string being searched (the "subject string"). If the pattern match
+succeeds by reaching (*ACCEPT), but does not reach the end of the subject, the
+match fails at the current starting point. For unanchored patterns, a new match
+is then tried at the next starting point. However, if the match succeeds by
+reaching the end of the pattern, but not the end of the subject, backtracking
 occurs and an alternative match may be found. Consider these two patterns:
 <pre>
   .(*ACCEPT)|..
@@ -1407,9 +1407,9 @@ achieved by appropriate constructs in the pattern itself, which is the only way
 to do it in Perl.
 </P>
 <P>
-For DFA matching with <b>pcre2_dfa_match()</b>, PCRE2_ENDANCHORED applies only 
+For DFA matching with <b>pcre2_dfa_match()</b>, PCRE2_ENDANCHORED applies only
 to the first (that is, the longest) matched string. Other parallel matches,
-which are necessarily substrings of the first one, must obviously end before 
+which are necessarily substrings of the first one, must obviously end before
 the end of the subject.
 <pre>
   PCRE2_EXTENDED
@@ -1584,7 +1584,7 @@ current starting position, which in this case, it does. However, if the same
 match is run with PCRE2_NO_START_OPTIMIZE set, the initial scan along the
 subject string does not happen. The first match attempt is run starting from
 "D" and when this fails, (*COMMIT) prevents any further matches being tried, so
-the overall result is "no match". 
+the overall result is "no match".
 </P>
 <P>
 There are also other start-up optimizations. For example, a minimum length for
@@ -1610,13 +1610,13 @@ and
 in the
 <a href="pcre2unicode.html"><b>pcre2unicode</b></a>
 document. If an invalid UTF sequence is found, <b>pcre2_compile()</b> returns a
-negative error code. 
+negative error code.
 </P>
 <P>
 If you know that your pattern is a valid UTF string, and you want to skip this
 check for performance reasons, you can set the PCRE2_NO_UTF_CHECK option. When
 it is set, the effect of passing an invalid UTF string as a pattern is
-undefined. It may cause your program to crash or loop. 
+undefined. It may cause your program to crash or loop.
 </P>
 <P>
 Note that this option can also be passed to <b>pcre2_match()</b> and
@@ -1685,13 +1685,13 @@ calling the <b>pcre2_set_compile_extra_options()</b> function are as follows:
 <pre>
   PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES
 </pre>
-This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is 
+This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is
 forbidden in UTF-16 mode, and ignored in non-UTF modes. Unicode "surrogate"
 code points in the range 0xd800 to 0xdfff are used in pairs in UTF-16 to encode
-code points with values in the range 0x10000 to 0x10ffff. The surrogates cannot 
+code points with values in the range 0x10000 to 0x10ffff. The surrogates cannot
 therefore be represented in UTF-16. They can be represented in UTF-8 and
-UTF-32, but are defined as invalid code points, and cause errors if encountered 
-in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2. 
+UTF-32, but are defined as invalid code points, and cause errors if encountered
+in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2.
 </P>
 <P>
 These values also cause errors if encountered in escape sequences such as
@@ -1702,9 +1702,9 @@ not disable the error that occurs, because it applies only to the testing of
 input strings for UTF validity.
 </P>
 <P>
-If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is set, surrogate code 
-point values in UTF-8 and UTF-32 patterns no longer provoke errors and are 
-incorporated in the compiled pattern. However, they can only match subject 
+If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is set, surrogate code
+point values in UTF-8 and UTF-32 patterns no longer provoke errors and are
+incorporated in the compiled pattern. However, they can only match subject
 characters if the matching function is called with PCRE2_NO_UTF_CHECK set.
 </P>
 <br><a name="SEC20" href="#TOC1">COMPILATION ERROR CODES</a><br>
@@ -1914,7 +1914,7 @@ The third argument should point to an <b>uint32_t</b> variable.
 If the pattern set a backtracking depth limit by including an item of the form
 (*LIMIT_DEPTH=nnnn) at the start, the value is returned. The third argument
 should point to an unsigned 32-bit integer. If no such value has been set, the
-call to <b>pcre2_pattern_info()</b> returns the error PCRE2_ERROR_UNSET. Note 
+call to <b>pcre2_pattern_info()</b> returns the error PCRE2_ERROR_UNSET. Note
 that this limit will only be used during matching if it is less than the limit
 set or defaulted by the caller of the match function.
 <pre>
@@ -2123,7 +2123,7 @@ The output is one of the following <b>uint32_t</b> values:
   PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
   PCRE2_NEWLINE_ANY      Any Unicode line ending
   PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
-  PCRE2_NEWLINE_NUL      The NUL character (binary zero) 
+  PCRE2_NEWLINE_NUL      The NUL character (binary zero)
 </pre>
 This identifies the character sequence that will be recognized as meaning
 "newline" while matching.
@@ -2334,8 +2334,8 @@ instead of one.
 <P>
 If a non-zero starting offset is passed when the pattern is anchored, a single
 attempt to match at the given offset is made. This can only succeed if the
-pattern does not require the match to be at the start of the subject. In other 
-words, the anchoring must be the result of setting the PCRE2_ANCHORED option or 
+pattern does not require the match to be at the start of the subject. In other
+words, the anchoring must be the result of setting the PCRE2_ANCHORED option or
 the use of .* with PCRE2_DOTALL, not by starting the pattern with ^ or \A.
 <a name="matchoptions"></a></P>
 <br><b>
@@ -2508,7 +2508,7 @@ reference, and so advances only by one character after the first failure.
 </P>
 <P>
 An explicit match for CR of LF is either a literal appearance of one of those
-characters in the pattern, or one of the \r or \n or equivalent octal or 
+characters in the pattern, or one of the \r or \n or equivalent octal or
 hexadecimal escape sequences. Implicit matches such as [^X] do not count, nor
 does \s, even though it includes CR and LF in the characters that it matches.
 </P>
@@ -2751,9 +2751,9 @@ The backtracking match limit was reached.
 <pre>
   PCRE2_ERROR_NOMEMORY
 </pre>
-If a pattern contains many nested backtracking points, heap memory is used to 
-remember them. This error is given when the memory allocation function (default 
-or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given 
+If a pattern contains many nested backtracking points, heap memory is used to
+remember them. This error is given when the memory allocation function (default
+or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
 if the amount of memory needed exceeds the heap limit.
 <pre>
   PCRE2_ERROR_NULL
@@ -3471,7 +3471,7 @@ Cambridge, England.
 </P>
 <br><a name="SEC42" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 26 May 2017
+Last updated: 30 May 2017
 <br>
 Copyright &copy; 1997-2017 University of Cambridge.
 <br>
diff --git a/doc/html/pcre2build.html b/doc/html/pcre2build.html
index 1cef522..94c2c65 100644
--- a/doc/html/pcre2build.html
+++ b/doc/html/pcre2build.html
@@ -260,9 +260,9 @@ setting such as
 <pre>
   --with-match-limit=500000
 </pre>
-to the <b>configure</b> command. This setting has no effect on the
-<b>pcre2_dfa_match()</b> matching function, but it does also limit JIT matching 
-(though the counting is done differently).
+to the <b>configure</b> command. This setting also applies to the
+<b>pcre2_dfa_match()</b> matching function, and to JIT matching (though the
+counting is done differently).
 </P>
 <P>
 The <b>pcre2_match()</b> function starts out using a 20K vector on the system
@@ -554,7 +554,7 @@ Cambridge, England.
 </P>
 <br><a name="SEC25" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 10 April 2017
+Last updated: 30 May 2017
 <br>
 Copyright &copy; 1997-2017 University of Cambridge.
 <br>
diff --git a/doc/html/pcre2pattern.html b/doc/html/pcre2pattern.html
index 9679933..3eccb3e 100644
--- a/doc/html/pcre2pattern.html
+++ b/doc/html/pcre2pattern.html
@@ -204,11 +204,11 @@ still recognized for backwards compatibility.
 <P>
 The heap limit applies only when the <b>pcre2_match()</b> interpreter is used
 for matching. It does not apply to JIT or DFA matching. The match limit is used
-(but in a different way) when JIT is being used, but it is not relevant, and is
-ignored, when matching with <b>pcre2_dfa_match()</b>. The depth limit is ignored 
-by JIT but is relevant for DFA matching, which uses function recursion for
-recursions within the pattern. In this case, the depth limit controls the
-amount of system stack that is used.
+(but in a different way) when JIT is being used, or when
+<b>pcre2_dfa_match()</b> is called, to limit computing resource usage by those
+matching functions. The depth limit is ignored by JIT but is relevant for DFA
+matching, which uses function recursion for recursions within the pattern. In
+this case, the depth limit controls the amount of system stack that is used.
 <a name="newlines"></a></P>
 <br><b>
 Newline conventions
@@ -3445,7 +3445,7 @@ Cambridge, England.
 </P>
 <br><a name="SEC30" href="#TOC1">REVISION</a><br>
 <P>
-Last updated: 26 May 2017
+Last updated: 30 May 2017
 <br>
 Copyright &copy; 1997-2017 University of Cambridge.
 <br>
diff --git a/doc/pcre2.txt b/doc/pcre2.txt
index d672333..477ad6f 100644
--- a/doc/pcre2.txt
+++ b/doc/pcre2.txt
@@ -963,8 +963,8 @@ PCRE2 CONTEXTS
        limit, pcre2_match() returns the negative value PCRE2_ERROR_MATCHLIMIT.
        This has the effect of limiting the amount  of  backtracking  that  can
        take place. For patterns that are not anchored, the count restarts from
-       zero for each position in the subject string. This limit is  not  rele-
-       vant to pcre2_dfa_match(), which ignores it.
+       zero for each position in the subject string. This limit  also  applies
+       to pcre2_dfa_match(), though the counting is done in a different way.
 
        When  pcre2_match() is called with a pattern that was successfully pro-
        cessed by pcre2_jit_compile(), the way in which matching is executed is
@@ -981,8 +981,8 @@ PCRE2 CONTEXTS
          (*LIMIT_MATCH=ddd)
 
        where  ddd  is  a  decimal  number.  However, such a setting is ignored
-       unless ddd is less than the limit set by the  caller  of  pcre2_match()
-       or, if no such limit is set, less than the default.
+       unless ddd is less than the limit set by the caller of pcre2_match() or
+       pcre2_dfa_match() or, if no such limit is set, less than the default.
 
        int pcre2_set_depth_limit(pcre2_match_context *mcontext,
          uint32_t value);
@@ -3350,7 +3350,7 @@ AUTHOR
 
 REVISION
 
-       Last updated: 26 May 2017
+       Last updated: 30 May 2017
        Copyright (c) 1997-2017 University of Cambridge.
 ------------------------------------------------------------------------------
  
@@ -3586,9 +3586,9 @@ LIMITING PCRE2 RESOURCE USAGE
 
          --with-match-limit=500000
 
-       to   the   configure  command.  This  setting  has  no  effect  on  the
-       pcre2_dfa_match() matching function, but it does also limit JIT  match-
-       ing (though the counting is done differently).
+       to   the   configure   command.   This  setting  also  applies  to  the
+       pcre2_dfa_match() matching function, and to JIT  matching  (though  the
+       counting is done differently).
 
        The  pcre2_match() function starts out using a 20K vector on the system
        stack to record  backtracking  points.  The  more  nested  backtracking
@@ -3885,7 +3885,7 @@ AUTHOR
 
 REVISION
 
-       Last updated: 10 April 2017
+       Last updated: 30 May 2017
        Copyright (c) 1997-2017 University of Cambridge.
 ------------------------------------------------------------------------------
  
@@ -5751,22 +5751,23 @@ SPECIAL START-OF-PATTERN ITEMS
 
        The heap limit applies only when the pcre2_match() interpreter is  used
        for matching. It does not apply to JIT or DFA matching. The match limit
-       is used (but in a different way) when JIT is being used, but it is  not
-       relevant,  and  is  ignored,  when matching with pcre2_dfa_match(). The
-       depth limit is ignored by JIT but is relevant for DFA  matching,  which
-       uses  function  recursion  for  recursions  within the pattern. In this
-       case, the depth limit controls the amount of system stack that is used.
+       is used (but in a different way)  when  JIT  is  being  used,  or  when
+       pcre2_dfa_match() is called, to limit computing resource usage by those
+       matching functions. The depth limit is ignored by JIT but  is  relevant
+       for  DFA  matching, which uses function recursion for recursions within
+       the pattern. In this case, the depth limit controls the amount of  sys-
+       tem stack that is used.
 
    Newline conventions
 
-       PCRE2 supports six different conventions for indicating line breaks  in
-       strings:  a  single  CR (carriage return) character, a single LF (line-
+       PCRE2  supports six different conventions for indicating line breaks in
+       strings: a single CR (carriage return) character, a  single  LF  (line-
        feed) character, the two-character sequence CRLF, any of the three pre-
-       ceding,  any  Unicode  newline  sequence,  or the NUL character (binary
-       zero). The pcre2api page has further  discussion  about  newlines,  and
+       ceding, any Unicode newline sequence,  or  the  NUL  character  (binary
+       zero).  The  pcre2api  page  has further discussion about newlines, and
        shows how to set the newline convention when calling pcre2_compile().
 
-       It  is also possible to specify a newline convention by starting a pat-
+       It is also possible to specify a newline convention by starting a  pat-
        tern string with one of the following sequences:
 
          (*CR)        carriage return
@@ -5777,7 +5778,7 @@ SPECIAL START-OF-PATTERN ITEMS
          (*NUL)       the NUL character (binary zero)
 
        These override the default and the options given to the compiling func-
-       tion.  For  example,  on  a Unix system where LF is the default newline
+       tion. For example, on a Unix system where LF  is  the  default  newline
        sequence, the pattern
 
          (*CR)a.b
@@ -5786,38 +5787,38 @@ SPECIAL START-OF-PATTERN ITEMS
        no longer a newline. If more than one of these settings is present, the
        last one is used.
 
-       The newline convention affects where the circumflex and  dollar  asser-
+       The  newline  convention affects where the circumflex and dollar asser-
        tions are true. It also affects the interpretation of the dot metachar-
-       acter when PCRE2_DOTALL is not set, and the behaviour of  \N.  However,
-       it  does  not  affect  what the \R escape sequence matches. By default,
-       this is any Unicode newline sequence, for Perl compatibility.  However,
-       this  can be changed; see the next section and the description of \R in
-       the section entitled "Newline sequences" below. A change of \R  setting
+       acter  when  PCRE2_DOTALL is not set, and the behaviour of \N. However,
+       it does not affect what the \R escape  sequence  matches.  By  default,
+       this  is any Unicode newline sequence, for Perl compatibility. However,
+       this can be changed; see the next section and the description of \R  in
+       the  section entitled "Newline sequences" below. A change of \R setting
        can be combined with a change of newline convention.
 
    Specifying what \R matches
 
        It is possible to restrict \R to match only CR, LF, or CRLF (instead of
-       the complete set  of  Unicode  line  endings)  by  setting  the  option
-       PCRE2_BSR_ANYCRLF  at compile time. This effect can also be achieved by
-       starting a pattern with (*BSR_ANYCRLF).  For  completeness,  (*BSR_UNI-
+       the  complete  set  of  Unicode  line  endings)  by  setting the option
+       PCRE2_BSR_ANYCRLF at compile time. This effect can also be achieved  by
+       starting  a  pattern  with (*BSR_ANYCRLF). For completeness, (*BSR_UNI-
        CODE) is also recognized, corresponding to PCRE2_BSR_UNICODE.
 
 
 EBCDIC CHARACTER CODES
 
-       PCRE2  can be compiled to run in an environment that uses EBCDIC as its
-       character code instead of ASCII or Unicode (typically a mainframe  sys-
-       tem).  In  the  sections below, character code values are ASCII or Uni-
+       PCRE2 can be compiled to run in an environment that uses EBCDIC as  its
+       character  code instead of ASCII or Unicode (typically a mainframe sys-
+       tem). In the sections below, character code values are  ASCII  or  Uni-
        code; in an EBCDIC environment these characters may have different code
        values, and there are no code points greater than 255.
 
 
 CHARACTERS AND METACHARACTERS
 
-       A  regular  expression  is  a pattern that is matched against a subject
-       string from left to right. Most characters stand for  themselves  in  a
-       pattern,  and  match  the corresponding characters in the subject. As a
+       A regular expression is a pattern that is  matched  against  a  subject
+       string  from  left  to right. Most characters stand for themselves in a
+       pattern, and match the corresponding characters in the  subject.  As  a
        trivial example, the pattern
 
          The quick brown fox
@@ -5826,14 +5827,14 @@ CHARACTERS AND METACHARACTERS
        caseless matching is specified (the PCRE2_CASELESS option), letters are
        matched independently of case.
 
-       The power of regular expressions comes  from  the  ability  to  include
-       alternatives  and  repetitions in the pattern. These are encoded in the
+       The  power  of  regular  expressions  comes from the ability to include
+       alternatives and repetitions in the pattern. These are encoded  in  the
        pattern by the use of metacharacters, which do not stand for themselves
        but instead are interpreted in some special way.
 
-       There  are  two different sets of metacharacters: those that are recog-
-       nized anywhere in the pattern except within square brackets, and  those
-       that  are  recognized  within square brackets. Outside square brackets,
+       There are two different sets of metacharacters: those that  are  recog-
+       nized  anywhere in the pattern except within square brackets, and those
+       that are recognized within square brackets.  Outside  square  brackets,
        the metacharacters are as follows:
 
          \      general escape character with several uses
@@ -5852,7 +5853,7 @@ CHARACTERS AND METACHARACTERS
                 also "possessive quantifier"
          {      start min/max quantifier
 
-       Part of a pattern that is in square brackets  is  called  a  "character
+       Part  of  a  pattern  that is in square brackets is called a "character
        class". In a character class the only metacharacters are:
 
          \      general escape character
@@ -5869,30 +5870,30 @@ BACKSLASH
 
        The backslash character has several uses. Firstly, if it is followed by
        a character that is not a number or a letter, it takes away any special
-       meaning  that  character  may  have. This use of backslash as an escape
+       meaning that character may have. This use of  backslash  as  an  escape
        character applies both inside and outside character classes.
 
-       For example, if you want to match a * character, you must write  \*  in
-       the  pattern. This escaping action applies whether or not the following
-       character would otherwise be interpreted as a metacharacter, so  it  is
-       always  safe  to  precede  a non-alphanumeric with backslash to specify
+       For  example,  if you want to match a * character, you must write \* in
+       the pattern. This escaping action applies whether or not the  following
+       character  would  otherwise be interpreted as a metacharacter, so it is
+       always safe to precede a non-alphanumeric  with  backslash  to  specify
        that it stands for itself.  In particular, if you want to match a back-
        slash, you write \\.
 
-       In  a UTF mode, only ASCII numbers and letters have any special meaning
-       after a backslash. All other characters  (in  particular,  those  whose
+       In a UTF mode, only ASCII numbers and letters have any special  meaning
+       after  a  backslash.  All  other characters (in particular, those whose
        codepoints are greater than 127) are treated as literals.
 
-       If  a  pattern  is  compiled with the PCRE2_EXTENDED option, most white
-       space in the pattern (other than in a character class), and  characters
-       between  a # outside a character class and the next newline, inclusive,
+       If a pattern is compiled with the  PCRE2_EXTENDED  option,  most  white
+       space  in the pattern (other than in a character class), and characters
+       between a # outside a character class and the next newline,  inclusive,
        are ignored. An escaping backslash can be used to include a white space
        or # character as part of the pattern.
 
-       If  you  want  to remove the special meaning from a sequence of charac-
-       ters, you can do so by putting them between \Q and \E. This is  differ-
-       ent  from  Perl  in  that  $  and  @ are handled as literals in \Q...\E
-       sequences in PCRE2, whereas in Perl, $ and @ cause variable  interpola-
+       If you want to remove the special meaning from a  sequence  of  charac-
+       ters,  you can do so by putting them between \Q and \E. This is differ-
+       ent from Perl in that $ and  @  are  handled  as  literals  in  \Q...\E
+       sequences  in PCRE2, whereas in Perl, $ and @ cause variable interpola-
        tion. Note the following examples:
 
          Pattern            PCRE2 matches   Perl matches
@@ -5902,21 +5903,21 @@ BACKSLASH
          \Qabc\$xyz\E       abc\$xyz       abc\$xyz
          \Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz
 
-       The  \Q...\E  sequence  is recognized both inside and outside character
-       classes.  An isolated \E that is not preceded by \Q is ignored.  If  \Q
-       is  not followed by \E later in the pattern, the literal interpretation
-       continues to the end of the pattern (that is,  \E  is  assumed  at  the
-       end).  If  the  isolated \Q is inside a character class, this causes an
-       error, because the character class  is  not  terminated  by  a  closing
+       The \Q...\E sequence is recognized both inside  and  outside  character
+       classes.   An  isolated \E that is not preceded by \Q is ignored. If \Q
+       is not followed by \E later in the pattern, the literal  interpretation
+       continues  to  the  end  of  the pattern (that is, \E is assumed at the
+       end). If the isolated \Q is inside a character class,  this  causes  an
+       error,  because  the  character  class  is  not terminated by a closing
        square bracket.
 
    Non-printing characters
 
        A second use of backslash provides a way of encoding non-printing char-
-       acters in patterns in a visible manner. There is no restriction on  the
-       appearance  of non-printing characters in a pattern, but when a pattern
+       acters  in patterns in a visible manner. There is no restriction on the
+       appearance of non-printing characters in a pattern, but when a  pattern
        is being prepared by text editing, it is often easier to use one of the
-       following  escape sequences than the binary character it represents. In
+       following escape sequences than the binary character it represents.  In
        an ASCII or Unicode environment, these escapes are as follows:
 
          \a        alarm, that is, the BEL character (hex 07)
@@ -5933,51 +5934,51 @@ BACKSLASH
          \x{hhh..} character with hex code hhh.. (default mode)
          \uhhhh    character with hex code hhhh (when PCRE2_ALT_BSUX is set)
 
-       The precise effect of \cx on ASCII characters is as follows: if x is  a
-       lower  case  letter,  it  is converted to upper case. Then bit 6 of the
+       The  precise effect of \cx on ASCII characters is as follows: if x is a
+       lower case letter, it is converted to upper case. Then  bit  6  of  the
        character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A
-       (A  is  41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes
-       hex 7B (; is 3B). If the code unit following \c has a value  less  than
+       (A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and  \c;  becomes
+       hex  7B  (; is 3B). If the code unit following \c has a value less than
        32 or greater than 126, a compile-time error occurs.
 
-       When  PCRE2 is compiled in EBCDIC mode, \a, \e, \f, \n, \r, and \t gen-
+       When PCRE2 is compiled in EBCDIC mode, \a, \e, \f, \n, \r, and \t  gen-
        erate the appropriate EBCDIC code values. The \c escape is processed as
        specified for Perl in the perlebcdic document. The only characters that
-       are allowed after \c are A-Z, a-z, or one of @, [, \, ], ^,  _,  or  ?.
-       Any  other  character  provokes  a compile-time error. The sequence \c@
-       encodes character code 0; after \c the letters (in either case)  encode
+       are  allowed  after  \c are A-Z, a-z, or one of @, [, \, ], ^, _, or ?.
+       Any other character provokes a compile-time  error.  The  sequence  \c@
+       encodes  character code 0; after \c the letters (in either case) encode
        characters 1-26 (hex 01 to hex 1A); [, \, ], ^, and _ encode characters
-       27-31 (hex 1B to hex 1F), and \c? becomes either 255  (hex  FF)  or  95
+       27-31  (hex  1B  to  hex 1F), and \c? becomes either 255 (hex FF) or 95
        (hex 5F).
 
-       Thus,  apart  from  \c?, these escapes generate the same character code
-       values as they do in an ASCII environment, though the meanings  of  the
-       values  mostly  differ. For example, \cG always generates code value 7,
+       Thus, apart from \c?, these escapes generate the  same  character  code
+       values  as  they do in an ASCII environment, though the meanings of the
+       values mostly differ. For example, \cG always generates code  value  7,
        which is BEL in ASCII but DEL in EBCDIC.
 
-       The sequence \c? generates DEL (127, hex 7F) in an  ASCII  environment,
-       but  because  127  is  not a control character in EBCDIC, Perl makes it
-       generate the APC character. Unfortunately, there are  several  variants
-       of  EBCDIC.  In  most  of them the APC character has the value 255 (hex
-       FF), but in the one Perl calls POSIX-BC its value is 95  (hex  5F).  If
+       The  sequence  \c? generates DEL (127, hex 7F) in an ASCII environment,
+       but because 127 is not a control character in  EBCDIC,  Perl  makes  it
+       generate  the  APC character. Unfortunately, there are several variants
+       of EBCDIC. In most of them the APC character has  the  value  255  (hex
+       FF),  but  in  the one Perl calls POSIX-BC its value is 95 (hex 5F). If
        certain other characters have POSIX-BC values, PCRE2 makes \c? generate
        95; otherwise it generates 255.
 
-       After \0 up to two further octal digits are read. If  there  are  fewer
-       than  two  digits,  just  those  that  are  present  are used. Thus the
+       After  \0  up  to two further octal digits are read. If there are fewer
+       than two digits, just  those  that  are  present  are  used.  Thus  the
        sequence \0\x\015 specifies two binary zeros followed by a CR character
        (code value 13). Make sure you supply two digits after the initial zero
        if the pattern character that follows is itself an octal digit.
 
-       The escape \o must be followed by a sequence of octal digits,  enclosed
-       in  braces.  An  error occurs if this is not the case. This escape is a
-       recent addition to Perl; it provides way of specifying  character  code
-       points  as  octal  numbers  greater than 0777, and it also allows octal
+       The  escape \o must be followed by a sequence of octal digits, enclosed
+       in braces. An error occurs if this is not the case. This  escape  is  a
+       recent  addition  to Perl; it provides way of specifying character code
+       points as octal numbers greater than 0777, and  it  also  allows  octal
        numbers and back references to be unambiguously specified.
 
        For greater clarity and unambiguity, it is best to avoid following \ by
        a digit greater than zero. Instead, use \o{} or \x{} to specify charac-
-       ter numbers, and \g{} to specify back references. The  following  para-
+       ter  numbers,  and \g{} to specify back references. The following para-
        graphs describe the old, ambiguous syntax.
 
        The handling of a backslash followed by a digit other than 0 is compli-
@@ -5985,16 +5986,16 @@ BACKSLASH
 
        Outside a character class, PCRE2 reads the digit and any following dig-
        its as a decimal number. If the number is less than 10, begins with the
-       digit 8 or 9, or if there are at least  that  many  previous  capturing
-       left  parentheses  in the expression, the entire sequence is taken as a
+       digit  8  or  9,  or if there are at least that many previous capturing
+       left parentheses in the expression, the entire sequence is taken  as  a
        back reference. A description of how this works is given later, follow-
-       ing  the  discussion  of  parenthesized  subpatterns.  Otherwise, up to
+       ing the discussion of  parenthesized  subpatterns.   Otherwise,  up  to
        three octal digits are read to form a character code.
 
-       Inside a character class, PCRE2 handles \8 and \9 as the literal  char-
-       acters  "8"  and "9", and otherwise reads up to three octal digits fol-
+       Inside  a character class, PCRE2 handles \8 and \9 as the literal char-
+       acters "8" and "9", and otherwise reads up to three octal  digits  fol-
        lowing the backslash, using them to generate a data character. Any sub-
-       sequent  digits  stand for themselves. For example, outside a character
+       sequent digits stand for themselves. For example, outside  a  character
        class:
 
          \040   is another way of writing an ASCII space
@@ -6011,31 +6012,31 @@ BACKSLASH
                    the value 255 (decimal)
          \81    is always a back reference
 
-       Note that octal values of 100 or greater that are specified using  this
-       syntax  must  not be introduced by a leading zero, because no more than
+       Note  that octal values of 100 or greater that are specified using this
+       syntax must not be introduced by a leading zero, because no  more  than
        three octal digits are ever read.
 
-       By default, after \x that is not followed by {, from zero to two  hexa-
-       decimal  digits  are  read (letters can be in upper or lower case). Any
+       By  default, after \x that is not followed by {, from zero to two hexa-
+       decimal digits are read (letters can be in upper or  lower  case).  Any
        number of hexadecimal digits may appear between \x{ and }. If a charac-
-       ter  other  than  a  hexadecimal digit appears between \x{ and }, or if
+       ter other than a hexadecimal digit appears between \x{  and  },  or  if
        there is no terminating }, an error occurs.
 
-       If the PCRE2_ALT_BSUX option is set, the interpretation  of  \x  is  as
+       If  the  PCRE2_ALT_BSUX  option  is set, the interpretation of \x is as
        just described only when it is followed by two hexadecimal digits. Oth-
-       erwise, it matches a literal "x" character. In this mode,  support  for
-       code  points greater than 256 is provided by \u, which must be followed
-       by four hexadecimal digits; otherwise it matches a literal "u"  charac-
+       erwise,  it  matches a literal "x" character. In this mode, support for
+       code points greater than 256 is provided by \u, which must be  followed
+       by  four hexadecimal digits; otherwise it matches a literal "u" charac-
        ter.
 
        Characters whose value is less than 256 can be defined by either of the
        two syntaxes for \x (or by \u in PCRE2_ALT_BSUX mode). There is no dif-
-       ference  in  the way they are handled. For example, \xdc is exactly the
+       ference in the way they are handled. For example, \xdc is  exactly  the
        same as \x{dc} (or \u00dc in PCRE2_ALT_BSUX mode).
 
    Constraints on character values
 
-       Characters that are specified using octal or  hexadecimal  numbers  are
+       Characters  that  are  specified using octal or hexadecimal numbers are
        limited to certain values, as follows:
 
          8-bit non-UTF mode    no greater than 0xff
@@ -6043,42 +6044,42 @@ BACKSLASH
          32-bit non-UTF mode   no greater than 0xffffffff
          All UTF modes         no greater than 0x10ffff and a valid codepoint
 
-       Invalid  Unicode  codepoints  are  the  range 0xd800 to 0xdfff (the so-
+       Invalid Unicode codepoints are the range  0xd800  to  0xdfff  (the  so-
        called "surrogate" codepoints), and 0xffef.
 
    Escape sequences in character classes
 
        All the sequences that define a single character value can be used both
-       inside  and  outside character classes. In addition, inside a character
+       inside and outside character classes. In addition, inside  a  character
        class, \b is interpreted as the backspace character (hex 08).
 
-       \N is not allowed in a character class. \B, \R, and \X are not  special
-       inside  a  character  class.  Like other unrecognized alphabetic escape
-       sequences, they cause  an  error.  Outside  a  character  class,  these
+       \N  is not allowed in a character class. \B, \R, and \X are not special
+       inside a character class. Like  other  unrecognized  alphabetic  escape
+       sequences,  they  cause  an  error.  Outside  a  character class, these
        sequences have different meanings.
 
    Unsupported escape sequences
 
-       In  Perl, the sequences \l, \L, \u, and \U are recognized by its string
-       handler and used  to  modify  the  case  of  following  characters.  By
+       In Perl, the sequences \l, \L, \u, and \U are recognized by its  string
+       handler  and  used  to  modify  the  case  of  following characters. By
        default, PCRE2 does not support these escape sequences. However, if the
        PCRE2_ALT_BSUX option is set, \U matches a "U" character, and \u can be
        used to define a character by code point, as described above.
 
    Absolute and relative back references
 
-       The  sequence  \g  followed  by a signed or unsigned number, optionally
-       enclosed in braces, is an absolute or relative back reference. A  named
-       back  reference can be coded as \g{name}. Back references are discussed
+       The sequence \g followed by a signed  or  unsigned  number,  optionally
+       enclosed  in braces, is an absolute or relative back reference. A named
+       back reference can be coded as \g{name}. Back references are  discussed
        later, following the discussion of parenthesized subpatterns.
 
    Absolute and relative subroutine calls
 
-       For compatibility with Oniguruma, the non-Perl syntax \g followed by  a
+       For  compatibility with Oniguruma, the non-Perl syntax \g followed by a
        name or a number enclosed either in angle brackets or single quotes, is
-       an alternative syntax for referencing a subpattern as  a  "subroutine".
-       Details  are  discussed  later.   Note  that  \g{...} (Perl syntax) and
-       \g<...> (Oniguruma syntax) are not synonymous. The  former  is  a  back
+       an  alternative  syntax for referencing a subpattern as a "subroutine".
+       Details are discussed later.   Note  that  \g{...}  (Perl  syntax)  and
+       \g<...>  (Oniguruma  syntax)  are  not synonymous. The former is a back
        reference; the latter is a subroutine call.
 
    Generic character types
@@ -6097,55 +6098,55 @@ BACKSLASH
          \W     any "non-word" character
 
        There is also the single sequence \N, which matches a non-newline char-
-       acter.  This is the same as the "." metacharacter when PCRE2_DOTALL  is
-       not  set. Perl also uses \N to match characters by name; PCRE2 does not
+       acter.   This is the same as the "." metacharacter when PCRE2_DOTALL is
+       not set. Perl also uses \N to match characters by name; PCRE2 does  not
        support this.
 
-       Each pair of lower and upper case escape sequences partitions the  com-
-       plete  set  of  characters  into two disjoint sets. Any given character
-       matches one, and only one, of each pair. The sequences can appear  both
-       inside  and outside character classes. They each match one character of
-       the appropriate type. If the current matching point is at  the  end  of
-       the  subject string, all of them fail, because there is no character to
+       Each  pair of lower and upper case escape sequences partitions the com-
+       plete set of characters into two disjoint  sets.  Any  given  character
+       matches  one, and only one, of each pair. The sequences can appear both
+       inside and outside character classes. They each match one character  of
+       the  appropriate  type.  If the current matching point is at the end of
+       the subject string, all of them fail, because there is no character  to
        match.
 
-       The default \s characters are HT (9), LF (10), VT  (11),  FF  (12),  CR
-       (13),  and  space  (32),  which  are  defined as white space in the "C"
+       The  default  \s  characters  are HT (9), LF (10), VT (11), FF (12), CR
+       (13), and space (32), which are defined  as  white  space  in  the  "C"
        locale. This list may vary if locale-specific matching is taking place.
-       For  example, in some locales the "non-breaking space" character (\xA0)
+       For example, in some locales the "non-breaking space" character  (\xA0)
        is recognized as white space, and in others the VT character is not.
 
-       A "word" character is an underscore or any character that is  a  letter
-       or  digit.   By  default,  the definition of letters and digits is con-
+       A  "word"  character is an underscore or any character that is a letter
+       or digit.  By default, the definition of letters  and  digits  is  con-
        trolled by PCRE2's low-valued character tables, and may vary if locale-
        specific matching is taking place (see "Locale support" in the pcre2api
-       page). For example, in a French locale such  as  "fr_FR"  in  Unix-like
-       systems,  or "french" in Windows, some character codes greater than 127
-       are used for accented letters, and these are then matched  by  \w.  The
+       page).  For  example,  in  a French locale such as "fr_FR" in Unix-like
+       systems, or "french" in Windows, some character codes greater than  127
+       are  used  for  accented letters, and these are then matched by \w. The
        use of locales with Unicode is discouraged.
 
-       By  default,  characters  whose  code points are greater than 127 never
+       By default, characters whose code points are  greater  than  127  never
        match \d, \s, or \w, and always match \D, \S, and \W, although this may
-       be  different  for characters in the range 128-255 when locale-specific
-       matching is happening.  These escape sequences  retain  their  original
-       meanings  from  before  Unicode support was available, mainly for effi-
-       ciency reasons. If the  PCRE2_UCP  option  is  set,  the  behaviour  is
-       changed  so  that  Unicode  properties  are used to determine character
+       be different for characters in the range 128-255  when  locale-specific
+       matching  is  happening.   These escape sequences retain their original
+       meanings from before Unicode support was available,  mainly  for  effi-
+       ciency  reasons.  If  the  PCRE2_UCP  option  is  set, the behaviour is
+       changed so that Unicode properties  are  used  to  determine  character
        types, as follows:
 
          \d  any character that matches \p{Nd} (decimal digit)
          \s  any character that matches \p{Z} or \h or \v
          \w  any character that matches \p{L} or \p{N}, plus underscore
 
-       The upper case escapes match the inverse sets of characters. Note  that
-       \d  matches  only decimal digits, whereas \w matches any Unicode digit,
+       The  upper case escapes match the inverse sets of characters. Note that
+       \d matches only decimal digits, whereas \w matches any  Unicode  digit,
        as well as any Unicode letter, and underscore. Note also that PCRE2_UCP
-       affects  \b,  and  \B  because  they are defined in terms of \w and \W.
+       affects \b, and \B because they are defined in  terms  of  \w  and  \W.
        Matching these sequences is noticeably slower when PCRE2_UCP is set.
 
-       The sequences \h, \H, \v, and \V, in contrast to the  other  sequences,
-       which  match  only ASCII characters by default, always match a specific
-       list of code points, whether or not PCRE2_UCP is  set.  The  horizontal
+       The  sequences  \h, \H, \v, and \V, in contrast to the other sequences,
+       which match only ASCII characters by default, always match  a  specific
+       list  of  code  points, whether or not PCRE2_UCP is set. The horizontal
        space characters are:
 
          U+0009     Horizontal tab (HT)
@@ -6178,36 +6179,36 @@ BACKSLASH
          U+2028     Line separator
          U+2029     Paragraph separator
 
-       In  8-bit,  non-UTF-8  mode,  only the characters with code points less
+       In 8-bit, non-UTF-8 mode, only the characters  with  code  points  less
        than 256 are relevant.
 
    Newline sequences
 
-       Outside a character class, by default, the escape sequence  \R  matches
-       any  Unicode newline sequence. In 8-bit non-UTF-8 mode \R is equivalent
+       Outside  a  character class, by default, the escape sequence \R matches
+       any Unicode newline sequence. In 8-bit non-UTF-8 mode \R is  equivalent
        to the following:
 
          (?>\r\n|\n|\x0b|\f|\r|\x85)
 
-       This is an example of an "atomic group", details  of  which  are  given
+       This  is  an  example  of an "atomic group", details of which are given
        below.  This particular group matches either the two-character sequence
-       CR followed by LF, or  one  of  the  single  characters  LF  (linefeed,
-       U+000A),  VT  (vertical  tab, U+000B), FF (form feed, U+000C), CR (car-
-       riage return, U+000D), or NEL (next line, U+0085). Because this  is  an
-       atomic  group,  the  two-character sequence is treated as a single unit
+       CR  followed  by  LF,  or  one  of  the single characters LF (linefeed,
+       U+000A), VT (vertical tab, U+000B), FF (form feed,  U+000C),  CR  (car-
+       riage  return,  U+000D), or NEL (next line, U+0085). Because this is an
+       atomic group, the two-character sequence is treated as  a  single  unit
        that cannot be split.
 
-       In other modes, two additional characters whose codepoints are  greater
+       In  other modes, two additional characters whose codepoints are greater
        than 255 are added: LS (line separator, U+2028) and PS (paragraph sepa-
-       rator, U+2029).  Unicode support is not needed for these characters  to
+       rator,  U+2029).  Unicode support is not needed for these characters to
        be recognized.
 
        It is possible to restrict \R to match only CR, LF, or CRLF (instead of
-       the complete set  of  Unicode  line  endings)  by  setting  the  option
-       PCRE2_BSR_ANYCRLF  at  compile  time. (BSR is an abbrevation for "back-
+       the  complete  set  of  Unicode  line  endings)  by  setting the option
+       PCRE2_BSR_ANYCRLF at compile time. (BSR is an  abbrevation  for  "back-
        slash R".) This can be made the default when PCRE2 is built; if this is
-       the  case,  the other behaviour can be requested via the PCRE2_BSR_UNI-
-       CODE option. It is also possible to specify these settings by  starting
+       the case, the other behaviour can be requested via  the  PCRE2_BSR_UNI-
+       CODE  option. It is also possible to specify these settings by starting
        a pattern string with one of the following sequences:
 
          (*BSR_ANYCRLF)   CR, LF, or CRLF only
@@ -6215,79 +6216,79 @@ BACKSLASH
 
        These override the default and the options given to the compiling func-
        tion.  Note that these special settings, which are not Perl-compatible,
-       are  recognized only at the very start of a pattern, and that they must
-       be in upper case. If more than one of them is present, the last one  is
-       used.  They  can  be  combined with a change of newline convention; for
+       are recognized only at the very start of a pattern, and that they  must
+       be  in upper case. If more than one of them is present, the last one is
+       used. They can be combined with a change  of  newline  convention;  for
        example, a pattern can start with:
 
          (*ANY)(*BSR_ANYCRLF)
 
-       They can also be combined with the (*UTF) or (*UCP) special  sequences.
-       Inside  a  character  class,  \R  is  treated as an unrecognized escape
+       They  can also be combined with the (*UTF) or (*UCP) special sequences.
+       Inside a character class, \R  is  treated  as  an  unrecognized  escape
        sequence, and causes an error.
 
    Unicode character properties
 
-       When PCRE2 is built with Unicode support  (the  default),  three  addi-
-       tional  escape sequences that match characters with specific properties
-       are available. In 8-bit non-UTF-8 mode, these sequences are  of  course
-       limited  to  testing characters whose codepoints are less than 256, but
-       they do work in this mode.  In 32-bit non-UTF mode, codepoints  greater
-       than  0x10ffff  (the  Unicode  limit) may be encountered. These are all
-       treated as being in the Common script and with an unassigned type.  The
+       When  PCRE2  is  built  with Unicode support (the default), three addi-
+       tional escape sequences that match characters with specific  properties
+       are  available.  In 8-bit non-UTF-8 mode, these sequences are of course
+       limited to testing characters whose codepoints are less than  256,  but
+       they  do work in this mode.  In 32-bit non-UTF mode, codepoints greater
+       than 0x10ffff (the Unicode limit) may be  encountered.  These  are  all
+       treated  as being in the Common script and with an unassigned type. The
        extra escape sequences are:
 
          \p{xx}   a character with the xx property
          \P{xx}   a character without the xx property
          \X       a Unicode extended grapheme cluster
 
-       The  property  names represented by xx above are limited to the Unicode
+       The property names represented by xx above are limited to  the  Unicode
        script names, the general category properties, "Any", which matches any
        character  (including  newline),  and  some  special  PCRE2  properties
-       (described in the next section).  Other Perl properties such as  "InMu-
-       sicalSymbols"  are  not supported by PCRE2.  Note that \P{Any} does not
+       (described  in the next section).  Other Perl properties such as "InMu-
+       sicalSymbols" are not supported by PCRE2.  Note that \P{Any}  does  not
        match any characters, so always causes a match failure.
 
        Sets of Unicode characters are defined as belonging to certain scripts.
-       A  character from one of these sets can be matched using a script name.
+       A character from one of these sets can be matched using a script  name.
        For example:
 
          \p{Greek}
          \P{Han}
 
-       Those that are not part of an identified script are lumped together  as
+       Those  that are not part of an identified script are lumped together as
        "Common". The current list of scripts is:
 
-       Ahom,   Anatolian_Hieroglyphs,  Arabic,  Armenian,  Avestan,  Balinese,
-       Bamum, Bassa_Vah, Batak, Bengali, Bopomofo, Brahmi, Braille,  Buginese,
-       Buhid,  Canadian_Aboriginal,  Carian, Caucasian_Albanian, Chakma, Cham,
-       Cherokee,  Common,  Coptic,  Cuneiform,  Cypriot,  Cyrillic,   Deseret,
-       Devanagari,  Duployan,  Egyptian_Hieroglyphs,  Elbasan, Ethiopic, Geor-
-       gian, Glagolitic, Gothic,  Grantha,  Greek,  Gujarati,  Gurmukhi,  Han,
+       Ahom,  Anatolian_Hieroglyphs,  Arabic,  Armenian,  Avestan,   Balinese,
+       Bamum,  Bassa_Vah, Batak, Bengali, Bopomofo, Brahmi, Braille, Buginese,
+       Buhid, Canadian_Aboriginal, Carian, Caucasian_Albanian,  Chakma,  Cham,
+       Cherokee,   Common,  Coptic,  Cuneiform,  Cypriot,  Cyrillic,  Deseret,
+       Devanagari, Duployan, Egyptian_Hieroglyphs,  Elbasan,  Ethiopic,  Geor-
+       gian,  Glagolitic,  Gothic,  Grantha,  Greek,  Gujarati, Gurmukhi, Han,
        Hangul, Hanunoo, Hatran, Hebrew, Hiragana, Imperial_Aramaic, Inherited,
-       Inscriptional_Pahlavi, Inscriptional_Parthian, Javanese,  Kaithi,  Kan-
-       nada,  Katakana,  Kayah_Li,  Kharoshthi, Khmer, Khojki, Khudawadi, Lao,
-       Latin, Lepcha, Limbu, Linear_A, Linear_B, Lisu, Lycian,  Lydian,  Maha-
+       Inscriptional_Pahlavi,  Inscriptional_Parthian,  Javanese, Kaithi, Kan-
+       nada, Katakana, Kayah_Li, Kharoshthi, Khmer,  Khojki,  Khudawadi,  Lao,
+       Latin,  Lepcha,  Limbu, Linear_A, Linear_B, Lisu, Lycian, Lydian, Maha-
        jani,  Malayalam,  Mandaic,  Manichaean,  Meetei_Mayek,  Mende_Kikakui,
-       Meroitic_Cursive, Meroitic_Hieroglyphs,  Miao,  Modi,  Mongolian,  Mro,
-       Multani,   Myanmar,   Nabataean,  New_Tai_Lue,  Nko,  Ogham,  Ol_Chiki,
-       Old_Hungarian, Old_Italic, Old_North_Arabian, Old_Permic,  Old_Persian,
+       Meroitic_Cursive,  Meroitic_Hieroglyphs,  Miao,  Modi,  Mongolian, Mro,
+       Multani,  Myanmar,  Nabataean,  New_Tai_Lue,  Nko,   Ogham,   Ol_Chiki,
+       Old_Hungarian,  Old_Italic, Old_North_Arabian, Old_Permic, Old_Persian,
        Old_South_Arabian, Old_Turkic, Oriya, Osmanya, Pahawh_Hmong, Palmyrene,
        Pau_Cin_Hau,  Phags_Pa,  Phoenician,  Psalter_Pahlavi,  Rejang,  Runic,
        Samaritan, Saurashtra, Sharada, Shavian, Siddham, SignWriting, Sinhala,
-       Sora_Sompeng,  Sundanese,  Syloti_Nagri,  Syriac,  Tagalog,   Tagbanwa,
-       Tai_Le,   Tai_Tham,  Tai_Viet,  Takri,  Tamil,  Telugu,  Thaana,  Thai,
+       Sora_Sompeng,   Sundanese,  Syloti_Nagri,  Syriac,  Tagalog,  Tagbanwa,
+       Tai_Le,  Tai_Tham,  Tai_Viet,  Takri,  Tamil,  Telugu,  Thaana,   Thai,
        Tibetan, Tifinagh, Tirhuta, Ugaritic, Vai, Warang_Citi, Yi.
 
        Each character has exactly one Unicode general category property, spec-
-       ified  by a two-letter abbreviation. For compatibility with Perl, nega-
-       tion can be specified by including a  circumflex  between  the  opening
-       brace  and  the  property  name.  For  example,  \p{^Lu} is the same as
+       ified by a two-letter abbreviation. For compatibility with Perl,  nega-
+       tion  can  be  specified  by including a circumflex between the opening
+       brace and the property name.  For  example,  \p{^Lu}  is  the  same  as
        \P{Lu}.
 
        If only one letter is specified with \p or \P, it includes all the gen-
-       eral  category properties that start with that letter. In this case, in
-       the absence of negation, the curly brackets in the escape sequence  are
+       eral category properties that start with that letter. In this case,  in
+       the  absence of negation, the curly brackets in the escape sequence are
        optional; these two examples have the same effect:
 
          \p{L}
@@ -6339,59 +6340,59 @@ BACKSLASH
          Zp    Paragraph separator
          Zs    Space separator
 
-       The  special property L& is also supported: it matches a character that
-       has the Lu, Ll, or Lt property, in other words, a letter  that  is  not
+       The special property L& is also supported: it matches a character  that
+       has  the  Lu,  Ll, or Lt property, in other words, a letter that is not
        classified as a modifier or "other".
 
-       The  Cs  (Surrogate)  property  applies only to characters in the range
-       U+D800 to U+DFFF. Such characters are not valid in Unicode strings  and
-       so  cannot  be  tested  by PCRE2, unless UTF validity checking has been
-       turned off (see the discussion of PCRE2_NO_UTF_CHECK  in  the  pcre2api
+       The Cs (Surrogate) property applies only to  characters  in  the  range
+       U+D800  to U+DFFF. Such characters are not valid in Unicode strings and
+       so cannot be tested by PCRE2, unless UTF  validity  checking  has  been
+       turned  off  (see  the discussion of PCRE2_NO_UTF_CHECK in the pcre2api
        page). Perl does not support the Cs property.
 
-       The  long  synonyms  for  property  names  that  Perl supports (such as
-       \p{Letter}) are not supported by PCRE2, nor is it permitted  to  prefix
+       The long synonyms for  property  names  that  Perl  supports  (such  as
+       \p{Letter})  are  not supported by PCRE2, nor is it permitted to prefix
        any of these properties with "Is".
 
        No character that is in the Unicode table has the Cn (unassigned) prop-
        erty.  Instead, this property is assumed for any code point that is not
        in the Unicode table.
 
-       Specifying  caseless  matching  does not affect these escape sequences.
-       For example, \p{Lu} always matches only upper  case  letters.  This  is
+       Specifying caseless matching does not affect  these  escape  sequences.
+       For  example,  \p{Lu}  always  matches only upper case letters. This is
        different from the behaviour of current versions of Perl.
 
-       Matching  characters by Unicode property is not fast, because PCRE2 has
-       to do a multistage table lookup in order to find  a  character's  prop-
+       Matching characters by Unicode property is not fast, because PCRE2  has
+       to  do  a  multistage table lookup in order to find a character's prop-
        erty. That is why the traditional escape sequences such as \d and \w do
-       not use Unicode properties in PCRE2 by default,  though  you  can  make
-       them  do  so by setting the PCRE2_UCP option or by starting the pattern
+       not  use  Unicode  properties  in PCRE2 by default, though you can make
+       them do so by setting the PCRE2_UCP option or by starting  the  pattern
        with (*UCP).
 
    Extended grapheme clusters
 
-       The \X escape matches any number of Unicode  characters  that  form  an
+       The  \X  escape  matches  any number of Unicode characters that form an
        "extended grapheme cluster", and treats the sequence as an atomic group
-       (see below).  Unicode supports various kinds of composite character  by
-       giving  each  character  a grapheme breaking property, and having rules
+       (see  below).  Unicode supports various kinds of composite character by
+       giving each character a grapheme breaking property,  and  having  rules
        that use these properties to define the boundaries of extended grapheme
-       clusters.  \X  always  matches  at least one character. Then it decides
-       whether to add additional characters according to the  following  rules
+       clusters. \X always matches at least one  character.  Then  it  decides
+       whether  to  add additional characters according to the following rules
        for ending a cluster:
 
        1. End at the end of the subject string.
 
-       2.  Do not end between CR and LF; otherwise end after any control char-
+       2. Do not end between CR and LF; otherwise end after any control  char-
        acter.
 
-       3. Do not break Hangul (a Korean  script)  syllable  sequences.  Hangul
-       characters  are of five types: L, V, T, LV, and LVT. An L character may
-       be followed by an L, V, LV, or LVT character; an LV or V character  may
+       3.  Do  not  break  Hangul (a Korean script) syllable sequences. Hangul
+       characters are of five types: L, V, T, LV, and LVT. An L character  may
+       be  followed by an L, V, LV, or LVT character; an LV or V character may
        be followed by a V or T character; an LVT or T character may be follwed
        only by a T character.
 
-       4. Do not end before extending characters or spacing marks.  Characters
-       with  the  "mark"  property  always have the "extend" grapheme breaking
+       4.  Do not end before extending characters or spacing marks. Characters
+       with the "mark" property always have  the  "extend"  grapheme  breaking
        property.
 
        5. Do not end after prepend characters.
@@ -6400,10 +6401,10 @@ BACKSLASH
 
    PCRE2's additional properties
 
-       As well as the standard Unicode properties described above, PCRE2  sup-
-       ports  four  more  that  make it possible to convert traditional escape
+       As  well as the standard Unicode properties described above, PCRE2 sup-
+       ports four more that make it possible  to  convert  traditional  escape
        sequences such as \w and \s to use Unicode properties. PCRE2 uses these
-       non-standard,  non-Perl  properties  internally  when PCRE2_UCP is set.
+       non-standard, non-Perl properties internally  when  PCRE2_UCP  is  set.
        However, they may also be used explicitly. These properties are:
 
          Xan   Any alphanumeric character
@@ -6411,53 +6412,53 @@ BACKSLASH
          Xsp   Any Perl space character
          Xwd   Any Perl "word" character
 
-       Xan matches characters that have either the L (letter) or the  N  (num-
-       ber)  property. Xps matches the characters tab, linefeed, vertical tab,
-       form feed, or carriage return, and any other character that has  the  Z
-       (separator)  property.   Xsp  is  the  same as Xps; in PCRE1 it used to
-       exclude vertical tab, for Perl compatibility,  but  Perl  changed.  Xwd
+       Xan  matches  characters that have either the L (letter) or the N (num-
+       ber) property. Xps matches the characters tab, linefeed, vertical  tab,
+       form  feed,  or carriage return, and any other character that has the Z
+       (separator) property.  Xsp is the same as Xps;  in  PCRE1  it  used  to
+       exclude  vertical  tab,  for  Perl compatibility, but Perl changed. Xwd
        matches the same characters as Xan, plus underscore.
 
-       There  is another non-standard property, Xuc, which matches any charac-
-       ter that can be represented by a Universal Character Name  in  C++  and
-       other  programming  languages.  These are the characters $, @, ` (grave
-       accent), and all characters with Unicode code points  greater  than  or
-       equal  to U+00A0, except for the surrogates U+D800 to U+DFFF. Note that
-       most base (ASCII) characters are excluded. (Universal  Character  Names
-       are  of  the  form \uHHHH or \UHHHHHHHH where H is a hexadecimal digit.
+       There is another non-standard property, Xuc, which matches any  charac-
+       ter  that  can  be represented by a Universal Character Name in C++ and
+       other programming languages. These are the characters $,  @,  `  (grave
+       accent),  and  all  characters with Unicode code points greater than or
+       equal to U+00A0, except for the surrogates U+D800 to U+DFFF. Note  that
+       most  base  (ASCII) characters are excluded. (Universal Character Names
+       are of the form \uHHHH or \UHHHHHHHH where H is  a  hexadecimal  digit.
        Note that the Xuc property does not match these sequences but the char-
        acters that they represent.)
 
    Resetting the match start
 
-       The  escape sequence \K causes any previously matched characters not to
+       The escape sequence \K causes any previously matched characters not  to
        be included in the final matched sequence. For example, the pattern:
 
          foo\Kbar
 
-       matches "foobar", but reports that it has matched "bar".  This  feature
-       is  similar  to  a lookbehind assertion (described below).  However, in
-       this case, the part of the subject before the real match does not  have
-       to  be of fixed length, as lookbehind assertions do. The use of \K does
-       not interfere with the setting of captured  substrings.   For  example,
+       matches  "foobar",  but reports that it has matched "bar". This feature
+       is similar to a lookbehind assertion (described  below).   However,  in
+       this  case, the part of the subject before the real match does not have
+       to be of fixed length, as lookbehind assertions do. The use of \K  does
+       not  interfere  with  the setting of captured substrings.  For example,
        when the pattern
 
          (foo)\Kbar
 
        matches "foobar", the first substring is still set to "foo".
 
-       Perl  documents  that  the  use  of  \K  within assertions is "not well
-       defined". In PCRE2, \K is acted upon when  it  occurs  inside  positive
-       assertions,  but  is  ignored  in negative assertions. Note that when a
-       pattern such as (?=ab\K) matches, the reported start of the  match  can
+       Perl documents that the use  of  \K  within  assertions  is  "not  well
+       defined".  In  PCRE2,  \K  is acted upon when it occurs inside positive
+       assertions, but is ignored in negative assertions.  Note  that  when  a
+       pattern  such  as (?=ab\K) matches, the reported start of the match can
        be greater than the end of the match.
 
    Simple assertions
 
-       The  final use of backslash is for certain simple assertions. An asser-
-       tion specifies a condition that has to be met at a particular point  in
-       a  match, without consuming any characters from the subject string. The
-       use of subpatterns for more complicated assertions is described  below.
+       The final use of backslash is for certain simple assertions. An  asser-
+       tion  specifies a condition that has to be met at a particular point in
+       a match, without consuming any characters from the subject string.  The
+       use  of subpatterns for more complicated assertions is described below.
        The backslashed assertions are:
 
          \b     matches at a word boundary
@@ -6468,184 +6469,184 @@ BACKSLASH
          \z     matches only at the end of the subject
          \G     matches at the first matching position in the subject
 
-       Inside  a  character  class, \b has a different meaning; it matches the
-       backspace character. If any other of  these  assertions  appears  in  a
+       Inside a character class, \b has a different meaning;  it  matches  the
+       backspace  character.  If  any  other  of these assertions appears in a
        character class, an "invalid escape sequence" error is generated.
 
-       A  word  boundary is a position in the subject string where the current
-       character and the previous character do not both match \w or  \W  (i.e.
-       one  matches  \w  and the other matches \W), or the start or end of the
-       string if the first or last character matches \w,  respectively.  In  a
-       UTF  mode,  the  meanings  of  \w  and \W can be changed by setting the
+       A word boundary is a position in the subject string where  the  current
+       character  and  the previous character do not both match \w or \W (i.e.
+       one matches \w and the other matches \W), or the start or  end  of  the
+       string  if  the  first or last character matches \w, respectively. In a
+       UTF mode, the meanings of \w and \W  can  be  changed  by  setting  the
        PCRE2_UCP option. When this is done, it also affects \b and \B. Neither
-       PCRE2  nor Perl has a separate "start of word" or "end of word" metase-
-       quence. However, whatever follows \b normally determines which  it  is.
+       PCRE2 nor Perl has a separate "start of word" or "end of word"  metase-
+       quence.  However,  whatever follows \b normally determines which it is.
        For example, the fragment \ba matches "a" at the start of a word.
 
-       The  \A,  \Z,  and \z assertions differ from the traditional circumflex
+       The \A, \Z, and \z assertions differ from  the  traditional  circumflex
        and dollar (described in the next section) in that they only ever match
-       at  the  very start and end of the subject string, whatever options are
-       set. Thus, they are independent of multiline mode. These  three  asser-
-       tions  are  not  affected  by the PCRE2_NOTBOL or PCRE2_NOTEOL options,
-       which affect only the behaviour of the circumflex and dollar  metachar-
-       acters.  However,  if the startoffset argument of pcre2_match() is non-
-       zero, indicating that matching is to start at a point  other  than  the
-       beginning  of  the subject, \A can never match.  The difference between
-       \Z and \z is that \Z matches before a newline at the end of the  string
+       at the very start and end of the subject string, whatever  options  are
+       set.  Thus,  they are independent of multiline mode. These three asser-
+       tions are not affected by the  PCRE2_NOTBOL  or  PCRE2_NOTEOL  options,
+       which  affect only the behaviour of the circumflex and dollar metachar-
+       acters. However, if the startoffset argument of pcre2_match()  is  non-
+       zero,  indicating  that  matching is to start at a point other than the
+       beginning of the subject, \A can never match.  The  difference  between
+       \Z  and \z is that \Z matches before a newline at the end of the string
        as well as at the very end, whereas \z matches only at the end.
 
-       The  \G assertion is true only when the current matching position is at
-       the start point of the match, as specified by the startoffset  argument
-       of  pcre2_match().  It differs from \A when the value of startoffset is
-       non-zero. By calling  pcre2_match()  multiple  times  with  appropriate
-       arguments,  you  can  mimic Perl's /g option, and it is in this kind of
+       The \G assertion is true only when the current matching position is  at
+       the  start point of the match, as specified by the startoffset argument
+       of pcre2_match(). It differs from \A when the value of  startoffset  is
+       non-zero.  By  calling  pcre2_match()  multiple  times with appropriate
+       arguments, you can mimic Perl's /g option, and it is in  this  kind  of
        implementation where \G can be useful.
 
-       Note, however, that PCRE2's interpretation of \G, as the start  of  the
+       Note,  however,  that PCRE2's interpretation of \G, as the start of the
        current match, is subtly different from Perl's, which defines it as the
-       end of the previous match. In Perl, these can  be  different  when  the
-       previously  matched string was empty. Because PCRE2 does just one match
+       end  of  the  previous  match. In Perl, these can be different when the
+       previously matched string was empty. Because PCRE2 does just one  match
        at a time, it cannot reproduce this behaviour.
 
-       If all the alternatives of a pattern begin with \G, the  expression  is
+       If  all  the alternatives of a pattern begin with \G, the expression is
        anchored to the starting match position, and the "anchored" flag is set
        in the compiled regular expression.
 
 
 CIRCUMFLEX AND DOLLAR
 
-       The circumflex and dollar  metacharacters  are  zero-width  assertions.
-       That  is,  they test for a particular condition being true without con-
+       The  circumflex  and  dollar  metacharacters are zero-width assertions.
+       That is, they test for a particular condition being true  without  con-
        suming any characters from the subject string. These two metacharacters
-       are  concerned  with matching the starts and ends of lines. If the new-
-       line convention is set so that only the two-character sequence CRLF  is
-       recognized  as  a newline, isolated CR and LF characters are treated as
+       are concerned with matching the starts and ends of lines. If  the  new-
+       line  convention is set so that only the two-character sequence CRLF is
+       recognized as a newline, isolated CR and LF characters are  treated  as
        ordinary data characters, and are not recognized as newlines.
 
        Outside a character class, in the default matching mode, the circumflex
-       character  is  an  assertion  that is true only if the current matching
-       point is at the start of the subject string. If the  startoffset  argu-
-       ment  of  pcre2_match() is non-zero, or if PCRE2_NOTBOL is set, circum-
-       flex can never match if the PCRE2_MULTILINE option is unset.  Inside  a
-       character  class,  circumflex  has  an  entirely different meaning (see
+       character is an assertion that is true only  if  the  current  matching
+       point  is  at the start of the subject string. If the startoffset argu-
+       ment of pcre2_match() is non-zero, or if PCRE2_NOTBOL is  set,  circum-
+       flex  can  never match if the PCRE2_MULTILINE option is unset. Inside a
+       character class, circumflex has  an  entirely  different  meaning  (see
        below).
 
-       Circumflex need not be the first character of the pattern if  a  number
-       of  alternatives are involved, but it should be the first thing in each
-       alternative in which it appears if the pattern is ever  to  match  that
-       branch.  If all possible alternatives start with a circumflex, that is,
-       if the pattern is constrained to match only at the start  of  the  sub-
-       ject,  it  is  said  to be an "anchored" pattern. (There are also other
+       Circumflex  need  not be the first character of the pattern if a number
+       of alternatives are involved, but it should be the first thing in  each
+       alternative  in  which  it appears if the pattern is ever to match that
+       branch. If all possible alternatives start with a circumflex, that  is,
+       if  the  pattern  is constrained to match only at the start of the sub-
+       ject, it is said to be an "anchored" pattern.  (There  are  also  other
        constructs that can cause a pattern to be anchored.)
 
-       The dollar character is an assertion that is true only if  the  current
-       matching  point  is  at  the  end of the subject string, or immediately
-       before a newline  at  the  end  of  the  string  (by  default),  unless
+       The  dollar  character is an assertion that is true only if the current
+       matching point is at the end of  the  subject  string,  or  immediately
+       before  a  newline  at  the  end  of  the  string  (by default), unless
        PCRE2_NOTEOL is set. Note, however, that it does not actually match the
        newline. Dollar need not be the last character of the pattern if a num-
        ber of alternatives are involved, but it should be the last item in any
-       branch in which it appears. Dollar has no special meaning in a  charac-
+       branch  in which it appears. Dollar has no special meaning in a charac-
        ter class.
 
-       The  meaning  of  dollar  can be changed so that it matches only at the
-       very end of the string, by setting the PCRE2_DOLLAR_ENDONLY  option  at
+       The meaning of dollar can be changed so that it  matches  only  at  the
+       very  end  of the string, by setting the PCRE2_DOLLAR_ENDONLY option at
        compile time. This does not affect the \Z assertion.
 
        The meanings of the circumflex and dollar metacharacters are changed if
-       the PCRE2_MULTILINE option is set. When this  is  the  case,  a  dollar
-       character  matches before any newlines in the string, as well as at the
-       very end, and a circumflex matches immediately after internal  newlines
-       as  well as at the start of the subject string. It does not match after
-       a newline that ends the string, for compatibility with  Perl.  However,
+       the  PCRE2_MULTILINE  option  is  set.  When this is the case, a dollar
+       character matches before any newlines in the string, as well as at  the
+       very  end, and a circumflex matches immediately after internal newlines
+       as well as at the start of the subject string. It does not match  after
+       a  newline  that ends the string, for compatibility with Perl. However,
        this can be changed by setting the PCRE2_ALT_CIRCUMFLEX option.
 
-       For  example, the pattern /^abc$/ matches the subject string "def\nabc"
-       (where \n represents a newline) in multiline mode, but  not  otherwise.
-       Consequently,  patterns  that  are anchored in single line mode because
-       all branches start with ^ are not anchored in  multiline  mode,  and  a
-       match  for  circumflex  is  possible  when  the startoffset argument of
-       pcre2_match() is non-zero. The PCRE2_DOLLAR_ENDONLY option  is  ignored
+       For example, the pattern /^abc$/ matches the subject string  "def\nabc"
+       (where  \n  represents a newline) in multiline mode, but not otherwise.
+       Consequently, patterns that are anchored in single  line  mode  because
+       all  branches  start  with  ^ are not anchored in multiline mode, and a
+       match for circumflex is  possible  when  the  startoffset  argument  of
+       pcre2_match()  is  non-zero. The PCRE2_DOLLAR_ENDONLY option is ignored
        if PCRE2_MULTILINE is set.
 
-       When  the  newline  convention (see "Newline conventions" below) recog-
-       nizes the two-character sequence CRLF as a newline, this is  preferred,
-       even  if  the  single  characters CR and LF are also recognized as new-
-       lines. For example, if the newline convention  is  "any",  a  multiline
-       mode  circumflex matches before "xyz" in the string "abc\r\nxyz" rather
-       than after CR, even though CR on its own is a valid newline.  (It  also
+       When the newline convention (see "Newline  conventions"  below)  recog-
+       nizes  the two-character sequence CRLF as a newline, this is preferred,
+       even if the single characters CR and LF are  also  recognized  as  new-
+       lines.  For  example,  if  the newline convention is "any", a multiline
+       mode circumflex matches before "xyz" in the string "abc\r\nxyz"  rather
+       than  after  CR, even though CR on its own is a valid newline. (It also
        matches at the very start of the string, of course.)
 
-       Note  that  the sequences \A, \Z, and \z can be used to match the start
-       and end of the subject in both modes, and if all branches of a  pattern
-       start  with \A it is always anchored, whether or not PCRE2_MULTILINE is
+       Note that the sequences \A, \Z, and \z can be used to match  the  start
+       and  end of the subject in both modes, and if all branches of a pattern
+       start with \A it is always anchored, whether or not PCRE2_MULTILINE  is
        set.
 
 
 FULL STOP (PERIOD, DOT) AND \N
 
        Outside a character class, a dot in the pattern matches any one charac-
-       ter  in  the subject string except (by default) a character that signi-
+       ter in the subject string except (by default) a character  that  signi-
        fies the end of a line.
 
-       When a line ending is defined as a single character, dot never  matches
-       that  character; when the two-character sequence CRLF is used, dot does
-       not match CR if it is immediately followed  by  LF,  but  otherwise  it
-       matches  all characters (including isolated CRs and LFs). When any Uni-
-       code line endings are being recognized, dot does not match CR or LF  or
+       When  a line ending is defined as a single character, dot never matches
+       that character; when the two-character sequence CRLF is used, dot  does
+       not  match  CR  if  it  is immediately followed by LF, but otherwise it
+       matches all characters (including isolated CRs and LFs). When any  Uni-
+       code  line endings are being recognized, dot does not match CR or LF or
        any of the other line ending characters.
 
-       The  behaviour  of  dot  with regard to newlines can be changed. If the
-       PCRE2_DOTALL option is set, a dot matches any  one  character,  without
-       exception.   If  the two-character sequence CRLF is present in the sub-
+       The behaviour of dot with regard to newlines can  be  changed.  If  the
+       PCRE2_DOTALL  option  is  set, a dot matches any one character, without
+       exception.  If the two-character sequence CRLF is present in  the  sub-
        ject string, it takes two dots to match it.
 
-       The handling of dot is entirely independent of the handling of  circum-
-       flex  and  dollar,  the  only relationship being that they both involve
+       The  handling of dot is entirely independent of the handling of circum-
+       flex and dollar, the only relationship being  that  they  both  involve
        newlines. Dot has no special meaning in a character class.
 
-       The escape sequence \N behaves like  a  dot,  except  that  it  is  not
-       affected  by  the  PCRE2_DOTALL  option. In other words, it matches any
-       character except one that signifies the end of a line. Perl  also  uses
+       The  escape  sequence  \N  behaves  like  a  dot, except that it is not
+       affected by the PCRE2_DOTALL option. In other  words,  it  matches  any
+       character  except  one that signifies the end of a line. Perl also uses
        \N to match characters by name; PCRE2 does not support this.
 
 
 MATCHING A SINGLE CODE UNIT
 
-       Outside  a character class, the escape sequence \C matches any one code
-       unit, whether or not a UTF mode is set. In the 8-bit library, one  code
-       unit  is  one  byte;  in the 16-bit library it is a 16-bit unit; in the
-       32-bit library it is a 32-bit unit. Unlike a  dot,  \C  always  matches
-       line-ending  characters.  The  feature  is provided in Perl in order to
+       Outside a character class, the escape sequence \C matches any one  code
+       unit,  whether or not a UTF mode is set. In the 8-bit library, one code
+       unit is one byte; in the 16-bit library it is a  16-bit  unit;  in  the
+       32-bit  library  it  is  a 32-bit unit. Unlike a dot, \C always matches
+       line-ending characters. The feature is provided in  Perl  in  order  to
        match individual bytes in UTF-8 mode, but it is unclear how it can use-
        fully be used.
 
-       Because  \C  breaks  up characters into individual code units, matching
-       one unit with \C in UTF-8 or UTF-16 mode means that  the  rest  of  the
-       string  may  start  with  a malformed UTF character. This has undefined
+       Because \C breaks up characters into individual  code  units,  matching
+       one  unit  with  \C  in UTF-8 or UTF-16 mode means that the rest of the
+       string may start with a malformed UTF  character.  This  has  undefined
        results, because PCRE2 assumes that it is matching character by charac-
-       ter  in  a  valid UTF string (by default it checks the subject string's
-       validity at the  start  of  processing  unless  the  PCRE2_NO_UTF_CHECK
+       ter in a valid UTF string (by default it checks  the  subject  string's
+       validity  at  the  start  of  processing  unless the PCRE2_NO_UTF_CHECK
        option is used).
 
-       An   application   can   lock   out  the  use  of  \C  by  setting  the
-       PCRE2_NEVER_BACKSLASH_C option when compiling a  pattern.  It  is  also
+       An  application  can  lock  out  the  use  of   \C   by   setting   the
+       PCRE2_NEVER_BACKSLASH_C  option  when  compiling  a pattern. It is also
        possible to build PCRE2 with the use of \C permanently disabled.
 
-       PCRE2  does  not allow \C to appear in lookbehind assertions (described
-       below) in UTF-8 or UTF-16 modes, because this would make it  impossible
-       to  calculate  the  length  of  the lookbehind. Neither the alternative
+       PCRE2 does not allow \C to appear in lookbehind  assertions  (described
+       below)  in UTF-8 or UTF-16 modes, because this would make it impossible
+       to calculate the length of  the  lookbehind.  Neither  the  alternative
        matching function pcre2_dfa_match() nor the JIT optimizer support \C in
        these UTF modes.  The former gives a match-time error; the latter fails
        to optimize and so the match is always run using the interpreter.
 
-       In the 32-bit library,  however,  \C  is  always  supported  (when  not
-       explicitly  locked  out)  because it always matches a single code unit,
+       In  the  32-bit  library,  however,  \C  is  always supported (when not
+       explicitly locked out) because it always matches a  single  code  unit,
        whether or not UTF-32 is specified.
 
        In general, the \C escape sequence is best avoided. However, one way of
-       using  it  that avoids the problem of malformed UTF-8 or UTF-16 charac-
-       ters is to use a lookahead to check the length of the  next  character,
-       as  in  this  pattern,  which could be used with a UTF-8 string (ignore
+       using it that avoids the problem of malformed UTF-8 or  UTF-16  charac-
+       ters  is  to use a lookahead to check the length of the next character,
+       as in this pattern, which could be used with  a  UTF-8  string  (ignore
        white space and line breaks):
 
          (?| (?=[\x00-\x7f])(\C) |
@@ -6653,10 +6654,10 @@ MATCHING A SINGLE CODE UNIT
              (?=[\x{800}-\x{ffff}])(\C)(\C)(\C) |
              (?=[\x{10000}-\x{1fffff}])(\C)(\C)(\C)(\C))
 
-       In this example, a group that starts  with  (?|  resets  the  capturing
+       In  this  example,  a  group  that starts with (?| resets the capturing
        parentheses numbers in each alternative (see "Duplicate Subpattern Num-
        bers" below). The assertions at the start of each branch check the next
-       UTF-8  character  for  values  whose encoding uses 1, 2, 3, or 4 bytes,
+       UTF-8 character for values whose encoding uses 1, 2,  3,  or  4  bytes,
        respectively. The character's individual bytes are then captured by the
        appropriate number of \C groups.
 
@@ -6665,105 +6666,105 @@ SQUARE BRACKETS AND CHARACTER CLASSES
 
        An opening square bracket introduces a character class, terminated by a
        closing square bracket. A closing square bracket on its own is not spe-
-       cial  by  default.  If a closing square bracket is required as a member
+       cial by default.  If a closing square bracket is required as  a  member
        of the class, it should be the first data character in the class (after
-       an  initial  circumflex,  if present) or escaped with a backslash. This
-       means that, by default, an empty class cannot be defined.  However,  if
-       the  PCRE2_ALLOW_EMPTY_CLASS option is set, a closing square bracket at
+       an initial circumflex, if present) or escaped with  a  backslash.  This
+       means  that,  by default, an empty class cannot be defined. However, if
+       the PCRE2_ALLOW_EMPTY_CLASS option is set, a closing square bracket  at
        the start does end the (empty) class.
 
-       A character class matches a single character in the subject. A  matched
+       A  character class matches a single character in the subject. A matched
        character must be in the set of characters defined by the class, unless
-       the first character in the class definition is a circumflex,  in  which
+       the  first  character in the class definition is a circumflex, in which
        case the subject character must not be in the set defined by the class.
-       If a circumflex is actually required as a member of the  class,  ensure
+       If  a  circumflex is actually required as a member of the class, ensure
        it is not the first character, or escape it with a backslash.
 
-       For  example, the character class [aeiou] matches any lower case vowel,
-       while [^aeiou] matches any character that is not a  lower  case  vowel.
+       For example, the character class [aeiou] matches any lower case  vowel,
+       while  [^aeiou]  matches  any character that is not a lower case vowel.
        Note that a circumflex is just a convenient notation for specifying the
-       characters that are in the class by enumerating those that are  not.  A
-       class  that starts with a circumflex is not an assertion; it still con-
-       sumes a character from the subject string, and therefore  it  fails  if
+       characters  that  are in the class by enumerating those that are not. A
+       class that starts with a circumflex is not an assertion; it still  con-
+       sumes  a  character  from the subject string, and therefore it fails if
        the current pointer is at the end of the string.
 
-       When  caseless  matching  is set, any letters in a class represent both
-       their upper case and lower case versions, so for  example,  a  caseless
-       [aeiou]  matches  "A"  as well as "a", and a caseless [^aeiou] does not
+       When caseless matching is set, any letters in a  class  represent  both
+       their  upper  case  and lower case versions, so for example, a caseless
+       [aeiou] matches "A" as well as "a", and a caseless  [^aeiou]  does  not
        match "A", whereas a caseful version would.
 
-       Characters that might indicate line breaks are  never  treated  in  any
-       special  way  when  matching  character  classes,  whatever line-ending
-       sequence is in use,  and  whatever  setting  of  the  PCRE2_DOTALL  and
-       PCRE2_MULTILINE  options  is  used. A class such as [^a] always matches
+       Characters  that  might  indicate  line breaks are never treated in any
+       special way  when  matching  character  classes,  whatever  line-ending
+       sequence  is  in  use,  and  whatever  setting  of the PCRE2_DOTALL and
+       PCRE2_MULTILINE options is used. A class such as  [^a]  always  matches
        one of these characters.
 
-       The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v,  \V,
+       The  character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V,
        \w, and \W may appear in a character class, and add the characters that
-       they match to the class. For example, [\dABCDEF] matches any  hexadeci-
-       mal  digit.  In UTF modes, the PCRE2_UCP option affects the meanings of
-       \d, \s, \w and their upper case partners, just as  it  does  when  they
-       appear  outside a character class, as described in the section entitled
+       they  match to the class. For example, [\dABCDEF] matches any hexadeci-
+       mal digit. In UTF modes, the PCRE2_UCP option affects the  meanings  of
+       \d,  \s,  \w  and  their upper case partners, just as it does when they
+       appear outside a character class, as described in the section  entitled
        "Generic character types" above. The escape sequence \b has a different
-       meaning  inside  a character class; it matches the backspace character.
-       The sequences \B, \N, \R, and \X are not  special  inside  a  character
-       class.  Like  any  other  unrecognized  escape sequences, they cause an
+       meaning inside a character class; it matches the  backspace  character.
+       The  sequences  \B,  \N,  \R, and \X are not special inside a character
+       class. Like any other unrecognized  escape  sequences,  they  cause  an
        error.
 
-       The minus (hyphen) character can be used to specify a range of  charac-
-       ters  in  a  character  class.  For  example,  [d-m] matches any letter
-       between d and m, inclusive. If a  minus  character  is  required  in  a
-       class,  it  must  be  escaped  with a backslash or appear in a position
-       where it cannot be interpreted as indicating a range, typically as  the
+       The  minus (hyphen) character can be used to specify a range of charac-
+       ters in a character  class.  For  example,  [d-m]  matches  any  letter
+       between  d  and  m,  inclusive.  If  a minus character is required in a
+       class, it must be escaped with a backslash  or  appear  in  a  position
+       where  it cannot be interpreted as indicating a range, typically as the
        first or last character in the class, or immediately after a range. For
-       example, [b-d-z] matches letters in the range b to d, a hyphen  charac-
+       example,  [b-d-z] matches letters in the range b to d, a hyphen charac-
        ter, or z.
 
        Perl treats a hyphen as a literal if it appears before or after a POSIX
        class (see below) or a character type escape such as as \d, but gives a
-       warning  in  its  warning mode, as this is most likely a user error. As
+       warning in its warning mode, as this is most likely a  user  error.  As
        PCRE2 has no facility for warning, an error is given in these cases.
 
        It is not possible to have the literal character "]" as the end charac-
-       ter  of a range. A pattern such as [W-]46] is interpreted as a class of
-       two characters ("W" and "-") followed by a literal string "46]", so  it
-       would  match  "W46]"  or  "-46]". However, if the "]" is escaped with a
-       backslash it is interpreted as the end of range, so [W-\]46] is  inter-
-       preted  as a class containing a range followed by two other characters.
-       The octal or hexadecimal representation of "]" can also be used to  end
+       ter of a range. A pattern such as [W-]46] is interpreted as a class  of
+       two  characters ("W" and "-") followed by a literal string "46]", so it
+       would match "W46]" or "-46]". However, if the "]"  is  escaped  with  a
+       backslash  it is interpreted as the end of range, so [W-\]46] is inter-
+       preted as a class containing a range followed by two other  characters.
+       The  octal or hexadecimal representation of "]" can also be used to end
        a range.
 
        Ranges normally include all code points between the start and end char-
-       acters, inclusive. They can also be  used  for  code  points  specified
+       acters,  inclusive.  They  can  also  be used for code points specified
        numerically, for example [\000-\037]. Ranges can include any characters
        that are valid for the current mode.
 
-       There is a special case in EBCDIC environments  for  ranges  whose  end
+       There  is  a  special  case in EBCDIC environments for ranges whose end
        points are both specified as literal letters in the same case. For com-
-       patibility with Perl, EBCDIC code points within the range that are  not
-       letters  are  omitted. For example, [h-k] matches only four characters,
+       patibility  with Perl, EBCDIC code points within the range that are not
+       letters are omitted. For example, [h-k] matches only  four  characters,
        even though the codes for h and k are 0x88 and 0x92, a range of 11 code
-       points.  However,  if  the range is specified numerically, for example,
+       points. However, if the range is specified  numerically,  for  example,
        [\x88-\x92] or [h-\x92], all code points are included.
 
        If a range that includes letters is used when caseless matching is set,
        it matches the letters in either case. For example, [W-c] is equivalent
-       to [][\\^_`wxyzabc], matched caselessly, and  in  a  non-UTF  mode,  if
-       character  tables  for  a French locale are in use, [\xc8-\xcb] matches
+       to  [][\\^_`wxyzabc],  matched  caselessly,  and  in a non-UTF mode, if
+       character tables for a French locale are in  use,  [\xc8-\xcb]  matches
        accented E characters in both cases.
 
-       A circumflex can conveniently be used with  the  upper  case  character
-       types  to specify a more restricted set of characters than the matching
-       lower case type.  For example, the class [^\W_] matches any  letter  or
+       A  circumflex  can  conveniently  be used with the upper case character
+       types to specify a more restricted set of characters than the  matching
+       lower  case  type.  For example, the class [^\W_] matches any letter or
        digit, but not underscore, whereas [\w] includes underscore. A positive
        character class should be read as "something OR something OR ..." and a
        negative class as "NOT something AND NOT something AND NOT ...".
 
-       The  only  metacharacters  that are recognized in character classes are
-       backslash, hyphen (only where it can be  interpreted  as  specifying  a
-       range),  circumflex  (only  at the start), opening square bracket (only
-       when it can be interpreted as introducing a POSIX class name, or for  a
-       special  compatibility  feature  -  see the next two sections), and the
+       The only metacharacters that are recognized in  character  classes  are
+       backslash,  hyphen  (only  where  it can be interpreted as specifying a
+       range), circumflex (only at the start), opening  square  bracket  (only
+       when  it can be interpreted as introducing a POSIX class name, or for a
+       special compatibility feature - see the next  two  sections),  and  the
        terminating  closing  square  bracket.  However,  escaping  other  non-
        alphanumeric characters does no harm.
 
@@ -6771,7 +6772,7 @@ SQUARE BRACKETS AND CHARACTER CLASSES
 POSIX CHARACTER CLASSES
 
        Perl supports the POSIX notation for character classes. This uses names
-       enclosed by [: and :] within the enclosing square brackets. PCRE2  also
+       enclosed  by [: and :] within the enclosing square brackets. PCRE2 also
        supports this notation. For example,
 
          [01[:alpha:]%]
@@ -6794,13 +6795,13 @@ POSIX CHARACTER CLASSES
          word     "word" characters (same as \w)
          xdigit   hexadecimal digits
 
-       The default "space" characters are HT (9), LF (10), VT (11),  FF  (12),
-       CR  (13),  and space (32). If locale-specific matching is taking place,
-       the list of space characters may be different; there may  be  fewer  or
+       The  default  "space" characters are HT (9), LF (10), VT (11), FF (12),
+       CR (13), and space (32). If locale-specific matching is  taking  place,
+       the  list  of  space characters may be different; there may be fewer or
        more of them. "Space" and \s match the same set of characters.
 
-       The  name  "word"  is  a Perl extension, and "blank" is a GNU extension
-       from Perl 5.8. Another Perl extension is negation, which  is  indicated
+       The name "word" is a Perl extension, and "blank"  is  a  GNU  extension
+       from  Perl  5.8. Another Perl extension is negation, which is indicated
        by a ^ character after the colon. For example,
 
          [12[:^digit:]]
@@ -6811,9 +6812,9 @@ POSIX CHARACTER CLASSES
 
        By default, characters with values greater than 127 do not match any of
        the POSIX character classes, although this may be different for charac-
-       ters  in  the range 128-255 when locale-specific matching is happening.
-       However, if the PCRE2_UCP option is passed to pcre2_compile(), some  of
-       the  classes are changed so that Unicode character properties are used.
+       ters in the range 128-255 when locale-specific matching  is  happening.
+       However,  if the PCRE2_UCP option is passed to pcre2_compile(), some of
+       the classes are changed so that Unicode character properties are  used.
        This  is  achieved  by  replacing  certain  POSIX  classes  with  other
        sequences, as follows:
 
@@ -6827,10 +6828,10 @@ POSIX CHARACTER CLASSES
          [:upper:]  becomes  \p{Lu}
          [:word:]   becomes  \p{Xwd}
 
-       Negated  versions, such as [:^alpha:] use \P instead of \p. Three other
+       Negated versions, such as [:^alpha:] use \P instead of \p. Three  other
        POSIX classes are handled specially in UCP mode:
 
-       [:graph:] This matches characters that have glyphs that mark  the  page
+       [:graph:] This  matches  characters that have glyphs that mark the page
                  when printed. In Unicode property terms, it matches all char-
                  acters with the L, M, N, P, S, or Cf properties, except for:
 
@@ -6839,59 +6840,59 @@ POSIX CHARACTER CLASSES
                    U+2066 - U+2069  Various "isolate"s
 
 
-       [:print:] This matches the same  characters  as  [:graph:]  plus  space
-                 characters  that  are  not controls, that is, characters with
+       [:print:] This  matches  the  same  characters  as [:graph:] plus space
+                 characters that are not controls, that  is,  characters  with
                  the Zs property.
 
        [:punct:] This matches all characters that have the Unicode P (punctua-
-                 tion)  property,  plus those characters with code points less
+                 tion) property, plus those characters with code  points  less
                  than 256 that have the S (Symbol) property.
 
-       The other POSIX classes are unchanged, and match only  characters  with
+       The  other  POSIX classes are unchanged, and match only characters with
        code points less than 256.
 
 
 COMPATIBILITY FEATURE FOR WORD BOUNDARIES
 
-       In  the POSIX.2 compliant library that was included in 4.4BSD Unix, the
-       ugly syntax [[:<:]] and [[:>:]] is used for matching  "start  of  word"
+       In the POSIX.2 compliant library that was included in 4.4BSD Unix,  the
+       ugly  syntax  [[:<:]]  and [[:>:]] is used for matching "start of word"
        and "end of word". PCRE2 treats these items as follows:
 
          [[:<:]]  is converted to  \b(?=\w)
          [[:>:]]  is converted to  \b(?<=\w)
 
        Only these exact character sequences are recognized. A sequence such as
-       [a[:<:]b] provokes error for an unrecognized  POSIX  class  name.  This
-       support  is not compatible with Perl. It is provided to help migrations
+       [a[:<:]b]  provokes  error  for  an unrecognized POSIX class name. This
+       support is not compatible with Perl. It is provided to help  migrations
        from other environments, and is best not used in any new patterns. Note
-       that  \b matches at the start and the end of a word (see "Simple asser-
-       tions" above), and in a Perl-style pattern the preceding  or  following
-       character  normally  shows  which  is  wanted, without the need for the
-       assertions that are used above in order to give exactly the  POSIX  be-
+       that \b matches at the start and the end of a word (see "Simple  asser-
+       tions"  above),  and in a Perl-style pattern the preceding or following
+       character normally shows which is wanted,  without  the  need  for  the
+       assertions  that  are used above in order to give exactly the POSIX be-
        haviour.
 
 
 VERTICAL BAR
 
-       Vertical  bar characters are used to separate alternative patterns. For
+       Vertical bar characters are used to separate alternative patterns.  For
        example, the pattern
 
          gilbert|sullivan
 
-       matches either "gilbert" or "sullivan". Any number of alternatives  may
-       appear,  and  an  empty  alternative  is  permitted (matching the empty
+       matches  either "gilbert" or "sullivan". Any number of alternatives may
+       appear, and an empty  alternative  is  permitted  (matching  the  empty
        string). The matching process tries each alternative in turn, from left
-       to  right, and the first one that succeeds is used. If the alternatives
-       are within a subpattern (defined below), "succeeds" means matching  the
+       to right, and the first one that succeeds is used. If the  alternatives
+       are  within a subpattern (defined below), "succeeds" means matching the
        rest of the main pattern as well as the alternative in the subpattern.
 
 
 INTERNAL OPTION SETTING
 
-       The  settings  of  the  PCRE2_CASELESS,  PCRE2_MULTILINE, PCRE2_DOTALL,
-       PCRE2_EXTENDED, PCRE2_EXTENDED_MORE, and PCRE2_NO_AUTO_CAPTURE  options
+       The settings  of  the  PCRE2_CASELESS,  PCRE2_MULTILINE,  PCRE2_DOTALL,
+       PCRE2_EXTENDED,  PCRE2_EXTENDED_MORE, and PCRE2_NO_AUTO_CAPTURE options
        (which are Perl-compatible) can be changed from within the pattern by a
-       sequence of Perl option letters enclosed  between  "(?"  and  ")".  The
+       sequence  of  Perl  option  letters  enclosed between "(?" and ")". The
        option letters are
 
          i  for PCRE2_CASELESS
@@ -6902,43 +6903,43 @@ INTERNAL OPTION SETTING
          xx for PCRE2_EXTENDED_MORE
 
        For example, (?im) sets caseless, multiline matching. It is also possi-
-       ble to unset these options by preceding the letter with a  hyphen.  The
-       two  "extended"  options are not independent; unsetting either one can-
+       ble  to  unset these options by preceding the letter with a hyphen. The
+       two "extended" options are not independent; unsetting either  one  can-
        cels the effects of both of them.
 
-       A  combined  setting  and  unsetting  such  as  (?im-sx),  which   sets
-       PCRE2_CASELESS  and  PCRE2_MULTILINE  while  unsetting PCRE2_DOTALL and
-       PCRE2_EXTENDED, is also permitted. If a letter appears both before  and
-       after  the  hyphen, the option is unset. An empty options setting "(?)"
+       A   combined  setting  and  unsetting  such  as  (?im-sx),  which  sets
+       PCRE2_CASELESS and PCRE2_MULTILINE  while  unsetting  PCRE2_DOTALL  and
+       PCRE2_EXTENDED,  is also permitted. If a letter appears both before and
+       after the hyphen, the option is unset. An empty options  setting  "(?)"
        is allowed. Needless to say, it has no effect.
 
-       The PCRE2-specific options PCRE2_DUPNAMES  and  PCRE2_UNGREEDY  can  be
-       changed  in  the  same  way as the Perl-compatible options by using the
+       The  PCRE2-specific  options  PCRE2_DUPNAMES  and PCRE2_UNGREEDY can be
+       changed in the same way as the Perl-compatible  options  by  using  the
        characters J and U respectively.
 
-       When one of these option changes occurs at  top  level  (that  is,  not
-       inside  subpattern parentheses), the change applies to the remainder of
-       the pattern that follows. An option change  within  a  subpattern  (see
-       below  for  a description of subpatterns) affects only that part of the
+       When  one  of  these  option  changes occurs at top level (that is, not
+       inside subpattern parentheses), the change applies to the remainder  of
+       the  pattern  that  follows.  An option change within a subpattern (see
+       below for a description of subpatterns) affects only that part  of  the
        subpattern that follows it, so
 
          (a(?i)b)c
 
-       matches abc and aBc and no other strings  (assuming  PCRE2_CASELESS  is
-       not  used).   By this means, options can be made to have different set-
+       matches  abc  and  aBc and no other strings (assuming PCRE2_CASELESS is
+       not used).  By this means, options can be made to have  different  set-
        tings in different parts of the pattern. Any changes made in one alter-
        native do carry on into subsequent branches within the same subpattern.
        For example,
 
          (a(?i)b|c)
 
-       matches "ab", "aB", "c", and "C", even though  when  matching  "C"  the
-       first  branch  is  abandoned before the option setting. This is because
-       the effects of option settings happen at compile time. There  would  be
+       matches  "ab",  "aB",  "c",  and "C", even though when matching "C" the
+       first branch is abandoned before the option setting.  This  is  because
+       the  effects  of option settings happen at compile time. There would be
        some very weird behaviour otherwise.
 
-       As  a  convenient shorthand, if any option settings are required at the
-       start of a non-capturing subpattern (see the next section), the  option
+       As a convenient shorthand, if any option settings are required  at  the
+       start  of a non-capturing subpattern (see the next section), the option
        letters may appear between the "?" and the ":". Thus the two patterns
 
          (?i:saturday|sunday)
@@ -6946,14 +6947,14 @@ INTERNAL OPTION SETTING
 
        match exactly the same set of strings.
 
-       Note:  There  are  other  PCRE2-specific options that can be set by the
+       Note: There are other PCRE2-specific options that can  be  set  by  the
        application when the compiling function is called. The pattern can con-
-       tain  special  leading  sequences  such as (*CRLF) to override what the
-       application has set or what has been defaulted. Details  are  given  in
-       the  section  entitled  "Newline  sequences"  above. There are also the
-       (*UTF) and (*UCP) leading sequences that can be used  to  set  UTF  and
-       Unicode  property  modes;  they are equivalent to setting the PCRE2_UTF
-       and PCRE2_UCP options, respectively. However, the application  can  set
+       tain special leading sequences such as (*CRLF)  to  override  what  the
+       application  has  set  or what has been defaulted. Details are given in
+       the section entitled "Newline sequences"  above.  There  are  also  the
+       (*UTF)  and  (*UCP)  leading  sequences that can be used to set UTF and
+       Unicode property modes; they are equivalent to  setting  the  PCRE2_UTF
+       and  PCRE2_UCP  options, respectively. However, the application can set
        the PCRE2_NEVER_UTF and PCRE2_NEVER_UCP options, which lock out the use
        of the (*UTF) and (*UCP) sequences.
 
@@ -6967,18 +6968,18 @@ SUBPATTERNS
 
          cat(aract|erpillar|)
 
-       matches  "cataract",  "caterpillar", or "cat". Without the parentheses,
+       matches "cataract", "caterpillar", or "cat". Without  the  parentheses,
        it would match "cataract", "erpillar" or an empty string.
 
-       2. It sets up the subpattern as  a  capturing  subpattern.  This  means
+       2.  It  sets  up  the  subpattern as a capturing subpattern. This means
        that, when the whole pattern matches, the portion of the subject string
-       that matched the subpattern is passed back to  the  caller,  separately
-       from  the portion that matched the whole pattern. (This applies only to
-       the traditional matching function; the DFA matching function  does  not
+       that  matched  the  subpattern is passed back to the caller, separately
+       from the portion that matched the whole pattern. (This applies only  to
+       the  traditional  matching function; the DFA matching function does not
        support capturing.)
 
        Opening parentheses are counted from left to right (starting from 1) to
-       obtain numbers for the  capturing  subpatterns.  For  example,  if  the
+       obtain  numbers  for  the  capturing  subpatterns.  For example, if the
        string "the red king" is matched against the pattern
 
          the ((red|white) (king|queen))
@@ -6986,12 +6987,12 @@ SUBPATTERNS
        the captured substrings are "red king", "red", and "king", and are num-
        bered 1, 2, and 3, respectively.
 
-       The fact that plain parentheses fulfil  two  functions  is  not  always
-       helpful.   There are often times when a grouping subpattern is required
-       without a capturing requirement. If an opening parenthesis is  followed
-       by  a question mark and a colon, the subpattern does not do any captur-
-       ing, and is not counted when computing the  number  of  any  subsequent
-       capturing  subpatterns. For example, if the string "the white queen" is
+       The  fact  that  plain  parentheses  fulfil two functions is not always
+       helpful.  There are often times when a grouping subpattern is  required
+       without  a capturing requirement. If an opening parenthesis is followed
+       by a question mark and a colon, the subpattern does not do any  captur-
+       ing,  and  is  not  counted when computing the number of any subsequent
+       capturing subpatterns. For example, if the string "the white queen"  is
        matched against the pattern
 
          the ((?:red|white) (king|queen))
@@ -6999,37 +7000,37 @@ SUBPATTERNS
        the captured substrings are "white queen" and "queen", and are numbered
        1 and 2. The maximum number of capturing subpatterns is 65535.
 
-       As  a  convenient shorthand, if any option settings are required at the
-       start of a non-capturing subpattern,  the  option  letters  may  appear
+       As a convenient shorthand, if any option settings are required  at  the
+       start  of  a  non-capturing  subpattern,  the option letters may appear
        between the "?" and the ":". Thus the two patterns
 
          (?i:saturday|sunday)
          (?:(?i)saturday|sunday)
 
        match exactly the same set of strings. Because alternative branches are
-       tried from left to right, and options are not reset until  the  end  of
-       the  subpattern is reached, an option setting in one branch does affect
-       subsequent branches, so the above patterns match "SUNDAY"  as  well  as
+       tried  from  left  to right, and options are not reset until the end of
+       the subpattern is reached, an option setting in one branch does  affect
+       subsequent  branches,  so  the above patterns match "SUNDAY" as well as
        "Saturday".
 
 
 DUPLICATE SUBPATTERN NUMBERS
 
        Perl 5.10 introduced a feature whereby each alternative in a subpattern
-       uses the same numbers for its capturing parentheses. Such a  subpattern
-       starts  with (?| and is itself a non-capturing subpattern. For example,
+       uses  the same numbers for its capturing parentheses. Such a subpattern
+       starts with (?| and is itself a non-capturing subpattern. For  example,
        consider this pattern:
 
          (?|(Sat)ur|(Sun))day
 
-       Because the two alternatives are inside a (?| group, both sets of  cap-
-       turing  parentheses  are  numbered one. Thus, when the pattern matches,
-       you can look at captured substring number  one,  whichever  alternative
-       matched.  This  construct  is useful when you want to capture part, but
+       Because  the two alternatives are inside a (?| group, both sets of cap-
+       turing parentheses are numbered one. Thus, when  the  pattern  matches,
+       you  can  look  at captured substring number one, whichever alternative
+       matched. This construct is useful when you want to  capture  part,  but
        not all, of one of a number of alternatives. Inside a (?| group, paren-
-       theses  are  numbered as usual, but the number is reset at the start of
-       each branch. The numbers of any capturing parentheses that  follow  the
-       subpattern  start after the highest number used in any branch. The fol-
+       theses are numbered as usual, but the number is reset at the  start  of
+       each  branch.  The numbers of any capturing parentheses that follow the
+       subpattern start after the highest number used in any branch. The  fol-
        lowing example is taken from the Perl documentation. The numbers under-
        neath show in which buffer the captured content will be stored.
 
@@ -7037,14 +7038,14 @@ DUPLICATE SUBPATTERN NUMBERS
          / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
          # 1            2         2  3        2     3     4
 
-       A  back  reference  to a numbered subpattern uses the most recent value
-       that is set for that number by any subpattern.  The  following  pattern
+       A back reference to a numbered subpattern uses the  most  recent  value
+       that  is  set  for that number by any subpattern. The following pattern
        matches "abcabc" or "defdef":
 
          /(?|(abc)|(def))\1/
 
-       In  contrast,  a subroutine call to a numbered subpattern always refers
-       to the first one in the pattern with the given  number.  The  following
+       In contrast, a subroutine call to a numbered subpattern  always  refers
+       to  the  first  one in the pattern with the given number. The following
        pattern matches "abcabc" or "defabc":
 
          /(?|(abc)|(def))(?1)/
@@ -7052,47 +7053,47 @@ DUPLICATE SUBPATTERN NUMBERS
        A relative reference such as (?-1) is no different: it is just a conve-
        nient way of computing an absolute group number.
 
-       If a condition test for a subpattern's having matched refers to a  non-
-       unique  number, the test is true if any of the subpatterns of that num-
+       If  a condition test for a subpattern's having matched refers to a non-
+       unique number, the test is true if any of the subpatterns of that  num-
        ber have matched.
 
-       An alternative approach to using this "branch reset" feature is to  use
+       An  alternative approach to using this "branch reset" feature is to use
        duplicate named subpatterns, as described in the next section.
 
 
 NAMED SUBPATTERNS
 
-       Identifying  capturing  parentheses  by number is simple, but it can be
-       very hard to keep track of the numbers in complicated  regular  expres-
-       sions.  Furthermore,  if  an  expression  is  modified, the numbers may
+       Identifying capturing parentheses by number is simple, but  it  can  be
+       very  hard  to keep track of the numbers in complicated regular expres-
+       sions. Furthermore, if an  expression  is  modified,  the  numbers  may
        change. To help with this difficulty, PCRE2 supports the naming of sub-
        patterns. This feature was not added to Perl until release 5.10. Python
-       had the feature earlier, and PCRE1 introduced it at release 4.0,  using
-       the  Python syntax. PCRE2 supports both the Perl and the Python syntax.
-       Perl allows identically numbered subpatterns to have  different  names,
+       had  the feature earlier, and PCRE1 introduced it at release 4.0, using
+       the Python syntax. PCRE2 supports both the Perl and the Python  syntax.
+       Perl  allows  identically numbered subpatterns to have different names,
        but PCRE2 does not.
 
-       In  PCRE2, a subpattern can be named in one of three ways: (?<name>...)
-       or (?'name'...) as in Perl, or (?P<name>...) as in  Python.  References
-       to  capturing parentheses from other parts of the pattern, such as back
-       references, recursion, and conditions, can be made by name as  well  as
+       In PCRE2, a subpattern can be named in one of three ways:  (?<name>...)
+       or  (?'name'...)  as in Perl, or (?P<name>...) as in Python. References
+       to capturing parentheses from other parts of the pattern, such as  back
+       references,  recursion,  and conditions, can be made by name as well as
        by number.
 
-       Names  consist of up to 32 alphanumeric characters and underscores, but
-       must start with a non-digit.  Named  capturing  parentheses  are  still
-       allocated  numbers  as  well as names, exactly as if the names were not
+       Names consist of up to 32 alphanumeric characters and underscores,  but
+       must  start  with  a  non-digit.  Named capturing parentheses are still
+       allocated numbers as well as names, exactly as if the  names  were  not
        present. The PCRE2 API provides function calls for extracting the name-
-       to-number  translation  table  from  a compiled pattern. There are also
+       to-number translation table from a compiled  pattern.  There  are  also
        convenience functions for extracting a captured substring by name.
 
-       By default, a name must be unique within a pattern, but it is  possible
-       to  relax  this constraint by setting the PCRE2_DUPNAMES option at com-
-       pile time.  (Duplicate names are also always permitted for  subpatterns
-       with  the  same  number,  set up as described in the previous section.)
-       Duplicate names can be useful for patterns where only one  instance  of
+       By  default, a name must be unique within a pattern, but it is possible
+       to relax this constraint by setting the PCRE2_DUPNAMES option  at  com-
+       pile  time.  (Duplicate names are also always permitted for subpatterns
+       with the same number, set up as described  in  the  previous  section.)
+       Duplicate  names  can be useful for patterns where only one instance of
        the named parentheses can match.  Suppose you want to match the name of
-       a weekday, either as a 3-letter abbreviation or as the full  name,  and
-       in  both  cases  you  want  to  extract  the abbreviation. This pattern
+       a  weekday,  either as a 3-letter abbreviation or as the full name, and
+       in both cases you  want  to  extract  the  abbreviation.  This  pattern
        (ignoring the line breaks) does the job:
 
          (?<DN>Mon|Fri|Sun)(?:day)?|
@@ -7101,18 +7102,18 @@ NAMED SUBPATTERNS
          (?<DN>Thu)(?:rsday)?|
          (?<DN>Sat)(?:urday)?
 
-       There are five capturing substrings, but only one is ever set  after  a
+       There  are  five capturing substrings, but only one is ever set after a
        match.  (An alternative way of solving this problem is to use a "branch
        reset" subpattern, as described in the previous section.)
 
-       The convenience functions for extracting the data by name  returns  the
-       substring  for  the first (and in this example, the only) subpattern of
-       that name that matched. This saves searching  to  find  which  numbered
+       The  convenience  functions for extracting the data by name returns the
+       substring for the first (and in this example, the only)  subpattern  of
+       that  name  that  matched.  This saves searching to find which numbered
        subpattern it was.
 
-       If  you  make  a  back  reference to a non-unique named subpattern from
-       elsewhere in the pattern, the subpatterns to which the name refers  are
-       checked  in  the order in which they appear in the overall pattern. The
+       If you make a back reference to  a  non-unique  named  subpattern  from
+       elsewhere  in the pattern, the subpatterns to which the name refers are
+       checked in the order in which they appear in the overall  pattern.  The
        first one that is set is used for the reference. For example, this pat-
        tern matches both "foofoo" and "barbar" but not "foobar" or "barfoo":
 
@@ -7120,29 +7121,29 @@ NAMED SUBPATTERNS
 
 
        If you make a subroutine call to a non-unique named subpattern, the one
-       that corresponds to the first occurrence of the name is  used.  In  the
+       that  corresponds  to  the first occurrence of the name is used. In the
        absence of duplicate numbers (see the previous section) this is the one
        with the lowest number.
 
        If you use a named reference in a condition test (see the section about
        conditions below), either to check whether a subpattern has matched, or
-       to check for recursion, all subpatterns with the same name are  tested.
-       If  the condition is true for any one of them, the overall condition is
-       true. This is the same behaviour as  testing  by  number.  For  further
-       details  of  the  interfaces  for  handling  named subpatterns, see the
+       to  check for recursion, all subpatterns with the same name are tested.
+       If the condition is true for any one of them, the overall condition  is
+       true.  This  is  the  same  behaviour as testing by number. For further
+       details of the interfaces  for  handling  named  subpatterns,  see  the
        pcre2api documentation.
 
        Warning: You cannot use different names to distinguish between two sub-
-       patterns  with the same number because PCRE2 uses only the numbers when
+       patterns with the same number because PCRE2 uses only the numbers  when
        matching. For this reason, an error is given at compile time if differ-
-       ent  names  are given to subpatterns with the same number. However, you
+       ent names are given to subpatterns with the same number.  However,  you
        can always give the same name to subpatterns with the same number, even
        when PCRE2_DUPNAMES is not set.
 
 
 REPETITION
 
-       Repetition  is  specified  by  quantifiers, which can follow any of the
+       Repetition is specified by quantifiers, which can  follow  any  of  the
        following items:
 
          a literal data character
@@ -7156,17 +7157,17 @@ REPETITION
          a parenthesized subpattern (including most assertions)
          a subroutine call to a subpattern (recursive or otherwise)
 
-       The general repetition quantifier specifies a minimum and maximum  num-
-       ber  of  permitted matches, by giving the two numbers in curly brackets
-       (braces), separated by a comma. The numbers must be  less  than  65536,
+       The  general repetition quantifier specifies a minimum and maximum num-
+       ber of permitted matches, by giving the two numbers in  curly  brackets
+       (braces),  separated  by  a comma. The numbers must be less than 65536,
        and the first must be less than or equal to the second. For example:
 
          z{2,4}
 
-       matches  "zz",  "zzz",  or  "zzzz". A closing brace on its own is not a
-       special character. If the second number is omitted, but  the  comma  is
-       present,  there  is  no upper limit; if the second number and the comma
-       are both omitted, the quantifier specifies an exact number of  required
+       matches "zz", "zzz", or "zzzz". A closing brace on its  own  is  not  a
+       special  character.  If  the second number is omitted, but the comma is
+       present, there is no upper limit; if the second number  and  the  comma
+       are  both omitted, the quantifier specifies an exact number of required
        matches. Thus
 
          [aeiou]{3,}
@@ -7175,50 +7176,50 @@ REPETITION
 
          \d{8}
 
-       matches  exactly  8  digits. An opening curly bracket that appears in a
-       position where a quantifier is not allowed, or one that does not  match
-       the  syntax of a quantifier, is taken as a literal character. For exam-
+       matches exactly 8 digits. An opening curly bracket that  appears  in  a
+       position  where a quantifier is not allowed, or one that does not match
+       the syntax of a quantifier, is taken as a literal character. For  exam-
        ple, {,6} is not a quantifier, but a literal string of four characters.
 
        In UTF modes, quantifiers apply to characters rather than to individual
-       code  units. Thus, for example, \x{100}{2} matches two characters, each
+       code units. Thus, for example, \x{100}{2} matches two characters,  each
        of which is represented by a two-byte sequence in a UTF-8 string. Simi-
-       larly,  \X{3} matches three Unicode extended grapheme clusters, each of
-       which may be several code units long (and  they  may  be  of  different
+       larly, \X{3} matches three Unicode extended grapheme clusters, each  of
+       which  may  be  several  code  units long (and they may be of different
        lengths).
 
        The quantifier {0} is permitted, causing the expression to behave as if
        the previous item and the quantifier were not present. This may be use-
-       ful  for  subpatterns that are referenced as subroutines from elsewhere
+       ful for subpatterns that are referenced as subroutines  from  elsewhere
        in the pattern (but see also the section entitled "Defining subpatterns
-       for  use  by  reference only" below). Items other than subpatterns that
+       for use by reference only" below). Items other  than  subpatterns  that
        have a {0} quantifier are omitted from the compiled pattern.
 
-       For convenience, the three most common quantifiers have  single-charac-
+       For  convenience, the three most common quantifiers have single-charac-
        ter abbreviations:
 
          *    is equivalent to {0,}
          +    is equivalent to {1,}
          ?    is equivalent to {0,1}
 
-       It  is  possible  to construct infinite loops by following a subpattern
+       It is possible to construct infinite loops by  following  a  subpattern
        that can match no characters with a quantifier that has no upper limit,
        for example:
 
          (a?)*
 
-       Earlier  versions  of  Perl  and PCRE1 used to give an error at compile
+       Earlier versions of Perl and PCRE1 used to give  an  error  at  compile
        time for such patterns. However, because there are cases where this can
        be useful, such patterns are now accepted, but if any repetition of the
-       subpattern does in fact match no characters, the loop is forcibly  bro-
+       subpattern  does in fact match no characters, the loop is forcibly bro-
        ken.
 
-       By  default,  the quantifiers are "greedy", that is, they match as much
-       as possible (up to the maximum  number  of  permitted  times),  without
-       causing  the  rest of the pattern to fail. The classic example of where
+       By default, the quantifiers are "greedy", that is, they match  as  much
+       as  possible  (up  to  the  maximum number of permitted times), without
+       causing the rest of the pattern to fail. The classic example  of  where
        this gives problems is in trying to match comments in C programs. These
-       appear  between  /*  and  */ and within the comment, individual * and /
-       characters may appear. An attempt to match C comments by  applying  the
+       appear between /* and */ and within the comment,  individual  *  and  /
+       characters  may  appear. An attempt to match C comments by applying the
        pattern
 
          /\*.*\*/
@@ -7227,19 +7228,19 @@ REPETITION
 
          /* first comment */  not comment  /* second comment */
 
-       fails,  because it matches the entire string owing to the greediness of
+       fails, because it matches the entire string owing to the greediness  of
        the .*  item.
 
        If a quantifier is followed by a question mark, it ceases to be greedy,
-       and  instead  matches the minimum number of times possible, so the pat-
+       and instead matches the minimum number of times possible, so  the  pat-
        tern
 
          /\*.*?\*/
 
-       does the right thing with the C comments. The meaning  of  the  various
-       quantifiers  is  not  otherwise  changed,  just the preferred number of
-       matches.  Do not confuse this use of question mark with its  use  as  a
-       quantifier  in its own right. Because it has two uses, it can sometimes
+       does  the  right  thing with the C comments. The meaning of the various
+       quantifiers is not otherwise changed,  just  the  preferred  number  of
+       matches.   Do  not  confuse this use of question mark with its use as a
+       quantifier in its own right. Because it has two uses, it can  sometimes
        appear doubled, as in
 
          \d??\d
@@ -7248,45 +7249,45 @@ REPETITION
        only way the rest of the pattern matches.
 
        If the PCRE2_UNGREEDY option is set (an option that is not available in
-       Perl), the quantifiers are not greedy by default, but  individual  ones
-       can  be  made  greedy  by following them with a question mark. In other
+       Perl),  the  quantifiers are not greedy by default, but individual ones
+       can be made greedy by following them with a  question  mark.  In  other
        words, it inverts the default behaviour.
 
-       When a parenthesized subpattern is quantified  with  a  minimum  repeat
-       count  that is greater than 1 or with a limited maximum, more memory is
-       required for the compiled pattern, in proportion to  the  size  of  the
+       When  a  parenthesized  subpattern  is quantified with a minimum repeat
+       count that is greater than 1 or with a limited maximum, more memory  is
+       required  for  the  compiled  pattern, in proportion to the size of the
        minimum or maximum.
 
-       If  a  pattern  starts  with  .*  or  .{0,} and the PCRE2_DOTALL option
-       (equivalent to Perl's /s) is set, thus allowing the dot to  match  new-
-       lines,  the  pattern  is  implicitly anchored, because whatever follows
-       will be tried against every character position in the  subject  string,
-       so  there  is  no  point  in retrying the overall match at any position
+       If a pattern starts with  .*  or  .{0,}  and  the  PCRE2_DOTALL  option
+       (equivalent  to  Perl's /s) is set, thus allowing the dot to match new-
+       lines, the pattern is implicitly  anchored,  because  whatever  follows
+       will  be  tried against every character position in the subject string,
+       so there is no point in retrying the  overall  match  at  any  position
        after the first. PCRE2 normally treats such a pattern as though it were
        preceded by \A.
 
-       In  cases  where  it  is known that the subject string contains no new-
-       lines, it is worth setting PCRE2_DOTALL in order to obtain  this  opti-
+       In cases where it is known that the subject  string  contains  no  new-
+       lines,  it  is worth setting PCRE2_DOTALL in order to obtain this opti-
        mization, or alternatively, using ^ to indicate anchoring explicitly.
 
-       However,  there  are  some cases where the optimization cannot be used.
+       However, there are some cases where the optimization  cannot  be  used.
        When .*  is inside capturing parentheses that are the subject of a back
        reference elsewhere in the pattern, a match at the start may fail where
        a later one succeeds. Consider, for example:
 
          (.*)abc\1
 
-       If the subject is "xyz123abc123" the match point is the fourth  charac-
+       If  the subject is "xyz123abc123" the match point is the fourth charac-
        ter. For this reason, such a pattern is not implicitly anchored.
 
-       Another  case where implicit anchoring is not applied is when the lead-
-       ing .* is inside an atomic group. Once again, a match at the start  may
+       Another case where implicit anchoring is not applied is when the  lead-
+       ing  .* is inside an atomic group. Once again, a match at the start may
        fail where a later one succeeds. Consider this pattern:
 
          (?>.*?a)b
 
-       It  matches "ab" in the subject "aab". The use of the backtracking con-
-       trol verbs (*PRUNE) and (*SKIP) also  disable  this  optimization,  and
+       It matches "ab" in the subject "aab". The use of the backtracking  con-
+       trol  verbs  (*PRUNE)  and  (*SKIP) also disable this optimization, and
        there is an option, PCRE2_NO_DOTSTAR_ANCHOR, to do so explicitly.
 
        When a capturing subpattern is repeated, the value captured is the sub-
@@ -7295,8 +7296,8 @@ REPETITION
          (tweedle[dume]{3}\s*)+
 
        has matched "tweedledum tweedledee" the value of the captured substring
-       is  "tweedledee".  However,  if there are nested capturing subpatterns,
-       the corresponding captured values may have been set in previous  itera-
+       is "tweedledee". However, if there are  nested  capturing  subpatterns,
+       the  corresponding captured values may have been set in previous itera-
        tions. For example, after
 
          (a|(b))+
@@ -7306,53 +7307,53 @@ REPETITION
 
 ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS
 
-       With  both  maximizing ("greedy") and minimizing ("ungreedy" or "lazy")
-       repetition, failure of what follows normally causes the  repeated  item
-       to  be  re-evaluated to see if a different number of repeats allows the
-       rest of the pattern to match. Sometimes it is useful to  prevent  this,
-       either  to  change the nature of the match, or to cause it fail earlier
-       than it otherwise might, when the author of the pattern knows there  is
+       With both maximizing ("greedy") and minimizing ("ungreedy"  or  "lazy")
+       repetition,  failure  of what follows normally causes the repeated item
+       to be re-evaluated to see if a different number of repeats  allows  the
+       rest  of  the pattern to match. Sometimes it is useful to prevent this,
+       either to change the nature of the match, or to cause it  fail  earlier
+       than  it otherwise might, when the author of the pattern knows there is
        no point in carrying on.
 
-       Consider,  for  example, the pattern \d+foo when applied to the subject
+       Consider, for example, the pattern \d+foo when applied to  the  subject
        line
 
          123456bar
 
        After matching all 6 digits and then failing to match "foo", the normal
-       action  of  the matcher is to try again with only 5 digits matching the
-       \d+ item, and then with  4,  and  so  on,  before  ultimately  failing.
-       "Atomic  grouping"  (a  term taken from Jeffrey Friedl's book) provides
-       the means for specifying that once a subpattern has matched, it is  not
+       action of the matcher is to try again with only 5 digits  matching  the
+       \d+  item,  and  then  with  4,  and  so on, before ultimately failing.
+       "Atomic grouping" (a term taken from Jeffrey  Friedl's  book)  provides
+       the  means for specifying that once a subpattern has matched, it is not
        to be re-evaluated in this way.
 
-       If  we  use atomic grouping for the previous example, the matcher gives
-       up immediately on failing to match "foo" the first time.  The  notation
+       If we use atomic grouping for the previous example, the  matcher  gives
+       up  immediately  on failing to match "foo" the first time. The notation
        is a kind of special parenthesis, starting with (?> as in this example:
 
          (?>\d+)foo
 
-       This  kind  of  parenthesis "locks up" the  part of the pattern it con-
-       tains once it has matched, and a failure further into  the  pattern  is
-       prevented  from  backtracking into it. Backtracking past it to previous
+       This kind of parenthesis "locks up" the  part of the  pattern  it  con-
+       tains  once  it  has matched, and a failure further into the pattern is
+       prevented from backtracking into it. Backtracking past it  to  previous
        items, however, works as normal.
 
-       An alternative description is that a subpattern of  this  type  matches
-       exactly  the  string of characters that an identical standalone pattern
+       An  alternative  description  is that a subpattern of this type matches
+       exactly the string of characters that an identical  standalone  pattern
        would match, if anchored at the current point in the subject string.
 
        Atomic grouping subpatterns are not capturing subpatterns. Simple cases
        such as the above example can be thought of as a maximizing repeat that
-       must swallow everything it can. So, while both \d+ and  \d+?  are  pre-
-       pared  to  adjust  the number of digits they match in order to make the
+       must  swallow  everything  it can. So, while both \d+ and \d+? are pre-
+       pared to adjust the number of digits they match in order  to  make  the
        rest of the pattern match, (?>\d+) can only match an entire sequence of
        digits.
 
-       Atomic  groups in general can of course contain arbitrarily complicated
-       subpatterns, and can be nested. However, when  the  subpattern  for  an
+       Atomic groups in general can of course contain arbitrarily  complicated
+       subpatterns,  and  can  be  nested. However, when the subpattern for an
        atomic group is just a single repeated item, as in the example above, a
-       simpler notation, called a "possessive quantifier" can  be  used.  This
-       consists  of  an  additional  + character following a quantifier. Using
+       simpler  notation,  called  a "possessive quantifier" can be used. This
+       consists of an additional + character  following  a  quantifier.  Using
        this notation, the previous example can be rewritten as
 
          \d++foo
@@ -7362,46 +7363,46 @@ ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS
 
          (abc|xyz){2,3}+
 
-       Possessive   quantifiers   are   always  greedy;  the  setting  of  the
-       PCRE2_UNGREEDY option is ignored. They are a  convenient  notation  for
-       the  simpler  forms of atomic group. However, there is no difference in
+       Possessive  quantifiers  are  always  greedy;  the   setting   of   the
+       PCRE2_UNGREEDY  option  is  ignored. They are a convenient notation for
+       the simpler forms of atomic group. However, there is no  difference  in
        the meaning of a possessive quantifier and the equivalent atomic group,
-       though  there  may  be a performance difference; possessive quantifiers
+       though there may be a performance  difference;  possessive  quantifiers
        should be slightly faster.
 
-       The possessive quantifier syntax is an extension to the Perl  5.8  syn-
-       tax.   Jeffrey  Friedl  originated the idea (and the name) in the first
+       The  possessive  quantifier syntax is an extension to the Perl 5.8 syn-
+       tax.  Jeffrey Friedl originated the idea (and the name)  in  the  first
        edition of his book. Mike McCloskey liked it, so implemented it when he
        built Sun's Java package, and PCRE1 copied it from there. It ultimately
        found its way into Perl at release 5.10.
 
-       PCRE2 has an optimization  that  automatically  "possessifies"  certain
-       simple  pattern constructs. For example, the sequence A+B is treated as
-       A++B because there is no point in backtracking into a sequence  of  A's
+       PCRE2  has  an  optimization  that automatically "possessifies" certain
+       simple pattern constructs. For example, the sequence A+B is treated  as
+       A++B  because  there is no point in backtracking into a sequence of A's
        when B must follow.  This feature can be disabled by the PCRE2_NO_AUTO-
        POSSESS option, or starting the pattern with (*NO_AUTO_POSSESS).
 
-       When a pattern contains an unlimited repeat inside  a  subpattern  that
-       can  itself  be  repeated  an  unlimited number of times, the use of an
-       atomic group is the only way to avoid some  failing  matches  taking  a
+       When  a  pattern  contains an unlimited repeat inside a subpattern that
+       can itself be repeated an unlimited number of  times,  the  use  of  an
+       atomic  group  is  the  only way to avoid some failing matches taking a
        very long time indeed. The pattern
 
          (\D+|<\d+>)*[!?]
 
-       matches  an  unlimited number of substrings that either consist of non-
-       digits, or digits enclosed in <>, followed by either ! or  ?.  When  it
+       matches an unlimited number of substrings that either consist  of  non-
+       digits,  or  digits  enclosed in <>, followed by either ! or ?. When it
        matches, it runs quickly. However, if it is applied to
 
          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 
-       it  takes  a  long  time  before reporting failure. This is because the
-       string can be divided between the internal \D+ repeat and the  external
-       *  repeat  in  a  large  number of ways, and all have to be tried. (The
-       example uses [!?] rather than a single character at  the  end,  because
-       both  PCRE2  and Perl have an optimization that allows for fast failure
-       when a single character is used. They remember the last single  charac-
-       ter  that  is required for a match, and fail early if it is not present
-       in the string.) If the pattern is changed so that  it  uses  an  atomic
+       it takes a long time before reporting  failure.  This  is  because  the
+       string  can be divided between the internal \D+ repeat and the external
+       * repeat in a large number of ways, and all  have  to  be  tried.  (The
+       example  uses  [!?]  rather than a single character at the end, because
+       both PCRE2 and Perl have an optimization that allows for  fast  failure
+       when  a single character is used. They remember the last single charac-
+       ter that is required for a match, and fail early if it is  not  present
+       in  the  string.)  If  the pattern is changed so that it uses an atomic
        group, like this:
 
          ((?>\D+)|<\d+>)*[!?]
@@ -7413,28 +7414,28 @@ BACK REFERENCES
 
        Outside a character class, a backslash followed by a digit greater than
        0 (and possibly further digits) is a back reference to a capturing sub-
-       pattern  earlier  (that is, to its left) in the pattern, provided there
+       pattern earlier (that is, to its left) in the pattern,  provided  there
        have been that many previous capturing left parentheses.
 
-       However, if the decimal number following the backslash is less than  8,
-       it  is  always  taken  as a back reference, and causes an error only if
-       there are not that many capturing left parentheses in the  entire  pat-
-       tern.  In  other words, the parentheses that are referenced need not be
-       to the left of the reference for numbers less than 8. A  "forward  back
-       reference"  of  this  type can make sense when a repetition is involved
-       and the subpattern to the right has participated in an  earlier  itera-
+       However,  if the decimal number following the backslash is less than 8,
+       it is always taken as a back reference, and causes  an  error  only  if
+       there  are  not that many capturing left parentheses in the entire pat-
+       tern. In other words, the parentheses that are referenced need  not  be
+       to  the  left of the reference for numbers less than 8. A "forward back
+       reference" of this type can make sense when a  repetition  is  involved
+       and  the  subpattern to the right has participated in an earlier itera-
        tion.
 
-       It  is  not  possible to have a numerical "forward back reference" to a
-       subpattern whose number is 8  or  more  using  this  syntax  because  a
-       sequence  such  as  \50 is interpreted as a character defined in octal.
+       It is not possible to have a numerical "forward back  reference"  to  a
+       subpattern  whose  number  is  8  or  more  using this syntax because a
+       sequence such as \50 is interpreted as a character  defined  in  octal.
        See the subsection entitled "Non-printing characters" above for further
-       details  of  the  handling of digits following a backslash. There is no
-       such problem when named parentheses are used. A back reference  to  any
+       details of the handling of digits following a backslash.  There  is  no
+       such  problem  when named parentheses are used. A back reference to any
        subpattern is possible using named parentheses (see below).
 
-       Another  way  of  avoiding  the ambiguity inherent in the use of digits
-       following a backslash is to use the \g  escape  sequence.  This  escape
+       Another way of avoiding the ambiguity inherent in  the  use  of  digits
+       following  a  backslash  is  to use the \g escape sequence. This escape
        must be followed by a signed or unsigned number, optionally enclosed in
        braces. These examples are all identical:
 
@@ -7442,46 +7443,46 @@ BACK REFERENCES
          (ring), \g1
          (ring), \g{1}
 
-       An unsigned number specifies an absolute reference without the  ambigu-
+       An  unsigned number specifies an absolute reference without the ambigu-
        ity that is present in the older syntax. It is also useful when literal
-       digits follow the reference. A signed number is a  relative  reference.
+       digits  follow  the reference. A signed number is a relative reference.
        Consider this example:
 
          (abc(def)ghi)\g{-1}
 
        The sequence \g{-1} is a reference to the most recently started captur-
        ing subpattern before \g, that is, is it equivalent to \2 in this exam-
-       ple.   Similarly, \g{-2} would be equivalent to \1. The use of relative
-       references can be helpful in long patterns, and also in  patterns  that
-       are  created  by  joining  together  fragments  that contain references
+       ple.  Similarly, \g{-2} would be equivalent to \1. The use of  relative
+       references  can  be helpful in long patterns, and also in patterns that
+       are created by  joining  together  fragments  that  contain  references
        within themselves.
 
-       The sequence \g{+1} is a reference to the  next  capturing  subpattern.
-       This  kind  of forward reference can be useful it patterns that repeat.
+       The  sequence  \g{+1}  is a reference to the next capturing subpattern.
+       This kind of forward reference can be useful it patterns  that  repeat.
        Perl does not support the use of + in this way.
 
-       A back reference matches whatever actually matched the  capturing  sub-
-       pattern  in  the  current subject string, rather than anything matching
+       A  back  reference matches whatever actually matched the capturing sub-
+       pattern in the current subject string, rather  than  anything  matching
        the subpattern itself (see "Subpatterns as subroutines" below for a way
        of doing that). So the pattern
 
          (sens|respons)e and \1ibility
 
-       matches  "sense and sensibility" and "response and responsibility", but
-       not "sense and responsibility". If caseful matching is in force at  the
-       time  of the back reference, the case of letters is relevant. For exam-
+       matches "sense and sensibility" and "response and responsibility",  but
+       not  "sense and responsibility". If caseful matching is in force at the
+       time of the back reference, the case of letters is relevant. For  exam-
        ple,
 
          ((?i)rah)\s+\1
 
-       matches "rah rah" and "RAH RAH", but not "RAH  rah",  even  though  the
+       matches  "rah  rah"  and  "RAH RAH", but not "RAH rah", even though the
        original capturing subpattern is matched caselessly.
 
-       There  are  several  different ways of writing back references to named
-       subpatterns. The .NET syntax \k{name} and the Perl syntax  \k<name>  or
-       \k'name'  are supported, as is the Python syntax (?P=name). Perl 5.10's
+       There are several different ways of writing back  references  to  named
+       subpatterns.  The  .NET syntax \k{name} and the Perl syntax \k<name> or
+       \k'name' are supported, as is the Python syntax (?P=name). Perl  5.10's
        unified back reference syntax, in which \g can be used for both numeric
-       and  named  references,  is  also supported. We could rewrite the above
+       and named references, is also supported. We  could  rewrite  the  above
        example in any of the following ways:
 
          (?<p1>(?i)rah)\s+\k<p1>
@@ -7489,96 +7490,96 @@ BACK REFERENCES
          (?P<p1>(?i)rah)\s+(?P=p1)
          (?<p1>(?i)rah)\s+\g{p1}
 
-       A subpattern that is referenced by  name  may  appear  in  the  pattern
+       A  subpattern  that  is  referenced  by  name may appear in the pattern
        before or after the reference.
 
-       There  may be more than one back reference to the same subpattern. If a
-       subpattern has not actually been used in a particular match,  any  back
+       There may be more than one back reference to the same subpattern. If  a
+       subpattern  has  not actually been used in a particular match, any back
        references to it always fail by default. For example, the pattern
 
          (a|(bc))\2
 
-       always  fails  if  it starts to match "a" rather than "bc". However, if
-       the PCRE2_MATCH_UNSET_BACKREF option is set at  compile  time,  a  back
+       always fails if it starts to match "a" rather than  "bc".  However,  if
+       the  PCRE2_MATCH_UNSET_BACKREF  option  is  set at compile time, a back
        reference to an unset value matches an empty string.
 
-       Because  there may be many capturing parentheses in a pattern, all dig-
-       its following a backslash are taken as part of a potential back  refer-
-       ence  number.   If  the  pattern continues with a digit character, some
-       delimiter must  be  used  to  terminate  the  back  reference.  If  the
-       PCRE2_EXTENDED  option  is set, this can be white space. Otherwise, the
+       Because there may be many capturing parentheses in a pattern, all  dig-
+       its  following a backslash are taken as part of a potential back refer-
+       ence number.  If the pattern continues with  a  digit  character,  some
+       delimiter  must  be  used  to  terminate  the  back  reference.  If the
+       PCRE2_EXTENDED option is set, this can be white space.  Otherwise,  the
        \g{ syntax or an empty comment (see "Comments" below) can be used.
 
    Recursive back references
 
-       A back reference that occurs inside the parentheses to which it  refers
-       fails  when  the subpattern is first used, so, for example, (a\1) never
-       matches.  However, such references can be useful inside  repeated  sub-
+       A  back reference that occurs inside the parentheses to which it refers
+       fails when the subpattern is first used, so, for example,  (a\1)  never
+       matches.   However,  such references can be useful inside repeated sub-
        patterns. For example, the pattern
 
          (a|b\1)+
 
        matches any number of "a"s and also "aba", "ababbaa" etc. At each iter-
-       ation of the subpattern,  the  back  reference  matches  the  character
-       string  corresponding  to  the previous iteration. In order for this to
-       work, the pattern must be such that the first iteration does  not  need
-       to  match the back reference. This can be done using alternation, as in
+       ation  of  the  subpattern,  the  back  reference matches the character
+       string corresponding to the previous iteration. In order  for  this  to
+       work,  the  pattern must be such that the first iteration does not need
+       to match the back reference. This can be done using alternation, as  in
        the example above, or by a quantifier with a minimum of zero.
 
-       Back references of this type cause the group that they reference to  be
-       treated  as  an atomic group.  Once the whole group has been matched, a
-       subsequent matching failure cannot cause backtracking into  the  middle
+       Back  references of this type cause the group that they reference to be
+       treated as an atomic group.  Once the whole group has been  matched,  a
+       subsequent  matching  failure cannot cause backtracking into the middle
        of the group.
 
 
 ASSERTIONS
 
-       An  assertion  is  a  test on the characters following or preceding the
+       An assertion is a test on the characters  following  or  preceding  the
        current matching point that does not consume any characters. The simple
-       assertions  coded  as  \b,  \B,  \A,  \G, \Z, \z, ^ and $ are described
+       assertions coded as \b, \B, \A, \G, \Z,  \z,  ^  and  $  are  described
        above.
 
-       More complicated assertions are coded as  subpatterns.  There  are  two
-       kinds:  those  that  look  ahead of the current position in the subject
-       string, and those that look behind it, and in each  case  an  assertion
-       may  be  positive  (must  succeed for matching to continue) or negative
+       More  complicated  assertions  are  coded as subpatterns. There are two
+       kinds: those that look ahead of the current  position  in  the  subject
+       string,  and  those  that look behind it, and in each case an assertion
+       may be positive (must succeed for matching  to  continue)  or  negative
        (must not succeed for matching to continue). An assertion subpattern is
-       matched  in the normal way, except that, when matching continues after-
-       wards, the matching position in the subject string is as it was at  the
+       matched in the normal way, except that, when matching continues  after-
+       wards,  the matching position in the subject string is as it was at the
        start of the assertion.
 
-       Assertion  subpatterns  are  not capturing subpatterns. If an assertion
-       contains capturing subpatterns within it, these  are  counted  for  the
-       purposes  of  numbering the capturing subpatterns in the whole pattern.
-       However, substring capturing is carried out only  for  positive  asser-
+       Assertion subpatterns are not capturing subpatterns.  If  an  assertion
+       contains  capturing  subpatterns  within  it, these are counted for the
+       purposes of numbering the capturing subpatterns in the  whole  pattern.
+       However,  substring  capturing  is carried out only for positive asser-
        tions that succeed, that is, one of their branches matches, so matching
-       continues after the assertion. If all branches of a positive  assertion
+       continues  after the assertion. If all branches of a positive assertion
        fail to match, nothing is captured, and control is passed to the previ-
        ous backtracking point.
 
-       No capturing is done for a negative assertion unless it is  being  used
-       as  a condition in a conditional subpattern (see the discussion below).
-       Matching continues after a non-conditional negative assertion  only  if
+       No  capturing  is done for a negative assertion unless it is being used
+       as a condition in a conditional subpattern (see the discussion  below).
+       Matching  continues  after a non-conditional negative assertion only if
        all its branches fail to match.
 
-       For   compatibility  with  Perl,  most  assertion  subpatterns  may  be
-       repeated; though it makes no sense to assert  the  same  thing  several
-       times,  the  side  effect  of capturing parentheses may occasionally be
-       useful. However, an assertion that forms the  condition  for  a  condi-
-       tional  subpattern may not be quantified. In practice, for other asser-
+       For  compatibility  with  Perl,  most  assertion  subpatterns  may   be
+       repeated;  though  it  makes  no sense to assert the same thing several
+       times, the side effect of capturing  parentheses  may  occasionally  be
+       useful.  However,  an  assertion  that forms the condition for a condi-
+       tional subpattern may not be quantified. In practice, for other  asser-
        tions, there only three cases:
 
-       (1) If the quantifier is {0}, the  assertion  is  never  obeyed  during
-       matching.   However,  it  may  contain internal capturing parenthesized
+       (1)  If  the  quantifier  is  {0}, the assertion is never obeyed during
+       matching.  However, it may  contain  internal  capturing  parenthesized
        groups that are called from elsewhere via the subroutine mechanism.
 
-       (2) If quantifier is {0,n} where n is greater than zero, it is  treated
-       as  if  it  were  {0,1}.  At run time, the rest of the pattern match is
+       (2)  If quantifier is {0,n} where n is greater than zero, it is treated
+       as if it were {0,1}. At run time, the rest  of  the  pattern  match  is
        tried with and without the assertion, the order depending on the greed-
        iness of the quantifier.
 
-       (3)  If  the minimum repetition is greater than zero, the quantifier is
-       ignored.  The assertion is obeyed just  once  when  encountered  during
+       (3) If the minimum repetition is greater than zero, the  quantifier  is
+       ignored.   The  assertion  is  obeyed just once when encountered during
        matching.
 
    Lookahead assertions
@@ -7588,38 +7589,38 @@ ASSERTIONS
 
          \w+(?=;)
 
-       matches a word followed by a semicolon, but does not include the  semi-
+       matches  a word followed by a semicolon, but does not include the semi-
        colon in the match, and
 
          foo(?!bar)
 
-       matches  any  occurrence  of  "foo" that is not followed by "bar". Note
+       matches any occurrence of "foo" that is not  followed  by  "bar".  Note
        that the apparently similar pattern
 
          (?!foo)bar
 
-       does not find an occurrence of "bar"  that  is  preceded  by  something
-       other  than "foo"; it finds any occurrence of "bar" whatsoever, because
+       does  not  find  an  occurrence  of "bar" that is preceded by something
+       other than "foo"; it finds any occurrence of "bar" whatsoever,  because
        the assertion (?!foo) is always true when the next three characters are
        "bar". A lookbehind assertion is needed to achieve the other effect.
 
        If you want to force a matching failure at some point in a pattern, the
-       most convenient way to do it is  with  (?!)  because  an  empty  string
-       always  matches, so an assertion that requires there not to be an empty
+       most  convenient  way  to  do  it  is with (?!) because an empty string
+       always matches, so an assertion that requires there not to be an  empty
        string must always fail.  The backtracking control verb (*FAIL) or (*F)
        is a synonym for (?!).
 
    Lookbehind assertions
 
-       Lookbehind  assertions start with (?<= for positive assertions and (?<!
+       Lookbehind assertions start with (?<= for positive assertions and  (?<!
        for negative assertions. For example,
 
          (?<!foo)bar
 
-       does find an occurrence of "bar" that is not  preceded  by  "foo".  The
-       contents  of  a  lookbehind  assertion are restricted such that all the
+       does  find  an  occurrence  of "bar" that is not preceded by "foo". The
+       contents of a lookbehind assertion are restricted  such  that  all  the
        strings it matches must have a fixed length. However, if there are sev-
-       eral  top-level  alternatives,  they  do  not all have to have the same
+       eral top-level alternatives, they do not all  have  to  have  the  same
        fixed length. Thus
 
          (?<=bullock|donkey)
@@ -7628,74 +7629,74 @@ ASSERTIONS
 
          (?<!dogs?|cats?)
 
-       causes an error at compile time. Branches that match  different  length
-       strings  are permitted only at the top level of a lookbehind assertion.
+       causes  an  error at compile time. Branches that match different length
+       strings are permitted only at the top level of a lookbehind  assertion.
        This is an extension compared with Perl, which requires all branches to
        match the same length of string. An assertion such as
 
          (?<=ab(c|de))
 
-       is  not  permitted,  because  its single top-level branch can match two
-       different lengths, but it is acceptable to PCRE2 if  rewritten  to  use
+       is not permitted, because its single top-level  branch  can  match  two
+       different  lengths,  but  it is acceptable to PCRE2 if rewritten to use
        two top-level branches:
 
          (?<=abc|abde)
 
-       In  some  cases, the escape sequence \K (see above) can be used instead
+       In some cases, the escape sequence \K (see above) can be  used  instead
        of a lookbehind assertion to get round the fixed-length restriction.
 
-       The implementation of lookbehind assertions is, for  each  alternative,
-       to  temporarily  move the current position back by the fixed length and
+       The  implementation  of lookbehind assertions is, for each alternative,
+       to temporarily move the current position back by the fixed  length  and
        then try to match. If there are insufficient characters before the cur-
        rent position, the assertion fails.
 
-       In  UTF-8  and  UTF-16 modes, PCRE2 does not allow the \C escape (which
-       matches a single code unit even in a UTF mode) to appear in  lookbehind
-       assertions,  because  it makes it impossible to calculate the length of
-       the lookbehind. The \X and \R escapes, which can match  different  num-
+       In UTF-8 and UTF-16 modes, PCRE2 does not allow the  \C  escape  (which
+       matches  a single code unit even in a UTF mode) to appear in lookbehind
+       assertions, because it makes it impossible to calculate the  length  of
+       the  lookbehind.  The \X and \R escapes, which can match different num-
        bers of code units, are never permitted in lookbehinds.
 
-       "Subroutine"  calls  (see below) such as (?2) or (?&X) are permitted in
-       lookbehinds, as long as the subpattern matches a  fixed-length  string.
-       However,  recursion,  that is, a "subroutine" call into a group that is
+       "Subroutine" calls (see below) such as (?2) or (?&X) are  permitted  in
+       lookbehinds,  as  long as the subpattern matches a fixed-length string.
+       However, recursion, that is, a "subroutine" call into a group  that  is
        already active, is not supported.
 
-       Perl does not support back references in lookbehinds. PCRE2  does  sup-
-       port   them,   but   only   if   certain   conditions   are   met.  The
-       PCRE2_MATCH_UNSET_BACKREF option must not be set, there must be no  use
+       Perl  does  not support back references in lookbehinds. PCRE2 does sup-
+       port  them,   but   only   if   certain   conditions   are   met.   The
+       PCRE2_MATCH_UNSET_BACKREF  option must not be set, there must be no use
        of (?| in the pattern (it creates duplicate subpattern numbers), and if
-       the back reference is by name, the name must be unique. Of course,  the
-       referenced  subpattern  must  itself  be of fixed length. The following
+       the  back reference is by name, the name must be unique. Of course, the
+       referenced subpattern must itself be of  fixed  length.  The  following
        pattern matches words containing at least two characters that begin and
        end with the same character:
 
           \b(\w)\w++(?<=\1)
 
-       Possessive  quantifiers  can  be  used  in  conjunction with lookbehind
+       Possessive quantifiers can  be  used  in  conjunction  with  lookbehind
        assertions to specify efficient matching of fixed-length strings at the
        end of subject strings. Consider a simple pattern such as
 
          abcd$
 
-       when  applied  to  a  long string that does not match. Because matching
-       proceeds from left to right, PCRE2 will look for each "a" in  the  sub-
-       ject  and  then see if what follows matches the rest of the pattern. If
+       when applied to a long string that does  not  match.  Because  matching
+       proceeds  from  left to right, PCRE2 will look for each "a" in the sub-
+       ject and then see if what follows matches the rest of the  pattern.  If
        the pattern is specified as
 
          ^.*abcd$
 
-       the initial .* matches the entire string at first, but when this  fails
+       the  initial .* matches the entire string at first, but when this fails
        (because there is no following "a"), it backtracks to match all but the
-       last character, then all but the last two characters, and so  on.  Once
-       again  the search for "a" covers the entire string, from right to left,
+       last  character,  then all but the last two characters, and so on. Once
+       again the search for "a" covers the entire string, from right to  left,
        so we are no better off. However, if the pattern is written as
 
          ^.*+(?<=abcd)
 
        there can be no backtracking for the .*+ item because of the possessive
        quantifier; it can match only the entire string. The subsequent lookbe-
-       hind assertion does a single test on the last four  characters.  If  it
-       fails,  the  match  fails  immediately. For long strings, this approach
+       hind  assertion  does  a single test on the last four characters. If it
+       fails, the match fails immediately. For  long  strings,  this  approach
        makes a significant difference to the processing time.
 
    Using multiple assertions
@@ -7704,18 +7705,18 @@ ASSERTIONS
 
          (?<=\d{3})(?<!999)foo
 
-       matches "foo" preceded by three digits that are not "999". Notice  that
-       each  of  the  assertions is applied independently at the same point in
-       the subject string. First there is a  check  that  the  previous  three
-       characters  are  all  digits,  and  then there is a check that the same
+       matches  "foo" preceded by three digits that are not "999". Notice that
+       each of the assertions is applied independently at the  same  point  in
+       the  subject  string.  First  there  is a check that the previous three
+       characters are all digits, and then there is  a  check  that  the  same
        three characters are not "999".  This pattern does not match "foo" pre-
-       ceded  by  six  characters,  the first of which are digits and the last
-       three of which are not "999". For example, it  doesn't  match  "123abc-
+       ceded by six characters, the first of which are  digits  and  the  last
+       three  of  which  are not "999". For example, it doesn't match "123abc-
        foo". A pattern to do that is
 
          (?<=\d{3}...)(?<!999)foo
 
-       This  time  the  first assertion looks at the preceding six characters,
+       This time the first assertion looks at the  preceding  six  characters,
        checking that the first three are digits, and then the second assertion
        checks that the preceding three characters are not "999".
 
@@ -7723,29 +7724,29 @@ ASSERTIONS
 
          (?<=(?<!foo)bar)baz
 
-       matches  an occurrence of "baz" that is preceded by "bar" which in turn
+       matches an occurrence of "baz" that is preceded by "bar" which in  turn
        is not preceded by "foo", while
 
          (?<=\d{3}(?!999)...)foo
 
-       is another pattern that matches "foo" preceded by three digits and  any
+       is  another pattern that matches "foo" preceded by three digits and any
        three characters that are not "999".
 
 
 CONDITIONAL SUBPATTERNS
 
-       It  is possible to cause the matching process to obey a subpattern con-
-       ditionally or to choose between two alternative subpatterns,  depending
-       on  the result of an assertion, or whether a specific capturing subpat-
-       tern has already been matched. The two possible  forms  of  conditional
+       It is possible to cause the matching process to obey a subpattern  con-
+       ditionally  or to choose between two alternative subpatterns, depending
+       on the result of an assertion, or whether a specific capturing  subpat-
+       tern  has  already  been matched. The two possible forms of conditional
        subpattern are:
 
          (?(condition)yes-pattern)
          (?(condition)yes-pattern|no-pattern)
 
-       If  the  condition is satisfied, the yes-pattern is used; otherwise the
-       no-pattern (if present) is used. If there are more  than  two  alterna-
-       tives  in  the subpattern, a compile-time error occurs. Each of the two
+       If the condition is satisfied, the yes-pattern is used;  otherwise  the
+       no-pattern  (if  present)  is used. If there are more than two alterna-
+       tives in the subpattern, a compile-time error occurs. Each of  the  two
        alternatives may itself contain nested subpatterns of any form, includ-
        ing  conditional  subpatterns;  the  restriction  to  two  alternatives
        applies only at the level of the condition. This pattern fragment is an
@@ -7754,88 +7755,88 @@ CONDITIONAL SUBPATTERNS
          (?(1) (A|B|C) | (D | (?(2)E|F) | E) )
 
 
-       There  are  five  kinds of condition: references to subpatterns, refer-
-       ences to recursion, two pseudo-conditions called  DEFINE  and  VERSION,
+       There are five kinds of condition: references  to  subpatterns,  refer-
+       ences  to  recursion,  two pseudo-conditions called DEFINE and VERSION,
        and assertions.
 
    Checking for a used subpattern by number
 
-       If  the  text between the parentheses consists of a sequence of digits,
+       If the text between the parentheses consists of a sequence  of  digits,
        the condition is true if a capturing subpattern of that number has pre-
-       viously  matched.  If  there is more than one capturing subpattern with
-       the same number (see the earlier  section  about  duplicate  subpattern
-       numbers),  the condition is true if any of them have matched. An alter-
-       native notation is to precede the digits with a plus or minus sign.  In
-       this  case, the subpattern number is relative rather than absolute. The
-       most recently opened parentheses can be referenced by (?(-1), the  next
-       most  recent  by (?(-2), and so on. Inside loops it can also make sense
+       viously matched. If there is more than one  capturing  subpattern  with
+       the  same  number  (see  the earlier section about duplicate subpattern
+       numbers), the condition is true if any of them have matched. An  alter-
+       native  notation is to precede the digits with a plus or minus sign. In
+       this case, the subpattern number is relative rather than absolute.  The
+       most  recently opened parentheses can be referenced by (?(-1), the next
+       most recent by (?(-2), and so on. Inside loops it can also  make  sense
        to refer to subsequent groups. The next parentheses to be opened can be
-       referenced  as (?(+1), and so on. (The value zero in any of these forms
+       referenced as (?(+1), and so on. (The value zero in any of these  forms
        is not used; it provokes a compile-time error.)
 
-       Consider the following pattern, which  contains  non-significant  white
-       space  to  make it more readable (assume the PCRE2_EXTENDED option) and
+       Consider  the  following  pattern, which contains non-significant white
+       space to make it more readable (assume the PCRE2_EXTENDED  option)  and
        to divide it into three parts for ease of discussion:
 
          ( \( )?    [^()]+    (?(1) \) )
 
-       The first part matches an optional opening  parenthesis,  and  if  that
+       The  first  part  matches  an optional opening parenthesis, and if that
        character is present, sets it as the first captured substring. The sec-
-       ond part matches one or more characters that are not  parentheses.  The
-       third  part  is  a conditional subpattern that tests whether or not the
-       first set of parentheses matched. If they  did,  that  is,  if  subject
-       started  with an opening parenthesis, the condition is true, and so the
-       yes-pattern is executed and a closing parenthesis is  required.  Other-
-       wise,  since no-pattern is not present, the subpattern matches nothing.
-       In other words, this pattern matches  a  sequence  of  non-parentheses,
+       ond  part  matches one or more characters that are not parentheses. The
+       third part is a conditional subpattern that tests whether  or  not  the
+       first  set  of  parentheses  matched.  If they did, that is, if subject
+       started with an opening parenthesis, the condition is true, and so  the
+       yes-pattern  is  executed and a closing parenthesis is required. Other-
+       wise, since no-pattern is not present, the subpattern matches  nothing.
+       In  other  words,  this  pattern matches a sequence of non-parentheses,
        optionally enclosed in parentheses.
 
-       If  you  were  embedding  this pattern in a larger one, you could use a
+       If you were embedding this pattern in a larger one,  you  could  use  a
        relative reference:
 
          ...other stuff... ( \( )?    [^()]+    (?(-1) \) ) ...
 
-       This makes the fragment independent of the parentheses  in  the  larger
+       This  makes  the  fragment independent of the parentheses in the larger
        pattern.
 
    Checking for a used subpattern by name
 
-       Perl  uses  the  syntax  (?(<name>)...) or (?('name')...) to test for a
-       used subpattern by name. For compatibility  with  earlier  versions  of
-       PCRE1,  which had this facility before Perl, the syntax (?(name)...) is
-       also recognized. Note, however, that undelimited  names  consisting  of
-       the  letter  R followed by digits are ambiguous (see the following sec-
+       Perl uses the syntax (?(<name>)...) or (?('name')...)  to  test  for  a
+       used  subpattern  by  name.  For compatibility with earlier versions of
+       PCRE1, which had this facility before Perl, the syntax (?(name)...)  is
+       also  recognized.  Note,  however, that undelimited names consisting of
+       the letter R followed by digits are ambiguous (see the  following  sec-
        tion).
 
        Rewriting the above example to use a named subpattern gives this:
 
          (?<OPEN> \( )?    [^()]+    (?(<OPEN>) \) )
 
-       If the name used in a condition of this kind is a duplicate,  the  test
-       is  applied to all subpatterns of the same name, and is true if any one
+       If  the  name used in a condition of this kind is a duplicate, the test
+       is applied to all subpatterns of the same name, and is true if any  one
        of them has matched.
 
    Checking for pattern recursion
 
-       "Recursion" in this sense refers to any subroutine-like call  from  one
-       part  of  the  pattern to another, whether or not it is actually recur-
-       sive. See the sections entitled "Recursive patterns"  and  "Subpatterns
+       "Recursion"  in  this sense refers to any subroutine-like call from one
+       part of the pattern to another, whether or not it  is  actually  recur-
+       sive.  See  the sections entitled "Recursive patterns" and "Subpatterns
        as subroutines" below for details of recursion and subpattern calls.
 
-       If  a  condition is the string (R), and there is no subpattern with the
-       name R, the condition is true if matching is currently in  a  recursion
-       or  subroutine  call  to the whole pattern or any subpattern. If digits
-       follow the letter R, and there is no subpattern  with  that  name,  the
+       If a condition is the string (R), and there is no subpattern  with  the
+       name  R,  the condition is true if matching is currently in a recursion
+       or subroutine call to the whole pattern or any  subpattern.  If  digits
+       follow  the  letter  R,  and there is no subpattern with that name, the
        condition is true if the most recent call is into a subpattern with the
-       given number, which must exist somewhere in the overall  pattern.  This
+       given  number,  which must exist somewhere in the overall pattern. This
        is a contrived example that is equivalent to a+b:
 
          ((?(R1)a+|(?1)b))
 
-       However,  in both cases, if there is a subpattern with a matching name,
-       the condition tests for its being set,  as  described  in  the  section
-       above,  instead of testing for recursion. For example, creating a group
-       with the name R1 by adding (?<R1>)  to  the  above  pattern  completely
+       However, in both cases, if there is a subpattern with a matching  name,
+       the  condition  tests  for  its  being set, as described in the section
+       above, instead of testing for recursion. For example, creating a  group
+       with  the  name  R1  by  adding (?<R1>) to the above pattern completely
        changes its meaning.
 
        If a name preceded by ampersand follows the letter R, for example:
@@ -7846,7 +7847,7 @@ CONDITIONAL SUBPATTERNS
        of that name (which must exist within the pattern).
 
        This condition does not check the entire recursion stack. It tests only
-       the  current  level.  If the name used in a condition of this kind is a
+       the current level. If the name used in a condition of this  kind  is  a
        duplicate, the test is applied to all subpatterns of the same name, and
        is true if any one of them is the most recent recursion.
 
@@ -7855,10 +7856,10 @@ CONDITIONAL SUBPATTERNS
    Defining subpatterns for use by reference only
 
        If the condition is the string (DEFINE), the condition is always false,
-       even if there is a group with the name DEFINE. In this case, there  may
+       even  if there is a group with the name DEFINE. In this case, there may
        be only one alternative in the subpattern. It is always skipped if con-
-       trol reaches this point in the pattern; the idea of DEFINE is  that  it
-       can  be  used  to  define subroutines that can be referenced from else-
+       trol  reaches  this point in the pattern; the idea of DEFINE is that it
+       can be used to define subroutines that can  be  referenced  from  else-
        where. (The use of subroutines is described below.) For example, a pat-
        tern to match an IPv4 address such as "192.168.23.245" could be written
        like this (ignore white space and line breaks):
@@ -7866,97 +7867,97 @@ CONDITIONAL SUBPATTERNS
          (?(DEFINE) (?<byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )
          \b (?&byte) (\.(?&byte)){3} \b
 
-       The first part of the pattern is a DEFINE group inside which a  another
-       group  named "byte" is defined. This matches an individual component of
-       an IPv4 address (a number less than 256). When  matching  takes  place,
-       this  part  of  the pattern is skipped because DEFINE acts like a false
-       condition. The rest of the pattern uses references to the  named  group
-       to  match the four dot-separated components of an IPv4 address, insist-
+       The  first part of the pattern is a DEFINE group inside which a another
+       group named "byte" is defined. This matches an individual component  of
+       an  IPv4  address  (a number less than 256). When matching takes place,
+       this part of the pattern is skipped because DEFINE acts  like  a  false
+       condition.  The  rest of the pattern uses references to the named group
+       to match the four dot-separated components of an IPv4 address,  insist-
        ing on a word boundary at each end.
 
    Checking the PCRE2 version
 
-       Programs that link with a PCRE2 library can check the version by  call-
-       ing  pcre2_config()  with  appropriate arguments. Users of applications
-       that do not have access to the underlying code cannot do this.  A  spe-
-       cial  "condition" called VERSION exists to allow such users to discover
+       Programs  that link with a PCRE2 library can check the version by call-
+       ing pcre2_config() with appropriate arguments.  Users  of  applications
+       that  do  not have access to the underlying code cannot do this. A spe-
+       cial "condition" called VERSION exists to allow such users to  discover
        which version of PCRE2 they are dealing with by using this condition to
-       match  a string such as "yesno". VERSION must be followed either by "="
+       match a string such as "yesno". VERSION must be followed either by  "="
        or ">=" and a version number.  For example:
 
          (?(VERSION>=10.4)yes|no)
 
-       This pattern matches "yes" if the PCRE2 version is greater or equal  to
-       10.4,  or "no" otherwise. The fractional part of the version number may
+       This  pattern matches "yes" if the PCRE2 version is greater or equal to
+       10.4, or "no" otherwise. The fractional part of the version number  may
        not contain more than two digits.
 
    Assertion conditions
 
-       If the condition is not in any of the above  formats,  it  must  be  an
-       assertion.   This may be a positive or negative lookahead or lookbehind
-       assertion. Consider  this  pattern,  again  containing  non-significant
+       If  the  condition  is  not  in any of the above formats, it must be an
+       assertion.  This may be a positive or negative lookahead or  lookbehind
+       assertion.  Consider  this  pattern,  again  containing non-significant
        white space, and with the two alternatives on the second line:
 
          (?(?=[^a-z]*[a-z])
          \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
 
-       The  condition  is  a  positive  lookahead  assertion  that  matches an
-       optional sequence of non-letters followed by a letter. In other  words,
-       it  tests  for the presence of at least one letter in the subject. If a
-       letter is found, the subject is matched against the first  alternative;
-       otherwise  it  is  matched  against  the  second.  This pattern matches
-       strings in one of the two forms dd-aaa-dd or dd-dd-dd,  where  aaa  are
+       The condition  is  a  positive  lookahead  assertion  that  matches  an
+       optional  sequence of non-letters followed by a letter. In other words,
+       it tests for the presence of at least one letter in the subject.  If  a
+       letter  is found, the subject is matched against the first alternative;
+       otherwise it is  matched  against  the  second.  This  pattern  matches
+       strings  in  one  of the two forms dd-aaa-dd or dd-dd-dd, where aaa are
        letters and dd are digits.
 
-       When  an  assertion that is a condition contains capturing subpatterns,
-       any capturing that occurs in a matching branch is retained  afterwards,
+       When an assertion that is a condition contains  capturing  subpatterns,
+       any  capturing that occurs in a matching branch is retained afterwards,
        for both positive and negative assertions, because matching always con-
        tinues after the assertion, whether it succeeds or fails. (Compare non-
-       conditional  assertions,  when  captures are retained only for positive
+       conditional assertions, when captures are retained  only  for  positive
        assertions that succeed.)
 
 
 COMMENTS
 
        There are two ways of including comments in patterns that are processed
-       by  PCRE2.  In  both  cases,  the start of the comment must not be in a
-       character class, nor in the middle of any  other  sequence  of  related
-       characters  such  as (?: or a subpattern name or number. The characters
+       by PCRE2. In both cases, the start of the comment  must  not  be  in  a
+       character  class,  nor  in  the middle of any other sequence of related
+       characters such as (?: or a subpattern name or number.  The  characters
        that make up a comment play no part in the pattern matching.
 
-       The sequence (?# marks the start of a comment that continues up to  the
-       next  closing parenthesis. Nested parentheses are not permitted. If the
-       PCRE2_EXTENDED option is set, an unescaped # character also  introduces
-       a  comment,  which in this case continues to immediately after the next
-       newline character or character sequence in the pattern.  Which  charac-
-       ters  are  interpreted as newlines is controlled by an option passed to
-       the compiling function or by a special sequence at  the  start  of  the
-       pattern,  as  described  in  the section entitled "Newline conventions"
-       above. Note that the end of this type of comment is a  literal  newline
-       sequence  in  the  pattern; escape sequences that happen to represent a
-       newline  do  not  count.  For  example,  consider  this  pattern   when
-       PCRE2_EXTENDED  is  set,  and  the default newline convention (a single
+       The  sequence (?# marks the start of a comment that continues up to the
+       next closing parenthesis. Nested parentheses are not permitted. If  the
+       PCRE2_EXTENDED  option is set, an unescaped # character also introduces
+       a comment, which in this case continues to immediately after  the  next
+       newline  character  or character sequence in the pattern. Which charac-
+       ters are interpreted as newlines is controlled by an option  passed  to
+       the  compiling  function  or  by a special sequence at the start of the
+       pattern, as described in the  section  entitled  "Newline  conventions"
+       above.  Note  that the end of this type of comment is a literal newline
+       sequence in the pattern; escape sequences that happen  to  represent  a
+       newline   do  not  count.  For  example,  consider  this  pattern  when
+       PCRE2_EXTENDED is set, and the default  newline  convention  (a  single
        linefeed character) is in force:
 
          abc #comment \n still comment
 
-       On encountering the # character, pcre2_compile() skips  along,  looking
-       for  a newline in the pattern. The sequence \n is still literal at this
-       stage, so it does not terminate the comment. Only an  actual  character
+       On  encountering  the # character, pcre2_compile() skips along, looking
+       for a newline in the pattern. The sequence \n is still literal at  this
+       stage,  so  it does not terminate the comment. Only an actual character
        with the code value 0x0a (the default newline) does so.
 
 
 RECURSIVE PATTERNS
 
-       Consider  the problem of matching a string in parentheses, allowing for
-       unlimited nested parentheses. Without the use of  recursion,  the  best
-       that  can  be  done  is  to use a pattern that matches up to some fixed
-       depth of nesting. It is not possible to  handle  an  arbitrary  nesting
+       Consider the problem of matching a string in parentheses, allowing  for
+       unlimited  nested  parentheses.  Without the use of recursion, the best
+       that can be done is to use a pattern that  matches  up  to  some  fixed
+       depth  of  nesting.  It  is not possible to handle an arbitrary nesting
        depth.
 
        For some time, Perl has provided a facility that allows regular expres-
-       sions to recurse (amongst other things). It does this by  interpolating
-       Perl  code in the expression at run time, and the code can refer to the
+       sions  to recurse (amongst other things). It does this by interpolating
+       Perl code in the expression at run time, and the code can refer to  the
        expression itself. A Perl pattern using code interpolation to solve the
        parentheses problem can be created like this:
 
@@ -7966,179 +7967,179 @@ RECURSIVE PATTERNS
        refers recursively to the pattern in which it appears.
 
        Obviously,  PCRE2  cannot  support  the  interpolation  of  Perl  code.
-       Instead,  it  supports  special syntax for recursion of the entire pat-
+       Instead, it supports special syntax for recursion of  the  entire  pat-
        tern, and also for individual subpattern recursion. After its introduc-
-       tion  in  PCRE1  and  Python,  this  kind of recursion was subsequently
+       tion in PCRE1 and Python,  this  kind  of  recursion  was  subsequently
        introduced into Perl at release 5.10.
 
-       A special item that consists of (? followed by a  number  greater  than
-       zero  and  a  closing parenthesis is a recursive subroutine call of the
-       subpattern of the given number, provided that  it  occurs  inside  that
-       subpattern.  (If  not,  it is a non-recursive subroutine call, which is
-       described in the next section.) The special item  (?R)  or  (?0)  is  a
+       A  special  item  that consists of (? followed by a number greater than
+       zero and a closing parenthesis is a recursive subroutine  call  of  the
+       subpattern  of  the  given  number, provided that it occurs inside that
+       subpattern. (If not, it is a non-recursive subroutine  call,  which  is
+       described  in  the  next  section.)  The special item (?R) or (?0) is a
        recursive call of the entire regular expression.
 
-       This  PCRE2  pattern  solves the nested parentheses problem (assume the
+       This PCRE2 pattern solves the nested parentheses  problem  (assume  the
        PCRE2_EXTENDED option is set so that white space is ignored):
 
          \( ( [^()]++ | (?R) )* \)
 
-       First it matches an opening parenthesis. Then it matches any number  of
-       substrings  which  can  either  be  a sequence of non-parentheses, or a
-       recursive match of the pattern itself (that is, a  correctly  parenthe-
+       First  it matches an opening parenthesis. Then it matches any number of
+       substrings which can either be a  sequence  of  non-parentheses,  or  a
+       recursive  match  of the pattern itself (that is, a correctly parenthe-
        sized substring).  Finally there is a closing parenthesis. Note the use
        of a possessive quantifier to avoid backtracking into sequences of non-
        parentheses.
 
-       If  this  were  part of a larger pattern, you would not want to recurse
+       If this were part of a larger pattern, you would not  want  to  recurse
        the entire pattern, so instead you could use this:
 
          ( \( ( [^()]++ | (?1) )* \) )
 
-       We have put the pattern into parentheses, and caused the  recursion  to
+       We  have  put the pattern into parentheses, and caused the recursion to
        refer to them instead of the whole pattern.
 
-       In  a  larger  pattern,  keeping  track  of  parenthesis numbers can be
-       tricky. This is made easier by the use of relative references.  Instead
+       In a larger pattern,  keeping  track  of  parenthesis  numbers  can  be
+       tricky.  This is made easier by the use of relative references. Instead
        of (?1) in the pattern above you can write (?-2) to refer to the second
-       most recently opened parentheses  preceding  the  recursion.  In  other
-       words,  a  negative  number counts capturing parentheses leftwards from
+       most  recently  opened  parentheses  preceding  the recursion. In other
+       words, a negative number counts capturing  parentheses  leftwards  from
        the point at which it is encountered.
 
        Be aware however, that if duplicate subpattern numbers are in use, rel-
-       ative  references refer to the earliest subpattern with the appropriate
+       ative references refer to the earliest subpattern with the  appropriate
        number. Consider, for example:
 
          (?|(a)|(b)) (c) (?-2)
 
-       The first two capturing groups (a) and (b) are  both  numbered  1,  and
-       group  (c)  is  number  2. When the reference (?-2) is encountered, the
+       The  first  two  capturing  groups (a) and (b) are both numbered 1, and
+       group (c) is number 2. When the reference  (?-2)  is  encountered,  the
        second most recently opened parentheses has the number 1, but it is the
-       first  such  group  (the (a) group) to which the recursion refers. This
-       would be the same if an absolute reference  (?1)  was  used.  In  other
-       words,  relative  references are just a shorthand for computing a group
+       first such group (the (a) group) to which the  recursion  refers.  This
+       would  be  the  same  if  an absolute reference (?1) was used. In other
+       words, relative references are just a shorthand for computing  a  group
        number.
 
-       It is also possible to refer to  subsequently  opened  parentheses,  by
-       writing  references  such  as (?+2). However, these cannot be recursive
-       because the reference is not inside the  parentheses  that  are  refer-
-       enced.  They are always non-recursive subroutine calls, as described in
+       It  is  also  possible  to refer to subsequently opened parentheses, by
+       writing references such as (?+2). However, these  cannot  be  recursive
+       because  the  reference  is  not inside the parentheses that are refer-
+       enced. They are always non-recursive subroutine calls, as described  in
        the next section.
 
-       An alternative approach is to use named parentheses.  The  Perl  syntax
-       for  this  is  (?&name);  PCRE1's earlier syntax (?P>name) is also sup-
+       An  alternative  approach  is to use named parentheses. The Perl syntax
+       for this is (?&name); PCRE1's earlier syntax  (?P>name)  is  also  sup-
        ported. We could rewrite the above example as follows:
 
          (?<pn> \( ( [^()]++ | (?&pn) )* \) )
 
-       If there is more than one subpattern with the same name,  the  earliest
+       If  there  is more than one subpattern with the same name, the earliest
        one is used.
 
        The example pattern that we have been looking at contains nested unlim-
-       ited repeats, and so the use of a possessive  quantifier  for  matching
-       strings  of  non-parentheses  is important when applying the pattern to
+       ited  repeats,  and  so the use of a possessive quantifier for matching
+       strings of non-parentheses is important when applying  the  pattern  to
        strings that do not match. For example, when this pattern is applied to
 
          (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()
 
-       it yields "no match" quickly. However, if a  possessive  quantifier  is
-       not  used, the match runs for a very long time indeed because there are
-       so many different ways the + and * repeats can carve  up  the  subject,
+       it  yields  "no  match" quickly. However, if a possessive quantifier is
+       not used, the match runs for a very long time indeed because there  are
+       so  many  different  ways the + and * repeats can carve up the subject,
        and all have to be tested before failure can be reported.
 
-       At  the  end  of a match, the values of capturing parentheses are those
-       from the outermost level. If you want to obtain intermediate values,  a
+       At the end of a match, the values of capturing  parentheses  are  those
+       from  the outermost level. If you want to obtain intermediate values, a
        callout function can be used (see below and the pcre2callout documenta-
        tion). If the pattern above is matched against
 
          (ab(cd)ef)
 
-       the value for the inner capturing parentheses  (numbered  2)  is  "ef",
-       which  is the last value taken on at the top level. If a capturing sub-
-       pattern is not matched at the top level, its final  captured  value  is
-       unset,  even  if  it was (temporarily) set at a deeper level during the
+       the  value  for  the  inner capturing parentheses (numbered 2) is "ef",
+       which is the last value taken on at the top level. If a capturing  sub-
+       pattern  is  not  matched at the top level, its final captured value is
+       unset, even if it was (temporarily) set at a deeper  level  during  the
        matching process.
 
        If there are more than 15 capturing parentheses in a pattern, PCRE2 has
-       to  obtain extra memory from the heap to store data during a recursion.
-       If  no  memory  can   be   obtained,   the   match   fails   with   the
+       to obtain extra memory from the heap to store data during a  recursion.
+       If   no   memory   can   be   obtained,   the   match  fails  with  the
        PCRE2_ERROR_NOMEMORY error.
 
-       Do  not  confuse  the (?R) item with the condition (R), which tests for
-       recursion.  Consider this pattern, which matches text in  angle  brack-
-       ets,  allowing for arbitrary nesting. Only digits are allowed in nested
-       brackets (that is, when recursing), whereas any characters are  permit-
+       Do not confuse the (?R) item with the condition (R),  which  tests  for
+       recursion.   Consider  this pattern, which matches text in angle brack-
+       ets, allowing for arbitrary nesting. Only digits are allowed in  nested
+       brackets  (that is, when recursing), whereas any characters are permit-
        ted at the outer level.
 
          < (?: (?(R) \d++  | [^<>]*+) | (?R)) * >
 
-       In  this  pattern, (?(R) is the start of a conditional subpattern, with
-       two different alternatives for the recursive and  non-recursive  cases.
+       In this pattern, (?(R) is the start of a conditional  subpattern,  with
+       two  different  alternatives for the recursive and non-recursive cases.
        The (?R) item is the actual recursive call.
 
    Differences in recursion processing between PCRE2 and Perl
 
        Some former differences between PCRE2 and Perl no longer exist.
 
-       Before  release 10.30, recursion processing in PCRE2 differed from Perl
-       in that a recursive subpattern call was always  treated  as  an  atomic
-       group.  That is, once it had matched some of the subject string, it was
-       never re-entered, even if it contained untried alternatives  and  there
-       was  a  subsequent matching failure. (Historical note: PCRE implemented
+       Before release 10.30, recursion processing in PCRE2 differed from  Perl
+       in  that  a  recursive  subpattern call was always treated as an atomic
+       group. That is, once it had matched some of the subject string, it  was
+       never  re-entered,  even if it contained untried alternatives and there
+       was a subsequent matching failure. (Historical note:  PCRE  implemented
        recursion before Perl did.)
 
-       Starting with release 10.30, recursive subroutine calls are  no  longer
+       Starting  with  release 10.30, recursive subroutine calls are no longer
        treated as atomic. That is, they can be re-entered to try unused alter-
-       natives if there is a matching failure later in the  pattern.  This  is
-       now  compatible  with the way Perl works. If you want a subroutine call
+       natives  if  there  is a matching failure later in the pattern. This is
+       now compatible with the way Perl works. If you want a  subroutine  call
        to be atomic, you must explicitly enclose it in an atomic group.
 
-       Supporting backtracking into recursions  simplifies  certain  types  of
+       Supporting  backtracking  into  recursions  simplifies certain types of
        recursive  pattern.  For  example,  this  pattern  matches  palindromic
        strings:
 
          ^((.)(?1)\2|.?)$
 
-       The second branch in the group matches a single  central  character  in
-       the  palindrome  when there are an odd number of characters, or nothing
-       when there are an even number of characters, but in order  to  work  it
-       has  to  be  able  to  try the second case when the rest of the pattern
+       The  second  branch  in the group matches a single central character in
+       the palindrome when there are an odd number of characters,  or  nothing
+       when  there  are  an even number of characters, but in order to work it
+       has to be able to try the second case when  the  rest  of  the  pattern
        match fails. If you want to match typical palindromic phrases, the pat-
-       tern  has  to  ignore  all  non-word characters, which can be done like
+       tern has to ignore all non-word characters,  which  can  be  done  like
        this:
 
          ^\W*+((.)\W*+(?1)\W*+\2|\W*+.?)\W*+$
 
-       If run with the PCRE2_CASELESS option,  this  pattern  matches  phrases
-       such  as "A man, a plan, a canal: Panama!". Note the use of the posses-
-       sive quantifier *+ to avoid backtracking  into  sequences  of  non-word
+       If  run  with  the  PCRE2_CASELESS option, this pattern matches phrases
+       such as "A man, a plan, a canal: Panama!". Note the use of the  posses-
+       sive  quantifier  *+  to  avoid backtracking into sequences of non-word
        characters. Without this, PCRE2 takes a great deal longer (ten times or
-       more) to match typical phrases, and Perl takes so long that  you  think
+       more)  to  match typical phrases, and Perl takes so long that you think
        it has gone into a loop.
 
-       Another  way  in which PCRE2 and Perl used to differ in their recursion
-       processing is in the handling of captured  values.  Formerly  in  Perl,
-       when  a  subpattern  was called recursively or as a subpattern (see the
-       next section), it had no access to any values that were  captured  out-
-       side  the  recursion,  whereas in PCRE2 these values can be referenced.
+       Another way in which PCRE2 and Perl used to differ in  their  recursion
+       processing  is  in  the  handling of captured values. Formerly in Perl,
+       when a subpattern was called recursively or as a  subpattern  (see  the
+       next  section),  it had no access to any values that were captured out-
+       side the recursion, whereas in PCRE2 these values  can  be  referenced.
        Consider this pattern:
 
          ^(.)(\1|a(?2))
 
-       This pattern matches "bab". The first capturing parentheses match  "b",
-       then  in  the  second  group, when the back reference \1 fails to match
-       "b", the second alternative matches  "a"  and  then  recurses.  In  the
-       recursion,  \1 does now match "b" and so the whole match succeeds. This
-       match used to fail in Perl, but in later versions (I  tried  5.024)  it
+       This  pattern matches "bab". The first capturing parentheses match "b",
+       then in the second group, when the back reference  \1  fails  to  match
+       "b",  the  second  alternative  matches  "a"  and then recurses. In the
+       recursion, \1 does now match "b" and so the whole match succeeds.  This
+       match  used  to  fail in Perl, but in later versions (I tried 5.024) it
        now works.
 
 
 SUBPATTERNS AS SUBROUTINES
 
-       If  the  syntax for a recursive subpattern call (either by number or by
-       name) is used outside the parentheses to which it refers,  it  operates
-       like  a subroutine in a programming language. The called subpattern may
-       be defined before or after the reference. A numbered reference  can  be
+       If the syntax for a recursive subpattern call (either by number  or  by
+       name)  is  used outside the parentheses to which it refers, it operates
+       like a subroutine in a programming language. The called subpattern  may
+       be  defined  before or after the reference. A numbered reference can be
        absolute or relative, as in these examples:
 
          (...(absolute)...)...(?2)...
@@ -8149,102 +8150,102 @@ SUBPATTERNS AS SUBROUTINES
 
          (sens|respons)e and \1ibility
 
-       matches  "sense and sensibility" and "response and responsibility", but
+       matches "sense and sensibility" and "response and responsibility",  but
        not "sense and responsibility". If instead the pattern
 
          (sens|respons)e and (?1)ibility
 
-       is used, it does match "sense and responsibility" as well as the  other
-       two  strings.  Another  example  is  given  in the discussion of DEFINE
+       is  used, it does match "sense and responsibility" as well as the other
+       two strings. Another example is  given  in  the  discussion  of  DEFINE
        above.
 
-       Like recursions, subroutine calls used to be  treated  as  atomic,  but
-       this  changed  at  PCRE2 release 10.30, so backtracking into subroutine
-       calls can now occur. However, any capturing parentheses  that  are  set
+       Like  recursions,  subroutine  calls  used to be treated as atomic, but
+       this changed at PCRE2 release 10.30, so  backtracking  into  subroutine
+       calls  can  now  occur. However, any capturing parentheses that are set
        during the subroutine call revert to their previous values afterwards.
 
-       Processing  options  such as case-independence are fixed when a subpat-
-       tern is defined, so if it is used as a subroutine, such options  cannot
+       Processing options such as case-independence are fixed when  a  subpat-
+       tern  is defined, so if it is used as a subroutine, such options cannot
        be changed for different calls. For example, consider this pattern:
 
          (abc)(?i:(?-1))
 
-       It  matches  "abcabc". It does not match "abcABC" because the change of
+       It matches "abcabc". It does not match "abcABC" because the  change  of
        processing option does not affect the called subpattern.
 
 
 ONIGURUMA SUBROUTINE SYNTAX
 
-       For compatibility with Oniguruma, the non-Perl syntax \g followed by  a
+       For  compatibility with Oniguruma, the non-Perl syntax \g followed by a
        name or a number enclosed either in angle brackets or single quotes, is
-       an alternative syntax for referencing a  subpattern  as  a  subroutine,
-       possibly  recursively. Here are two of the examples used above, rewrit-
+       an  alternative  syntax  for  referencing a subpattern as a subroutine,
+       possibly recursively. Here are two of the examples used above,  rewrit-
        ten using this syntax:
 
          (?<pn> \( ( (?>[^()]+) | \g<pn> )* \) )
          (sens|respons)e and \g'1'ibility
 
-       PCRE2 supports an extension to Oniguruma: if a number is preceded by  a
+       PCRE2  supports an extension to Oniguruma: if a number is preceded by a
        plus or a minus sign it is taken as a relative reference. For example:
 
          (abc)(?i:\g<-1>)
 
-       Note  that \g{...} (Perl syntax) and \g<...> (Oniguruma syntax) are not
-       synonymous. The former is a back reference; the latter is a  subroutine
+       Note that \g{...} (Perl syntax) and \g<...> (Oniguruma syntax) are  not
+       synonymous.  The former is a back reference; the latter is a subroutine
        call.
 
 
 CALLOUTS
 
        Perl has a feature whereby using the sequence (?{...}) causes arbitrary
-       Perl code to be obeyed in the middle of matching a regular  expression.
+       Perl  code to be obeyed in the middle of matching a regular expression.
        This makes it possible, amongst other things, to extract different sub-
        strings that match the same pair of parentheses when there is a repeti-
        tion.
 
-       PCRE2  provides  a  similar feature, but of course it cannot obey arbi-
-       trary Perl code. The feature is called "callout". The caller  of  PCRE2
-       provides  an  external  function  by putting its entry point in a match
-       context using the function pcre2_set_callout(), and then  passing  that
-       context  to  pcre2_match() or pcre2_dfa_match(). If no match context is
+       PCRE2 provides a similar feature, but of course it  cannot  obey  arbi-
+       trary  Perl  code. The feature is called "callout". The caller of PCRE2
+       provides an external function by putting its entry  point  in  a  match
+       context  using  the function pcre2_set_callout(), and then passing that
+       context to pcre2_match() or pcre2_dfa_match(). If no match  context  is
        passed, or if the callout entry point is set to NULL, callouts are dis-
        abled.
 
-       Within  a  regular expression, (?C<arg>) indicates a point at which the
-       external function is to be called. There  are  two  kinds  of  callout:
-       those  with a numerical argument and those with a string argument. (?C)
-       on its own with no argument is treated as (?C0). A  numerical  argument
-       allows  the  application  to  distinguish  between  different callouts.
-       String arguments were added for release 10.20 to make it  possible  for
-       script  languages that use PCRE2 to embed short scripts within patterns
+       Within a regular expression, (?C<arg>) indicates a point at  which  the
+       external  function  is  to  be  called. There are two kinds of callout:
+       those with a numerical argument and those with a string argument.  (?C)
+       on  its  own with no argument is treated as (?C0). A numerical argument
+       allows the  application  to  distinguish  between  different  callouts.
+       String  arguments  were added for release 10.20 to make it possible for
+       script languages that use PCRE2 to embed short scripts within  patterns
        in a similar way to Perl.
 
        During matching, when PCRE2 reaches a callout point, the external func-
-       tion  is  called.  It is provided with the number or string argument of
-       the callout, the position in the pattern, and one item of data that  is
+       tion is called. It is provided with the number or  string  argument  of
+       the  callout, the position in the pattern, and one item of data that is
        also set in the match block. The callout function may cause matching to
        proceed, to backtrack, or to fail.
 
-       By default, PCRE2 implements a  number  of  optimizations  at  matching
-       time,  and  one  side-effect is that sometimes callouts are skipped. If
-       you need all possible callouts to happen, you need to set options  that
-       disable  the relevant optimizations. More details, including a complete
-       description of the programming interface to the callout  function,  are
+       By  default,  PCRE2  implements  a  number of optimizations at matching
+       time, and one side-effect is that sometimes callouts  are  skipped.  If
+       you  need all possible callouts to happen, you need to set options that
+       disable the relevant optimizations. More details, including a  complete
+       description  of  the programming interface to the callout function, are
        given in the pcre2callout documentation.
 
    Callouts with numerical arguments
 
-       If  you  just  want  to  have  a means of identifying different callout
-       points, put a number less than 256 after the  letter  C.  For  example,
+       If you just want to have  a  means  of  identifying  different  callout
+       points,  put  a  number  less than 256 after the letter C. For example,
        this pattern has two callout points:
 
          (?C1)abc(?C2)def
 
-       If  the PCRE2_AUTO_CALLOUT flag is passed to pcre2_compile(), numerical
-       callouts are automatically installed before each item in  the  pattern.
-       They  are all numbered 255. If there is a conditional group in the pat-
+       If the PCRE2_AUTO_CALLOUT flag is passed to pcre2_compile(),  numerical
+       callouts  are  automatically installed before each item in the pattern.
+       They are all numbered 255. If there is a conditional group in the  pat-
        tern whose condition is an assertion, an additional callout is inserted
-       just  before the condition. An explicit callout may also be set at this
+       just before the condition. An explicit callout may also be set at  this
        position, as in this example:
 
          (?(?C9)(?=a)abc|def)
@@ -8254,60 +8255,60 @@ CALLOUTS
 
    Callouts with string arguments
 
-       A  delimited  string may be used instead of a number as a callout argu-
-       ment. The starting delimiter must be one of ` ' " ^ % #  $  {  and  the
+       A delimited string may be used instead of a number as a  callout  argu-
+       ment.  The  starting  delimiter  must be one of ` ' " ^ % # $ { and the
        ending delimiter is the same as the start, except for {, where the end-
-       ing delimiter is }. If  the  ending  delimiter  is  needed  within  the
+       ing  delimiter  is  }.  If  the  ending  delimiter is needed within the
        string, it must be doubled. For example:
 
          (?C'ab ''c'' d')xyz(?C{any text})pqr
 
-       The  doubling  is  removed  before  the string is passed to the callout
+       The doubling is removed before the string  is  passed  to  the  callout
        function.
 
 
 BACKTRACKING CONTROL
 
-       There are a number of special  "Backtracking  Control  Verbs"  (to  use
-       Perl's  terminology)  that  modify the behaviour of backtracking during
-       matching. They are generally of the form (*VERB) or (*VERB:NAME).  Some
-       verbs  take  either  form,  possibly  behaving differently depending on
+       There  are  a  number  of  special "Backtracking Control Verbs" (to use
+       Perl's terminology) that modify the behaviour  of  backtracking  during
+       matching.  They are generally of the form (*VERB) or (*VERB:NAME). Some
+       verbs take either form,  possibly  behaving  differently  depending  on
        whether or not a name is present.
 
-       By default, for compatibility with Perl, a  name  is  any  sequence  of
+       By  default,  for  compatibility  with  Perl, a name is any sequence of
        characters that does not include a closing parenthesis. The name is not
-       processed in any way, and it is  not  possible  to  include  a  closing
-       parenthesis   in  the  name.   This  can  be  changed  by  setting  the
-       PCRE2_ALT_VERBNAMES option, but the result is no  longer  Perl-compati-
+       processed  in  any  way,  and  it  is not possible to include a closing
+       parenthesis  in  the  name.   This  can  be  changed  by  setting   the
+       PCRE2_ALT_VERBNAMES  option,  but the result is no longer Perl-compati-
        ble.
 
-       When  PCRE2_ALT_VERBNAMES  is  set,  backslash processing is applied to
-       verb names and only an unescaped  closing  parenthesis  terminates  the
-       name.  However, the only backslash items that are permitted are \Q, \E,
-       and sequences such as \x{100} that define character code points.  Char-
+       When PCRE2_ALT_VERBNAMES is set, backslash  processing  is  applied  to
+       verb  names  and  only  an unescaped closing parenthesis terminates the
+       name. However, the only backslash items that are permitted are \Q,  \E,
+       and  sequences such as \x{100} that define character code points. Char-
        acter type escapes such as \d are faulted.
 
        A closing parenthesis can be included in a name either as \) or between
-       \Q and \E. In addition to backslash processing, if  the  PCRE2_EXTENDED
-       option  is also set, unescaped whitespace in verb names is skipped, and
-       #-comments are recognized, exactly as  in  the  rest  of  the  pattern.
+       \Q  and  \E. In addition to backslash processing, if the PCRE2_EXTENDED
+       option is also set, unescaped whitespace in verb names is skipped,  and
+       #-comments  are  recognized,  exactly  as  in  the rest of the pattern.
        PCRE2_EXTENDED does not affect verb names unless PCRE2_ALT_VERBNAMES is
        also set.
 
-       The maximum length of a name is 255 in the 8-bit library and  65535  in
-       the  16-bit and 32-bit libraries. If the name is empty, that is, if the
-       closing parenthesis immediately follows the colon, the effect is as  if
+       The  maximum  length of a name is 255 in the 8-bit library and 65535 in
+       the 16-bit and 32-bit libraries. If the name is empty, that is, if  the
+       closing  parenthesis immediately follows the colon, the effect is as if
        the colon were not there. Any number of these verbs may occur in a pat-
        tern.
 
-       Since these verbs are specifically related  to  backtracking,  most  of
-       them  can be used only when the pattern is to be matched using the tra-
+       Since  these  verbs  are  specifically related to backtracking, most of
+       them can be used only when the pattern is to be matched using the  tra-
        ditional matching function, because that uses a backtracking algorithm.
-       With  the  exception  of (*FAIL), which behaves like a failing negative
+       With the exception of (*FAIL), which behaves like  a  failing  negative
        assertion, the backtracking control verbs cause an error if encountered
        by the DFA matching function.
 
-       The  behaviour  of  these  verbs in repeated groups, assertions, and in
+       The behaviour of these verbs in repeated  groups,  assertions,  and  in
        subpatterns called as subroutines (whether or not recursively) is docu-
        mented below.
 
@@ -8315,71 +8316,71 @@ BACKTRACKING CONTROL
 
        PCRE2 contains some optimizations that are used to speed up matching by
        running some checks at the start of each match attempt. For example, it
-       may  know  the minimum length of matching subject, or that a particular
+       may know the minimum length of matching subject, or that  a  particular
        character must be present. When one of these optimizations bypasses the
-       running  of  a  match,  any  included  backtracking  verbs will not, of
+       running of a match,  any  included  backtracking  verbs  will  not,  of
        course, be processed. You can suppress the start-of-match optimizations
-       by  setting  the PCRE2_NO_START_OPTIMIZE option when calling pcre2_com-
-       pile(), or by starting the pattern with (*NO_START_OPT). There is  more
+       by setting the PCRE2_NO_START_OPTIMIZE option when  calling  pcre2_com-
+       pile(),  or by starting the pattern with (*NO_START_OPT). There is more
        discussion of this option in the section entitled "Compiling a pattern"
        in the pcre2api documentation.
 
-       Experiments with Perl suggest that it too  has  similar  optimizations,
+       Experiments  with  Perl  suggest that it too has similar optimizations,
        sometimes leading to anomalous results.
 
    Verbs that act immediately
 
-       The  following  verbs act as soon as they are encountered. They may not
+       The following verbs act as soon as they are encountered. They  may  not
        be followed by a name.
 
           (*ACCEPT)
 
-       This verb causes the match to end successfully, skipping the  remainder
-       of  the pattern. However, when it is inside a subpattern that is called
-       as a subroutine, only that subpattern is ended  successfully.  Matching
+       This  verb causes the match to end successfully, skipping the remainder
+       of the pattern. However, when it is inside a subpattern that is  called
+       as  a  subroutine, only that subpattern is ended successfully. Matching
        then continues at the outer level. If (*ACCEPT) in triggered in a posi-
-       tive assertion, the assertion succeeds; in a  negative  assertion,  the
+       tive  assertion,  the  assertion succeeds; in a negative assertion, the
        assertion fails.
 
-       If  (*ACCEPT)  is inside capturing parentheses, the data so far is cap-
+       If (*ACCEPT) is inside capturing parentheses, the data so far  is  cap-
        tured. For example:
 
          A((?:A|B(*ACCEPT)|C)D)
 
-       This matches "AB", "AAD", or "ACD"; when it matches "AB", "B"  is  cap-
+       This  matches  "AB", "AAD", or "ACD"; when it matches "AB", "B" is cap-
        tured by the outer parentheses.
 
          (*FAIL) or (*F)
 
-       This  verb causes a matching failure, forcing backtracking to occur. It
-       is equivalent to (?!) but easier to read. The Perl documentation  notes
-       that  it  is  probably  useful only when combined with (?{}) or (??{}).
-       Those are, of course, Perl features that are not present in PCRE2.  The
-       nearest  equivalent is the callout feature, as for example in this pat-
+       This verb causes a matching failure, forcing backtracking to occur.  It
+       is  equivalent to (?!) but easier to read. The Perl documentation notes
+       that it is probably useful only when combined  with  (?{})  or  (??{}).
+       Those  are, of course, Perl features that are not present in PCRE2. The
+       nearest equivalent is the callout feature, as for example in this  pat-
        tern:
 
          a+(?C)(*FAIL)
 
-       A match with the string "aaaa" always fails, but the callout  is  taken
+       A  match  with the string "aaaa" always fails, but the callout is taken
        before each backtrack happens (in this example, 10 times).
 
    Recording which path was taken
 
-       There  is  one  verb  whose  main  purpose  is to track how a match was
-       arrived at, though it also has a  secondary  use  in  conjunction  with
+       There is one verb whose main purpose  is  to  track  how  a  match  was
+       arrived  at,  though  it  also  has a secondary use in conjunction with
        advancing the match starting point (see (*SKIP) below).
 
          (*MARK:NAME) or (*:NAME)
 
-       A  name  is  always  required  with  this  verb.  There  may be as many
-       instances of (*MARK) as you like in a pattern, and their names  do  not
+       A name is always  required  with  this  verb.  There  may  be  as  many
+       instances  of  (*MARK) as you like in a pattern, and their names do not
        have to be unique.
 
-       When  a  match succeeds, the name of the last-encountered (*MARK:NAME),
-       (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed  back  to
-       the  caller  as  described  in  the section entitled "Other information
-       about the match" in the pcre2api documentation. Here is an  example  of
-       pcre2test  output, where the "mark" modifier requests the retrieval and
+       When a match succeeds, the name of the  last-encountered  (*MARK:NAME),
+       (*PRUNE:NAME),  or  (*THEN:NAME) on the matching path is passed back to
+       the caller as described in  the  section  entitled  "Other  information
+       about  the  match" in the pcre2api documentation. Here is an example of
+       pcre2test output, where the "mark" modifier requests the retrieval  and
        outputting of (*MARK) data:
 
            re> /X(*MARK:A)Y|X(*MARK:B)Z/mark
@@ -8391,72 +8392,72 @@ BACKTRACKING CONTROL
          MK: B
 
        The (*MARK) name is tagged with "MK:" in this output, and in this exam-
-       ple  it indicates which of the two alternatives matched. This is a more
-       efficient way of obtaining this information than putting each  alterna-
+       ple it indicates which of the two alternatives matched. This is a  more
+       efficient  way of obtaining this information than putting each alterna-
        tive in its own capturing parentheses.
 
-       If  a  verb  with a name is encountered in a positive assertion that is
-       true, the name is recorded and passed back if it  is  the  last-encoun-
+       If a verb with a name is encountered in a positive  assertion  that  is
+       true,  the  name  is recorded and passed back if it is the last-encoun-
        tered. This does not happen for negative assertions or failing positive
        assertions.
 
-       After a partial match or a failed match, the last encountered  name  in
+       After  a  partial match or a failed match, the last encountered name in
        the entire match process is returned. For example:
 
            re> /X(*MARK:A)Y|X(*MARK:B)Z/mark
          data> XP
          No match, mark = B
 
-       Note  that  in  this  unanchored  example the mark is retained from the
+       Note that in this unanchored example the  mark  is  retained  from  the
        match attempt that started at the letter "X" in the subject. Subsequent
        match attempts starting at "P" and then with an empty string do not get
        as far as the (*MARK) item, but nevertheless do not reset it.
 
-       If you are interested in  (*MARK)  values  after  failed  matches,  you
-       should  probably  set the PCRE2_NO_START_OPTIMIZE option (see above) to
+       If  you  are  interested  in  (*MARK)  values after failed matches, you
+       should probably set the PCRE2_NO_START_OPTIMIZE option (see  above)  to
        ensure that the match is always attempted.
 
    Verbs that act after backtracking
 
        The following verbs do nothing when they are encountered. Matching con-
-       tinues  with what follows, but if there is no subsequent match, causing
-       a backtrack to the verb, a failure is  forced.  That  is,  backtracking
-       cannot  pass  to the left of the verb. However, when one of these verbs
-       appears inside an atomic group or in an assertion  that  is  true,  its
-       effect  is  confined  to  that  group,  because once the group has been
-       matched, there is never any backtracking into it.  In  this  situation,
-       backtracking  has  to  jump  to  the left of the entire atomic group or
+       tinues with what follows, but if there is no subsequent match,  causing
+       a  backtrack  to  the  verb, a failure is forced. That is, backtracking
+       cannot pass to the left of the verb. However, when one of  these  verbs
+       appears  inside  an  atomic  group or in an assertion that is true, its
+       effect is confined to that group,  because  once  the  group  has  been
+       matched,  there  is  never any backtracking into it. In this situation,
+       backtracking has to jump to the left of  the  entire  atomic  group  or
        assertion.
 
-       These verbs differ in exactly what kind of failure  occurs  when  back-
-       tracking  reaches  them.  The behaviour described below is what happens
-       when the verb is not in a subroutine or an assertion.  Subsequent  sec-
+       These  verbs  differ  in exactly what kind of failure occurs when back-
+       tracking reaches them. The behaviour described below  is  what  happens
+       when  the  verb is not in a subroutine or an assertion. Subsequent sec-
        tions cover these special cases.
 
          (*COMMIT)
 
-       This  verb, which may not be followed by a name, causes the whole match
+       This verb, which may not be followed by a name, causes the whole  match
        to fail outright if there is a later matching failure that causes back-
-       tracking  to  reach  it.  Even if the pattern is unanchored, no further
+       tracking to reach it. Even if the pattern  is  unanchored,  no  further
        attempts to find a match by advancing the starting point take place. If
-       (*COMMIT)  is  the  only backtracking verb that is encountered, once it
-       has been passed pcre2_match() is committed to finding a  match  at  the
+       (*COMMIT) is the only backtracking verb that is  encountered,  once  it
+       has  been  passed  pcre2_match() is committed to finding a match at the
        current starting point, or not at all. For example:
 
          a+(*COMMIT)b
 
-       This  matches  "xxaab" but not "aacaab". It can be thought of as a kind
+       This matches "xxaab" but not "aacaab". It can be thought of as  a  kind
        of dynamic anchor, or "I've started, so I must finish." The name of the
-       most  recently passed (*MARK) in the path is passed back when (*COMMIT)
+       most recently passed (*MARK) in the path is passed back when  (*COMMIT)
        forces a match failure.
 
-       If there is more than one backtracking verb in a pattern,  a  different
-       one  that  follows  (*COMMIT) may be triggered first, so merely passing
+       If  there  is more than one backtracking verb in a pattern, a different
+       one that follows (*COMMIT) may be triggered first,  so  merely  passing
        (*COMMIT) during a match does not always guarantee that a match must be
        at this starting point.
 
-       Note  that  (*COMMIT)  at  the start of a pattern is not the same as an
-       anchor, unless PCRE2's start-of-match optimizations are turned off,  as
+       Note that (*COMMIT) at the start of a pattern is not  the  same  as  an
+       anchor,  unless PCRE2's start-of-match optimizations are turned off, as
        shown in this output from pcre2test:
 
            re> /(*COMMIT)abc/
@@ -8467,213 +8468,213 @@ BACKTRACKING CONTROL
          data> xyzabc
          No match
 
-       For  the first pattern, PCRE2 knows that any match must start with "a",
-       so the optimization skips along the subject to "a" before applying  the
-       pattern  to the first set of data. The match attempt then succeeds. The
-       second pattern disables the optimization that skips along to the  first
-       character.  The  pattern  is  now  applied  starting at "x", and so the
-       (*COMMIT) causes the match to fail without trying  any  other  starting
+       For the first pattern, PCRE2 knows that any match must start with  "a",
+       so  the optimization skips along the subject to "a" before applying the
+       pattern to the first set of data. The match attempt then succeeds.  The
+       second  pattern disables the optimization that skips along to the first
+       character. The pattern is now applied  starting  at  "x",  and  so  the
+       (*COMMIT)  causes  the  match to fail without trying any other starting
        points.
 
          (*PRUNE) or (*PRUNE:NAME)
 
-       This  verb causes the match to fail at the current starting position in
+       This verb causes the match to fail at the current starting position  in
        the subject if there is a later matching failure that causes backtrack-
-       ing  to  reach it. If the pattern is unanchored, the normal "bumpalong"
-       advance to the next starting character then happens.  Backtracking  can
-       occur  as  usual to the left of (*PRUNE), before it is reached, or when
-       matching to the right of (*PRUNE), but if there  is  no  match  to  the
-       right,  backtracking cannot cross (*PRUNE). In simple cases, the use of
-       (*PRUNE) is just an alternative to an atomic group or possessive  quan-
+       ing to reach it. If the pattern is unanchored, the  normal  "bumpalong"
+       advance  to  the next starting character then happens. Backtracking can
+       occur as usual to the left of (*PRUNE), before it is reached,  or  when
+       matching  to  the  right  of  (*PRUNE), but if there is no match to the
+       right, backtracking cannot cross (*PRUNE). In simple cases, the use  of
+       (*PRUNE)  is just an alternative to an atomic group or possessive quan-
        tifier, but there are some uses of (*PRUNE) that cannot be expressed in
-       any other way. In an anchored pattern (*PRUNE) has the same  effect  as
+       any  other  way. In an anchored pattern (*PRUNE) has the same effect as
        (*COMMIT).
 
        The behaviour of (*PRUNE:NAME) is not the same as (*MARK:NAME)(*PRUNE).
        It is like (*MARK:NAME) in that the name is remembered for passing back
-       to  the  caller. However, (*SKIP:NAME) searches only for names set with
+       to the caller. However, (*SKIP:NAME) searches only for names  set  with
        (*MARK), ignoring those set by (*PRUNE) or (*THEN).
 
          (*SKIP)
 
-       This verb, when given without a name, is like (*PRUNE), except that  if
-       the  pattern  is unanchored, the "bumpalong" advance is not to the next
+       This  verb, when given without a name, is like (*PRUNE), except that if
+       the pattern is unanchored, the "bumpalong" advance is not to  the  next
        character, but to the position in the subject where (*SKIP) was encoun-
-       tered.  (*SKIP)  signifies that whatever text was matched leading up to
+       tered. (*SKIP) signifies that whatever text was matched leading  up  to
        it cannot be part of a successful match. Consider:
 
          a+(*SKIP)b
 
-       If the subject is "aaaac...",  after  the  first  match  attempt  fails
-       (starting  at  the  first  character in the string), the starting point
+       If  the  subject  is  "aaaac...",  after  the first match attempt fails
+       (starting at the first character in the  string),  the  starting  point
        skips on to start the next attempt at "c". Note that a possessive quan-
-       tifer  does not have the same effect as this example; although it would
-       suppress backtracking  during  the  first  match  attempt,  the  second
-       attempt  would  start at the second character instead of skipping on to
+       tifer does not have the same effect as this example; although it  would
+       suppress  backtracking  during  the  first  match  attempt,  the second
+       attempt would start at the second character instead of skipping  on  to
        "c".
 
          (*SKIP:NAME)
 
        When (*SKIP) has an associated name, its behaviour is modified. When it
        is triggered, the previous path through the pattern is searched for the
-       most recent (*MARK) that has the  same  name.  If  one  is  found,  the
+       most  recent  (*MARK)  that  has  the  same  name. If one is found, the
        "bumpalong" advance is to the subject position that corresponds to that
        (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with
        a matching name is found, the (*SKIP) is ignored.
 
-       Note  that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It
+       Note that (*SKIP:NAME) searches only for names set by (*MARK:NAME).  It
        ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).
 
          (*THEN) or (*THEN:NAME)
 
-       This verb causes a skip to the next innermost  alternative  when  back-
-       tracking  reaches  it.  That  is,  it  cancels any further backtracking
-       within the current alternative. Its name  comes  from  the  observation
+       This  verb  causes  a skip to the next innermost alternative when back-
+       tracking reaches it. That  is,  it  cancels  any  further  backtracking
+       within  the  current  alternative.  Its name comes from the observation
        that it can be used for a pattern-based if-then-else block:
 
          ( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...
 
-       If  the COND1 pattern matches, FOO is tried (and possibly further items
-       after the end of the group if FOO succeeds); on  failure,  the  matcher
-       skips  to  the second alternative and tries COND2, without backtracking
-       into COND1. If that succeeds and BAR fails, COND3 is tried.  If  subse-
-       quently  BAZ fails, there are no more alternatives, so there is a back-
-       track to whatever came before the  entire  group.  If  (*THEN)  is  not
+       If the COND1 pattern matches, FOO is tried (and possibly further  items
+       after  the  end  of the group if FOO succeeds); on failure, the matcher
+       skips to the second alternative and tries COND2,  without  backtracking
+       into  COND1.  If that succeeds and BAR fails, COND3 is tried. If subse-
+       quently BAZ fails, there are no more alternatives, so there is a  back-
+       track  to  whatever  came  before  the  entire group. If (*THEN) is not
        inside an alternation, it acts like (*PRUNE).
 
-       The    behaviour   of   (*THEN:NAME)   is   the   not   the   same   as
-       (*MARK:NAME)(*THEN).  It is like  (*MARK:NAME)  in  that  the  name  is
-       remembered  for  passing  back  to  the  caller.  However, (*SKIP:NAME)
-       searches only for  names  set  with  (*MARK),  ignoring  those  set  by
+       The   behaviour   of   (*THEN:NAME)   is   the   not   the   same    as
+       (*MARK:NAME)(*THEN).   It  is  like  (*MARK:NAME)  in  that the name is
+       remembered for  passing  back  to  the  caller.  However,  (*SKIP:NAME)
+       searches  only  for  names  set  with  (*MARK),  ignoring  those set by
        (*PRUNE) and (*THEN).
 
-       A  subpattern that does not contain a | character is just a part of the
-       enclosing alternative; it is not a nested  alternation  with  only  one
-       alternative.  The effect of (*THEN) extends beyond such a subpattern to
-       the enclosing alternative. Consider this pattern, where A, B, etc.  are
-       complex  pattern fragments that do not contain any | characters at this
+       A subpattern that does not contain a | character is just a part of  the
+       enclosing  alternative;  it  is  not a nested alternation with only one
+       alternative. The effect of (*THEN) extends beyond such a subpattern  to
+       the  enclosing alternative. Consider this pattern, where A, B, etc. are
+       complex pattern fragments that do not contain any | characters at  this
        level:
 
          A (B(*THEN)C) | D
 
-       If A and B are matched, but there is a failure in C, matching does  not
+       If  A and B are matched, but there is a failure in C, matching does not
        backtrack into A; instead it moves to the next alternative, that is, D.
-       However, if the subpattern containing (*THEN) is given an  alternative,
+       However,  if the subpattern containing (*THEN) is given an alternative,
        it behaves differently:
 
          A (B(*THEN)C | (*FAIL)) | D
 
-       The  effect of (*THEN) is now confined to the inner subpattern. After a
+       The effect of (*THEN) is now confined to the inner subpattern. After  a
        failure in C, matching moves to (*FAIL), which causes the whole subpat-
-       tern  to  fail  because  there are no more alternatives to try. In this
+       tern to fail because there are no more alternatives  to  try.  In  this
        case, matching does now backtrack into A.
 
-       Note that a conditional subpattern is  not  considered  as  having  two
-       alternatives,  because  only  one  is  ever used. In other words, the |
+       Note  that  a  conditional  subpattern  is not considered as having two
+       alternatives, because only one is ever used.  In  other  words,  the  |
        character in a conditional subpattern has a different meaning. Ignoring
        white space, consider:
 
          ^.*? (?(?=a) a | b(*THEN)c )
 
-       If  the  subject  is  "ba", this pattern does not match. Because .*? is
-       ungreedy, it initially matches zero  characters.  The  condition  (?=a)
-       then  fails,  the  character  "b"  is  matched, but "c" is not. At this
-       point, matching does not backtrack to .*? as might perhaps be  expected
-       from  the  presence  of  the | character. The conditional subpattern is
+       If the subject is "ba", this pattern does not  match.  Because  .*?  is
+       ungreedy,  it  initially  matches  zero characters. The condition (?=a)
+       then fails, the character "b" is matched,  but  "c"  is  not.  At  this
+       point,  matching does not backtrack to .*? as might perhaps be expected
+       from the presence of the | character.  The  conditional  subpattern  is
        part of the single alternative that comprises the whole pattern, and so
-       the  match  fails.  (If  there was a backtrack into .*?, allowing it to
+       the match fails. (If there was a backtrack into  .*?,  allowing  it  to
        match "b", the match would succeed.)
 
-       The verbs just described provide four different "strengths" of  control
+       The  verbs just described provide four different "strengths" of control
        when subsequent matching fails. (*THEN) is the weakest, carrying on the
-       match at the next alternative. (*PRUNE) comes next, failing  the  match
-       at  the  current starting position, but allowing an advance to the next
-       character (for an unanchored pattern). (*SKIP) is similar, except  that
+       match  at  the next alternative. (*PRUNE) comes next, failing the match
+       at the current starting position, but allowing an advance to  the  next
+       character  (for an unanchored pattern). (*SKIP) is similar, except that
        the advance may be more than one character. (*COMMIT) is the strongest,
        causing the entire match to fail.
 
    More than one backtracking verb
 
-       If more than one backtracking verb is present in  a  pattern,  the  one
-       that  is  backtracked  onto first acts. For example, consider this pat-
+       If  more  than  one  backtracking verb is present in a pattern, the one
+       that is backtracked onto first acts. For example,  consider  this  pat-
        tern, where A, B, etc. are complex pattern fragments:
 
          (A(*COMMIT)B(*THEN)C|ABD)
 
-       If A matches but B fails, the backtrack to (*COMMIT) causes the  entire
+       If  A matches but B fails, the backtrack to (*COMMIT) causes the entire
        match to fail. However, if A and B match, but C fails, the backtrack to
-       (*THEN) causes the next alternative (ABD) to be tried.  This  behaviour
-       is  consistent,  but is not always the same as Perl's. It means that if
-       two or more backtracking verbs appear in succession, all the  the  last
+       (*THEN)  causes  the next alternative (ABD) to be tried. This behaviour
+       is consistent, but is not always the same as Perl's. It means  that  if
+       two  or  more backtracking verbs appear in succession, all the the last
        of them has no effect. Consider this example:
 
          ...(*COMMIT)(*PRUNE)...
 
        If there is a matching failure to the right, backtracking onto (*PRUNE)
-       causes it to be triggered, and its action is taken. There can never  be
+       causes  it to be triggered, and its action is taken. There can never be
        a backtrack onto (*COMMIT).
 
    Backtracking verbs in repeated groups
 
-       PCRE2  differs  from  Perl  in  its  handling  of backtracking verbs in
+       PCRE2 differs from Perl  in  its  handling  of  backtracking  verbs  in
        repeated groups. For example, consider:
 
          /(a(*COMMIT)b)+ac/
 
-       If the subject is "abac", Perl matches, but  PCRE2  fails  because  the
+       If  the  subject  is  "abac", Perl matches, but PCRE2 fails because the
        (*COMMIT) in the second repeat of the group acts.
 
    Backtracking verbs in assertions
 
-       (*FAIL)  in any assertion has its normal effect: it forces an immediate
-       backtrack. The behaviour of the other  backtracking  verbs  depends  on
-       whether  or  not the assertion is standalone or acting as the condition
+       (*FAIL) in any assertion has its normal effect: it forces an  immediate
+       backtrack.  The  behaviour  of  the other backtracking verbs depends on
+       whether or not the assertion is standalone or acting as  the  condition
        in a conditional subpattern.
 
-       (*ACCEPT) in a standalone positive assertion causes  the  assertion  to
-       succeed  without any further processing; captured strings are retained.
-       In a standalone negative assertion, (*ACCEPT) causes the  assertion  to
+       (*ACCEPT)  in  a  standalone positive assertion causes the assertion to
+       succeed without any further processing; captured strings are  retained.
+       In  a  standalone negative assertion, (*ACCEPT) causes the assertion to
        fail without any further processing; captured substrings are discarded.
 
-       If  the  assertion is a condition, (*ACCEPT) causes the condition to be
-       true for a positive assertion and false for a  negative  one;  captured
+       If the assertion is a condition, (*ACCEPT) causes the condition  to  be
+       true  for  a  positive assertion and false for a negative one; captured
        substrings are retained in both cases.
 
-       The  effect of (*THEN) is not allowed to escape beyond an assertion. If
-       there are no more branches to try, (*THEN) causes a positive  assertion
+       The effect of (*THEN) is not allowed to escape beyond an assertion.  If
+       there  are no more branches to try, (*THEN) causes a positive assertion
        to be false, and a negative assertion to be true.
 
-       The  other  backtracking verbs are not treated specially if they appear
-       in a standalone positive assertion. In a  conditional  positive  asser-
+       The other backtracking verbs are not treated specially if  they  appear
+       in  a  standalone  positive assertion. In a conditional positive asser-
        tion, backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes the con-
-       dition to be false. However, for both standalone and conditional  nega-
-       tive  assertions,  backtracking  into  (*COMMIT),  (*SKIP), or (*PRUNE)
+       dition  to be false. However, for both standalone and conditional nega-
+       tive assertions, backtracking  into  (*COMMIT),  (*SKIP),  or  (*PRUNE)
        causes the assertion to be true, without considering any further alter-
        native branches.
 
    Backtracking verbs in subroutines
 
-       These  behaviours  occur whether or not the subpattern is called recur-
+       These behaviours occur whether or not the subpattern is  called  recur-
        sively.  Perl's treatment of subroutines is different in some cases.
 
-       (*FAIL) in a subpattern called as a subroutine has its  normal  effect:
+       (*FAIL)  in  a subpattern called as a subroutine has its normal effect:
        it forces an immediate backtrack.
 
-       (*ACCEPT)  in a subpattern called as a subroutine causes the subroutine
-       match to succeed without any further processing. Matching then  contin-
+       (*ACCEPT) in a subpattern called as a subroutine causes the  subroutine
+       match  to succeed without any further processing. Matching then contin-
        ues after the subroutine call.
 
        (*COMMIT), (*SKIP), and (*PRUNE) in a subpattern called as a subroutine
        cause the subroutine match to fail.
 
-       (*THEN) skips to the next alternative in the innermost enclosing  group
-       within  the subpattern that has alternatives. If there is no such group
+       (*THEN)  skips to the next alternative in the innermost enclosing group
+       within the subpattern that has alternatives. If there is no such  group
        within the subpattern, (*THEN) causes the subroutine match to fail.
 
 
 SEE ALSO
 
-       pcre2api(3),   pcre2callout(3),    pcre2matching(3),    pcre2syntax(3),
+       pcre2api(3),    pcre2callout(3),    pcre2matching(3),   pcre2syntax(3),
        pcre2(3).
 
 
@@ -8686,7 +8687,7 @@ AUTHOR
 
 REVISION
 
-       Last updated: 26 May 2017
+       Last updated: 30 May 2017
        Copyright (c) 1997-2017 University of Cambridge.
 ------------------------------------------------------------------------------
  
diff --git a/doc/pcre2_dfa_match.3 b/doc/pcre2_dfa_match.3
index 17ed86e..32a22c8 100644
--- a/doc/pcre2_dfa_match.3
+++ b/doc/pcre2_dfa_match.3
@@ -1,4 +1,4 @@
-.TH PCRE2_DFA_MATCH 3 "04 April 2017" "PCRE2 10.30"
+.TH PCRE2_DFA_MATCH 3 "30 May 2017" "PCRE2 10.30"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .SH SYNOPSIS
@@ -34,8 +34,9 @@ just once (except when processing lookaround assertions). This function is
   \fIwscount\fP      Number of elements in the vector
 .sp
 For \fBpcre2_dfa_match()\fP, a match context is needed only if you want to set
-up a callout function or specify the recursion depth limit. The \fIlength\fP
-and \fIstartoffset\fP values are code units, not characters. The options are:
+up a callout function or specify the match and/or the recursion depth limits.
+The \fIlength\fP and \fIstartoffset\fP values are code units, not characters.
+The options are:
 .sp
   PCRE2_ANCHORED          Match only at the first position
   PCRE2_ENDANCHORED       Pattern can match only at end of subject
diff --git a/doc/pcre2api.3 b/doc/pcre2api.3
index 5fb703e..34c9f37 100644
--- a/doc/pcre2api.3
+++ b/doc/pcre2api.3
@@ -1,4 +1,4 @@
-.TH PCRE2API 3 "26 May 2017" "PCRE2 10.30"
+.TH PCRE2API 3 "30 May 2017" "PCRE2 10.30"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .sp
@@ -266,7 +266,7 @@ document for an overview of all the PCRE2 documentation.
 .B "  void (*\fIprivate_free\fP)(void *, void *), void *\fImemory_data\fP);"
 .fi
 .sp
-These functions became obsolete at release 10.30 and are retained only for 
+These functions became obsolete at release 10.30 and are retained only for
 backward compatibility. They should not be used in new code. The first is
 replaced by \fBpcre2_set_depth_limit()\fP; the second is no longer needed and
 has no effect (it always returns zero).
@@ -365,10 +365,10 @@ documentation, and the
 .\"
 documentation describes how to compile and run it.
 .P
-The compiling and matching functions recognize various options that are passed 
-as bits in an options argument. There are also some more complicated parameters 
-such as custom memory management functions and resource limits that are passed 
-in "contexts" (which are just memory blocks, described below). Simple 
+The compiling and matching functions recognize various options that are passed
+as bits in an options argument. There are also some more complicated parameters
+such as custom memory management functions and resource limits that are passed
+in "contexts" (which are just memory blocks, described below). Simple
 applications do not need to make use of contexts.
 .P
 Just-in-time (JIT) compiler support is an optional feature of PCRE2 that can be
@@ -384,7 +384,7 @@ More complicated programs might need to make use of the specialist functions
 .P
 JIT matching is automatically used by \fBpcre2_match()\fP if it is available,
 unless the PCRE2_NO_JIT option is set. There is also a direct interface for JIT
-matching, which gives improved performance at the expense of less sanity 
+matching, which gives improved performance at the expense of less sanity
 checking. The JIT-specific functions are discussed in the
 .\" HREF
 \fBpcre2jit\fP
@@ -646,7 +646,7 @@ following compile-time parameters:
   The newline character sequence
   The compile time nested parentheses limit
   The maximum length of the pattern string
-  The extra options bits (none set by default) 
+  The extra options bits (none set by default)
 .sp
 A compile context is also required if you are using custom memory management.
 If none of these apply, just pass NULL as the context argument of
@@ -695,9 +695,9 @@ in the current locale.
 .sp
 As PCRE2 has developed, almost all the 32 option bits that are available in
 the \fIoptions\fP argument of \fBpcre2_compile()\fP have been used up. To avoid
-running out, the compile context contains a set of extra option bits which are 
-used for some newer, assumed rarer, options. This function sets those bits. It 
-always sets all the bits (either on or off). It does not modify any existing 
+running out, the compile context contains a set of extra option bits which are
+used for some newer, assumed rarer, options. This function sets those bits. It
+always sets all the bits (either on or off). It does not modify any existing
 setting. The available options are defined in the section entitled "Extra
 compile options"
 .\" HTML <a href="#extracompileoptions">
@@ -724,8 +724,8 @@ PCRE2_SIZE variable can hold, which is effectively unlimited.
 This specifies which characters or character sequences are to be recognized as
 newlines. The value must be one of PCRE2_NEWLINE_CR (carriage return only),
 PCRE2_NEWLINE_LF (linefeed only), PCRE2_NEWLINE_CRLF (the two-character
-sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of the above), 
-PCRE2_NEWLINE_ANY (any Unicode newline sequence), or PCRE2_NEWLINE_NUL (the 
+sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of the above),
+PCRE2_NEWLINE_ANY (any Unicode newline sequence), or PCRE2_NEWLINE_NUL (the
 NUL character, that is a binary zero).
 .P
 A pattern can override the value set in the compile context by starting with a
@@ -778,7 +778,7 @@ A match context is required if you want to:
 .sp
   Set up a callout function
   Set an offset limit for matching an unanchored pattern
-  Change the limit on the amount of heap used when matching 
+  Change the limit on the amount of heap used when matching
   Change the backtracking match limit
   Change the backtracking depth limit
   Set custom memory management specifically for the match
@@ -846,7 +846,7 @@ In other words, whichever limit comes first is used.
 .B "  uint32_t \fIvalue\fP);"
 .fi
 .sp
-The \fIheap_limit\fP parameter specifies, in units of kilobytes, the maximum 
+The \fIheap_limit\fP parameter specifies, in units of kilobytes, the maximum
 amount of heap memory that \fBpcre2_match()\fP may use to hold backtracking
 information when running an interpretive match. This limit does not apply to
 matching with the JIT optimization, which has its own memory control
@@ -855,8 +855,8 @@ arrangements (see the
 \fBpcre2jit\fP
 .\"
 documentation for more details), nor does it apply to \fBpcre2_dfa_match()\fP.
-If the limit is reached, the negative error code PCRE2_ERROR_HEAPLIMIT is 
-returned. The default limit is set when PCRE2 is built; the default default is 
+If the limit is reached, the negative error code PCRE2_ERROR_HEAPLIMIT is
+returned. The default limit is set when PCRE2 is built; the default default is
 very large and is essentially "unlimited".
 .P
 A value for the heap limit may also be supplied by an item at the start of a
@@ -870,11 +870,11 @@ limit is set, less than the default.
 .P
 The \fBpcre2_match()\fP function starts out using a 20K vector on the system
 stack for recording backtracking points. The more nested backtracking points
-there are (that is, the deeper the search tree), the more memory is needed. 
-Heap memory is used only if the initial vector is too small. If the heap limit 
-is set to a value less than 21 (in particular, zero) no heap memory will be 
-used. In this case, only patterns that do not have a lot of nested backtracking 
-can be successfully processed. 
+there are (that is, the deeper the search tree), the more memory is needed.
+Heap memory is used only if the initial vector is too small. If the heap limit
+is set to a value less than 21 (in particular, zero) no heap memory will be
+used. In this case, only patterns that do not have a lot of nested backtracking
+can be successfully processed.
 .sp
 .nf
 .B int pcre2_set_match_limit(pcre2_match_context *\fImcontext\fP,
@@ -891,8 +891,8 @@ time round its main matching loop. If this value reaches the match limit,
 \fBpcre2_match()\fP returns the negative value PCRE2_ERROR_MATCHLIMIT. This has
 the effect of limiting the amount of backtracking that can take place. For
 patterns that are not anchored, the count restarts from zero for each position
-in the subject string. This limit is not relevant to \fBpcre2_dfa_match()\fP,
-which ignores it.
+in the subject string. This limit also applies to \fBpcre2_dfa_match()\fP,
+though the counting is done in a different way.
 .P
 When \fBpcre2_match()\fP is called with a pattern that was successfully
 processed by \fBpcre2_jit_compile()\fP, the way in which matching is executed
@@ -909,8 +909,8 @@ of the form
   (*LIMIT_MATCH=ddd)
 .sp
 where ddd is a decimal number. However, such a setting is ignored unless ddd is
-less than the limit set by the caller of \fBpcre2_match()\fP or, if no such
-limit is set, less than the default.
+less than the limit set by the caller of \fBpcre2_match()\fP or
+\fBpcre2_dfa_match()\fP or, if no such limit is set, less than the default.
 .sp
 .nf
 .B int pcre2_set_depth_limit(pcre2_match_context *\fImcontext\fP,
@@ -918,7 +918,7 @@ limit is set, less than the default.
 .fi
 .sp
 This parameter limits the depth of nested backtracking in \fBpcre2_match()\fP.
-Each time a nested backtracking point is passed, a new memory "frame" is used 
+Each time a nested backtracking point is passed, a new memory "frame" is used
 to remember the state of matching at that point. Thus, this parameter
 indirectly limits the amount of memory that is used in a match. However,
 because the size of each memory "frame" depends on the number of capturing
@@ -1040,7 +1040,7 @@ sequence that is recognized as meaning "newline". The values are:
   PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
   PCRE2_NEWLINE_ANY      Any Unicode line ending
   PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
-  PCRE2_NEWLINE_NUL      The NUL character (binary zero) 
+  PCRE2_NEWLINE_NUL      The NUL character (binary zero)
 .sp
 The default should normally correspond to the standard sequence for your
 operating system.
@@ -1270,7 +1270,7 @@ parenthesis. The name is not processed in any way, and it is not possible to
 include a closing parenthesis in the name. However, if the PCRE2_ALT_VERBNAMES
 option is set, normal backslash processing is applied to verb names and only an
 unescaped closing parenthesis terminates the name. A closing parenthesis can be
-included in a name either as \e) or between \eQ and \eE. If the PCRE2_EXTENDED 
+included in a name either as \e) or between \eQ and \eE. If the PCRE2_EXTENDED
 or PCRE2_EXTENDED_MORE option is set, unescaped whitespace in verb names is
 skipped and #-comments are recognized in this mode, exactly as in the rest of
 the pattern.
@@ -1290,12 +1290,12 @@ documentation.
 .sp
 If this bit is set, letters in the pattern match both upper and lower case
 letters in the subject. It is equivalent to Perl's /i option, and it can be
-changed within a pattern by a (?i) option setting. If PCRE2_UTF is set, Unicode 
+changed within a pattern by a (?i) option setting. If PCRE2_UTF is set, Unicode
 properties are used for all characters with more than one other case, and for
-all characters whose code points are greater than U+007f. For lower valued 
-characters with only one other case, a lookup table is used for speed. When 
-PCRE2_UTF is not set, a lookup table is used for all code points less than 256, 
-and higher code points (available only in 16-bit or 32-bit mode) are treated as 
+all characters whose code points are greater than U+007f. For lower valued
+characters with only one other case, a lookup table is used for speed. When
+PCRE2_UTF is not set, a lookup table is used for all code points less than 256,
+and higher code points (available only in 16-bit or 32-bit mode) are treated as
 not having another case.
 .sp
   PCRE2_DOLLAR_ENDONLY
@@ -1331,11 +1331,11 @@ documentation.
   PCRE2_ENDANCHORED
 .sp
 If this bit is set, the end of any pattern match must be right at the end of
-the string being searched (the "subject string"). If the pattern match 
-succeeds by reaching (*ACCEPT), but does not reach the end of the subject, the 
-match fails at the current starting point. For unanchored patterns, a new match 
-is then tried at the next starting point. However, if the match succeeds by 
-reaching the end of the pattern, but not the end of the subject, backtracking 
+the string being searched (the "subject string"). If the pattern match
+succeeds by reaching (*ACCEPT), but does not reach the end of the subject, the
+match fails at the current starting point. For unanchored patterns, a new match
+is then tried at the next starting point. However, if the match succeeds by
+reaching the end of the pattern, but not the end of the subject, backtracking
 occurs and an alternative match may be found. Consider these two patterns:
 .sp
   .(*ACCEPT)|..
@@ -1346,9 +1346,9 @@ whereas the second matches "bc". The effect of PCRE2_ENDANCHORED can also be
 achieved by appropriate constructs in the pattern itself, which is the only way
 to do it in Perl.
 .P
-For DFA matching with \fBpcre2_dfa_match()\fP, PCRE2_ENDANCHORED applies only 
+For DFA matching with \fBpcre2_dfa_match()\fP, PCRE2_ENDANCHORED applies only
 to the first (that is, the longest) matched string. Other parallel matches,
-which are necessarily substrings of the first one, must obviously end before 
+which are necessarily substrings of the first one, must obviously end before
 the end of the subject.
 .sp
   PCRE2_EXTENDED
@@ -1520,7 +1520,7 @@ current starting position, which in this case, it does. However, if the same
 match is run with PCRE2_NO_START_OPTIMIZE set, the initial scan along the
 subject string does not happen. The first match attempt is run starting from
 "D" and when this fails, (*COMMIT) prevents any further matches being tried, so
-the overall result is "no match". 
+the overall result is "no match".
 .P
 There are also other start-up optimizations. For example, a minimum length for
 the subject may be recorded. Consider the pattern
@@ -1556,12 +1556,12 @@ in the
 \fBpcre2unicode\fP
 .\"
 document. If an invalid UTF sequence is found, \fBpcre2_compile()\fP returns a
-negative error code. 
+negative error code.
 .P
 If you know that your pattern is a valid UTF string, and you want to skip this
 check for performance reasons, you can set the PCRE2_NO_UTF_CHECK option. When
 it is set, the effect of passing an invalid UTF string as a pattern is
-undefined. It may cause your program to crash or loop. 
+undefined. It may cause your program to crash or loop.
 .P
 Note that this option can also be passed to \fBpcre2_match()\fP and
 \fBpcre_dfa_match()\fP, to suppress UTF validity checking of the subject
@@ -1575,7 +1575,7 @@ such as \ex{d800} you can set the PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES extra
 option, as described in the section entitled "Extra compile options"
 .\" HTML <a href="#extracompileoptions">
 .\" </a>
-below. 
+below.
 .\"
 However, this is possible only in UTF-8 and UTF-32 modes, because these values
 are not representable in UTF-16.
@@ -1642,13 +1642,13 @@ calling the \fBpcre2_set_compile_extra_options()\fP function are as follows:
 .sp
   PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES
 .sp
-This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is 
+This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is
 forbidden in UTF-16 mode, and ignored in non-UTF modes. Unicode "surrogate"
 code points in the range 0xd800 to 0xdfff are used in pairs in UTF-16 to encode
-code points with values in the range 0x10000 to 0x10ffff. The surrogates cannot 
+code points with values in the range 0x10000 to 0x10ffff. The surrogates cannot
 therefore be represented in UTF-16. They can be represented in UTF-8 and
-UTF-32, but are defined as invalid code points, and cause errors if encountered 
-in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2. 
+UTF-32, but are defined as invalid code points, and cause errors if encountered
+in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2.
 .P
 These values also cause errors if encountered in escape sequences such as
 \ex{d912} within a pattern. However, it seems that some applications, when
@@ -1657,9 +1657,9 @@ for the surrogates using escape sequences. The PCRE2_NO_UTF_CHECK option does
 not disable the error that occurs, because it applies only to the testing of
 input strings for UTF validity.
 .P
-If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is set, surrogate code 
-point values in UTF-8 and UTF-32 patterns no longer provoke errors and are 
-incorporated in the compiled pattern. However, they can only match subject 
+If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is set, surrogate code
+point values in UTF-8 and UTF-32 patterns no longer provoke errors and are
+incorporated in the compiled pattern. However, they can only match subject
 characters if the matching function is called with PCRE2_NO_UTF_CHECK set.
 .
 .
@@ -1881,7 +1881,7 @@ The third argument should point to an \fBuint32_t\fP variable.
 If the pattern set a backtracking depth limit by including an item of the form
 (*LIMIT_DEPTH=nnnn) at the start, the value is returned. The third argument
 should point to an unsigned 32-bit integer. If no such value has been set, the
-call to \fBpcre2_pattern_info()\fP returns the error PCRE2_ERROR_UNSET. Note 
+call to \fBpcre2_pattern_info()\fP returns the error PCRE2_ERROR_UNSET. Note
 that this limit will only be used during matching if it is less than the limit
 set or defaulted by the caller of the match function.
 .sp
@@ -2092,7 +2092,7 @@ The output is one of the following \fBuint32_t\fP values:
   PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
   PCRE2_NEWLINE_ANY      Any Unicode line ending
   PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
-  PCRE2_NEWLINE_NUL      The NUL character (binary zero) 
+  PCRE2_NEWLINE_NUL      The NUL character (binary zero)
 .sp
 This identifies the character sequence that will be recognized as meaning
 "newline" while matching.
@@ -2319,8 +2319,8 @@ instead of one.
 .P
 If a non-zero starting offset is passed when the pattern is anchored, a single
 attempt to match at the given offset is made. This can only succeed if the
-pattern does not require the match to be at the start of the subject. In other 
-words, the anchoring must be the result of setting the PCRE2_ANCHORED option or 
+pattern does not require the match to be at the start of the subject. In other
+words, the anchoring must be the result of setting the PCRE2_ANCHORED option or
 the use of .* with PCRE2_DOTALL, not by starting the pattern with ^ or \eA.
 .
 .
@@ -2509,7 +2509,7 @@ start, it skips both the CR and the LF before retrying. However, the pattern
 reference, and so advances only by one character after the first failure.
 .P
 An explicit match for CR of LF is either a literal appearance of one of those
-characters in the pattern, or one of the \er or \en or equivalent octal or 
+characters in the pattern, or one of the \er or \en or equivalent octal or
 hexadecimal escape sequences. Implicit matches such as [^X] do not count, nor
 does \es, even though it includes CR and LF in the characters that it matches.
 .P
@@ -2769,9 +2769,9 @@ The backtracking match limit was reached.
 .sp
   PCRE2_ERROR_NOMEMORY
 .sp
-If a pattern contains many nested backtracking points, heap memory is used to 
-remember them. This error is given when the memory allocation function (default 
-or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given 
+If a pattern contains many nested backtracking points, heap memory is used to
+remember them. This error is given when the memory allocation function (default
+or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
 if the amount of memory needed exceeds the heap limit.
 .sp
   PCRE2_ERROR_NULL
@@ -3491,6 +3491,6 @@ Cambridge, England.
 .rs
 .sp
 .nf
-Last updated: 26 May 2017
+Last updated: 30 May 2017
 Copyright (c) 1997-2017 University of Cambridge.
 .fi
diff --git a/doc/pcre2build.3 b/doc/pcre2build.3
index 7537cbb..bbf5466 100644
--- a/doc/pcre2build.3
+++ b/doc/pcre2build.3
@@ -1,4 +1,4 @@
-.TH PCRE2BUILD 3 "10 April 2017" "PCRE2 10.30"
+.TH PCRE2BUILD 3 "30 May 2017" "PCRE2 10.30"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .
@@ -256,9 +256,9 @@ setting such as
 .sp
   --with-match-limit=500000
 .sp
-to the \fBconfigure\fP command. This setting has no effect on the
-\fBpcre2_dfa_match()\fP matching function, but it does also limit JIT matching 
-(though the counting is done differently).
+to the \fBconfigure\fP command. This setting also applies to the
+\fBpcre2_dfa_match()\fP matching function, and to JIT matching (though the
+counting is done differently).
 .P
 The \fBpcre2_match()\fP function starts out using a 20K vector on the system
 stack to record backtracking points. The more nested backtracking points there
@@ -572,6 +572,6 @@ Cambridge, England.
 .rs
 .sp
 .nf
-Last updated: 10 April 2017
+Last updated: 30 May 2017
 Copyright (c) 1997-2017 University of Cambridge.
 .fi
diff --git a/doc/pcre2pattern.3 b/doc/pcre2pattern.3
index 81374c4..bafe1cd 100644
--- a/doc/pcre2pattern.3
+++ b/doc/pcre2pattern.3
@@ -1,4 +1,4 @@
-.TH PCRE2PATTERN 3 "26 May 2017" "PCRE2 10.30"
+.TH PCRE2PATTERN 3 "30 May 2017" "PCRE2 10.30"
 .SH NAME
 PCRE2 - Perl-compatible regular expressions (revised API)
 .SH "PCRE2 REGULAR EXPRESSION DETAILS"
@@ -169,11 +169,11 @@ still recognized for backwards compatibility.
 .P
 The heap limit applies only when the \fBpcre2_match()\fP interpreter is used
 for matching. It does not apply to JIT or DFA matching. The match limit is used
-(but in a different way) when JIT is being used, but it is not relevant, and is
-ignored, when matching with \fBpcre2_dfa_match()\fP. The depth limit is ignored 
-by JIT but is relevant for DFA matching, which uses function recursion for
-recursions within the pattern. In this case, the depth limit controls the
-amount of system stack that is used.
+(but in a different way) when JIT is being used, or when
+\fBpcre2_dfa_match()\fP is called, to limit computing resource usage by those
+matching functions. The depth limit is ignored by JIT but is relevant for DFA
+matching, which uses function recursion for recursions within the pattern. In
+this case, the depth limit controls the amount of system stack that is used.
 .
 .
 .\" HTML <a name="newlines"></a>
@@ -3475,6 +3475,6 @@ Cambridge, England.
 .rs
 .sp
 .nf
-Last updated: 26 May 2017
+Last updated: 30 May 2017
 Copyright (c) 1997-2017 University of Cambridge.
 .fi
diff --git a/src/pcre2_dfa_match.c b/src/pcre2_dfa_match.c
index f9acba3..518eb83 100644
--- a/src/pcre2_dfa_match.c
+++ b/src/pcre2_dfa_match.c
@@ -396,6 +396,7 @@ BOOL utf = FALSE;
 
 BOOL reset_could_continue = FALSE;
 
+if (mb->match_call_count++ >= mb->match_limit) return PCRE2_ERROR_MATCHLIMIT;
 if (rlevel++ > mb->match_limit_depth) return PCRE2_ERROR_DEPTHLIMIT;
 offsetcount &= (uint32_t)(-2);  /* Round down */
 
@@ -3218,6 +3219,7 @@ if (mcontext == NULL)
   {
   mb->callout = NULL;
   mb->memctl = re->memctl;
+  mb->match_limit = PRIV(default_match_context).match_limit;
   mb->match_limit_depth = PRIV(default_match_context).depth_limit;
   }
 else
@@ -3231,8 +3233,13 @@ else
   mb->callout = mcontext->callout;
   mb->callout_data = mcontext->callout_data;
   mb->memctl = mcontext->memctl;
+  mb->match_limit = mcontext->match_limit;
   mb->match_limit_depth = mcontext->depth_limit;
   }
+
+if (mb->match_limit > re->limit_match)
+  mb->match_limit = re->limit_match;
+
 if (mb->match_limit_depth > re->limit_depth)
   mb->match_limit_depth = re->limit_depth;
 
@@ -3244,6 +3251,7 @@ mb->end_subject = end_subject;
 mb->start_offset = start_offset;
 mb->moptions = options;
 mb->poptions = re->overall_options;
+mb->match_call_count = 0;
 
 /* Process the \R and newline settings. */
 
diff --git a/src/pcre2_fuzzsupport.c b/src/pcre2_fuzzsupport.c
index 7e0d550..48781ff 100644
--- a/src/pcre2_fuzzsupport.c
+++ b/src/pcre2_fuzzsupport.c
@@ -178,20 +178,20 @@ for (i = 0; i < 2; i++)
         return 0;
         }
       (void)pcre2_set_match_limit(match_context, 100);
+      (void)pcre2_set_depth_limit(match_context, 100);
       (void)pcre2_set_callout(match_context, callout_function, &callout_count);
       }
 
-    /* Match twice, with and without options, with a depth limit of 100. */
-
-    (void)pcre2_set_depth_limit(match_context, 100);
+    /* Match twice, with and without options. */
 
     for (j = 0; j < 2; j++)
       {
 #ifdef STANDALONE
       printf("Match options %.8x", match_options);
-      printf("%s%s%s%s%s%s%s%s%s\n",
+      printf("%s%s%s%s%s%s%s%s%s%s\n",
         ((match_options & PCRE2_ANCHORED) != 0)? ",anchored" : "",
         ((match_options & PCRE2_ENDANCHORED) != 0)? ",endanchored" : "",
+        ((match_options & PCRE2_NO_JIT) != 0)? ",no_jit" : "",
         ((match_options & PCRE2_NO_UTF_CHECK) != 0)? ",no_utf_check" : "",
         ((match_options & PCRE2_NOTBOL) != 0)? ",notbol" : "",
         ((match_options & PCRE2_NOTEMPTY) != 0)? ",notempty" : "",
@@ -217,9 +217,8 @@ for (i = 0; i < 2; i++)
       match_options = 0;  /* For second time */
       }
 
-    /* Match with DFA twice, with and without options, depth limit of 10. */
+    /* Match with DFA twice, with and without options. */
 
-    (void)pcre2_set_depth_limit(match_context, 10);
     match_options = save_match_options & ~PCRE2_NO_JIT;  /* Not valid for DFA */
 
     for (j = 0; j < 2; j++)
diff --git a/src/pcre2_intmodedep.h b/src/pcre2_intmodedep.h
index c5af7df..387f65e 100644
--- a/src/pcre2_intmodedep.h
+++ b/src/pcre2_intmodedep.h
@@ -877,7 +877,9 @@ typedef struct dfa_match_block {
   PCRE2_SPTR last_used_ptr;       /* Latest consulted character */
   const uint8_t *tables;          /* Character tables */
   PCRE2_SIZE start_offset;        /* The start offset value */
+  uint32_t match_limit;           /* As it says */
   uint32_t match_limit_depth;     /* As it says */
+  uint32_t match_call_count;      /* Number of calls of internal function */
   uint32_t moptions;              /* Match options */
   uint32_t poptions;              /* Pattern options */
   uint32_t nltype;                /* Newline type */
diff --git a/src/pcre2test.c b/src/pcre2test.c
index 737471d..08d3669 100644
--- a/src/pcre2test.c
+++ b/src/pcre2test.c
@@ -7054,17 +7054,15 @@ else for (gmatched = 0;; gmatched++)
     {
     capcount = 0;  /* This stops compiler warnings */
 
-    if ((dat_datctl.control & CTL_DFA) == 0)
-      {
-      if (FLD(compiled_code, executable_jit) == NULL ||
-          (dat_datctl.options & PCRE2_NO_JIT) != 0)
-        {
-        (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT,
-          "heap");
-        }
-      capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,
-        "match");
-      }
+    if ((dat_datctl.control & CTL_DFA) == 0 &&
+        (FLD(compiled_code, executable_jit) == NULL ||
+          (dat_datctl.options & PCRE2_NO_JIT) != 0))
+      {     
+      (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, "heap");
+      } 
+       
+    capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,
+      "match");
 
     if (FLD(compiled_code, executable_jit) == NULL ||
         (dat_datctl.options & PCRE2_NO_JIT) != 0 ||
diff --git a/testdata/testinput6 b/testdata/testinput6
index df38249..14bdaed 100644
--- a/testdata/testinput6
+++ b/testdata/testinput6
@@ -4941,4 +4941,7 @@
 /(?<=|abc)/endanchored
     abcde\=aftertext
 
+/(*LIMIT_MATCH=100).*(?![|H]?.*(?![|H]?););.*(?![|H]?.*(?![|H]?););\x00\x00\x00\x00\x00\x00\x00(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?![|);)?.*(![|H]?);)?.*(?![|H]?);)?.*(?![|H]?);)?.*(?![|H]););![|H]?););[|H]?);|H]?);)\x00\x00\x00\x00\x00\x00H]?););?![|H]?);)?.*(?![|H]?););[||H]?);)?.*(?![|H]?););[|H]?);(?![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););;[\x00\x00\x00\x00\x00\x00\x00![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););/no_dotstar_anchor
+.*(?![|H]?.*(?![|H]?););.*(?![|H]?.*(?![|H]?););\x00\x00\x00\x00\x00\x00\x00(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?![|);)?.*(![|H]?);)?.*(?![|H]?);)?.*(?![|H]?);)?.*(?![|H]););![|H]?););[|H]?);|H]?);)\x00\x00\x00\x00\x00\x00H]?););?![|H]?);)?.*(?![|H]?););[||H]?);)?.*(?![|H]?););[|H]?);(?![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););;[\x00\x00\x00\x00\x00\x00\x00![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););
+
 # End of testinput6
diff --git a/testdata/testoutput6 b/testdata/testoutput6
index f029123..a703ad3 100644
--- a/testdata/testoutput6
+++ b/testdata/testoutput6
@@ -7691,6 +7691,7 @@ Failed: error -53: matching depth limit exceeded
 
 /^(a(?2))(b)(?1)/
     abbab\=find_limits 
+Minimum match limit = 4
 Minimum depth limit = 2
  0: abbab
 
@@ -7766,4 +7767,8 @@ No match
  0: 
  0+ 
 
+/(*LIMIT_MATCH=100).*(?![|H]?.*(?![|H]?););.*(?![|H]?.*(?![|H]?););\x00\x00\x00\x00\x00\x00\x00(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?![|);)?.*(![|H]?);)?.*(?![|H]?);)?.*(?![|H]?);)?.*(?![|H]););![|H]?););[|H]?);|H]?);)\x00\x00\x00\x00\x00\x00H]?););?![|H]?);)?.*(?![|H]?););[||H]?);)?.*(?![|H]?););[|H]?);(?![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););;[\x00\x00\x00\x00\x00\x00\x00![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););/no_dotstar_anchor
+.*(?![|H]?.*(?![|H]?););.*(?![|H]?.*(?![|H]?););\x00\x00\x00\x00\x00\x00\x00(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?!(?![|);)?.*(![|H]?);)?.*(?![|H]?);)?.*(?![|H]?);)?.*(?![|H]););![|H]?););[|H]?);|H]?);)\x00\x00\x00\x00\x00\x00H]?););?![|H]?);)?.*(?![|H]?););[||H]?);)?.*(?![|H]?););[|H]?);(?![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););;[\x00\x00\x00\x00\x00\x00\x00![|H]?););![|H]?););[|H]?);|H]?);)?.*(?![|H]?););
+Failed: error -47: match limit exceeded
+
 # End of testinput6
