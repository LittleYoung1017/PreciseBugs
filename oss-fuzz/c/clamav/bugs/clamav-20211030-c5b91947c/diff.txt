diff --git a/libclamav/mbox.c b/libclamav/mbox.c
index 8d4abe7bf..a56ecabb0 100644
--- a/libclamav/mbox.c
+++ b/libclamav/mbox.c
@@ -38,6 +38,7 @@
 #include <errno.h>
 #include <assert.h>
 #include <string.h>
+#include <stdbool.h>
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
 #endif
@@ -115,21 +116,6 @@ static void print_trace(int use_syslog);
 #define strtok_r(a, b, c) strtok(a, b)
 #endif
 
-#ifdef HAVE_STDBOOL_H
-#ifdef C_BEOS
-#include "SupportDefs.h"
-#else
-#include <stdbool.h>
-#endif
-#else
-#ifdef FALSE
-typedef unsigned char bool;
-#else
-typedef enum { FALSE = 0,
-               TRUE  = 1 } bool;
-#endif
-#endif
-
 typedef enum {
     FAIL,
     OK,
@@ -375,21 +361,18 @@ cli_parse_mbox(const char *dir, cli_ctx *ctx)
         /* empty message */
         return CL_CLEAN;
     }
+
 #ifdef CL_THREAD_SAFE
     pthread_mutex_lock(&tables_mutex);
 #endif
-    if (rfc821 == NULL) {
-        assert(subtype == NULL);
 
-        if (initialiseTables(&rfc821, &subtype) < 0) {
-            rfc821  = NULL;
-            subtype = NULL;
+    if (initialiseTables(&rfc821, &subtype) < 0) {
 #ifdef CL_THREAD_SAFE
-            pthread_mutex_unlock(&tables_mutex);
+        pthread_mutex_unlock(&tables_mutex);
 #endif
-            return CL_EMEM;
-        }
+        return CL_EMEM;
     }
+
 #ifdef CL_THREAD_SAFE
     pthread_mutex_unlock(&tables_mutex);
 #endif
@@ -442,7 +425,7 @@ cli_parse_mbox(const char *dir, cli_ctx *ctx)
         if (m == NULL)
             return CL_EMEM;
 
-        lastLineWasEmpty = FALSE;
+        lastLineWasEmpty = false;
         messagenumber    = 1;
         messageSetCTX(m, ctx);
 
@@ -454,7 +437,7 @@ cli_parse_mbox(const char *dir, cli_ctx *ctx)
                 /*
                  * End of a message in the mail box
                  */
-                bool heuristicFound = FALSE;
+                bool heuristicFound = false;
                 body                = parseEmailHeaders(m, rfc821, &heuristicFound);
                 if (body == NULL) {
                     messageReset(m);
@@ -514,7 +497,7 @@ cli_parse_mbox(const char *dir, cli_ctx *ctx)
 
         if (retcode == CL_SUCCESS) {
             cli_dbgmsg("Extract attachments from email %d\n", messagenumber);
-            bool heuristicFound = FALSE;
+            bool heuristicFound = false;
             body                = parseEmailHeaders(m, rfc821, &heuristicFound);
             if (heuristicFound) {
                 retcode = CL_VIRUS;
@@ -545,7 +528,7 @@ cli_parse_mbox(const char *dir, cli_ctx *ctx)
 
         buffer[sizeof(buffer) - 1] = '\0';
 
-        bool heuristicFound = FALSE;
+        bool heuristicFound = false;
         body                = parseEmailFile(map, &at, rfc821, buffer, dir, ctx, &heuristicFound);
         if (heuristicFound) {
             retcode = CL_VIRUS;
@@ -625,7 +608,7 @@ static ReadStruct *
 appendReadStruct(ReadStruct *rs, const char *const buffer)
 {
     if (NULL == rs) {
-        assert(rs && "Invalid argument");
+        cli_dbgmsg("appendReadStruct: Invalid argument\n");
         goto done;
     }
 
@@ -729,14 +712,14 @@ doContinueMultipleEmptyOptions(const char *const line, bool *lastWasOnlySemi)
 
         if (1 == doCont) {
             if (*lastWasOnlySemi) {
-                return TRUE;
+                return true;
             }
-            *lastWasOnlySemi = TRUE;
+            *lastWasOnlySemi = true;
         } else {
-            *lastWasOnlySemi = FALSE;
+            *lastWasOnlySemi = false;
         }
     }
-    return FALSE;
+    return false;
 }
 
 static bool
@@ -753,13 +736,13 @@ hitLineFoldCnt(const char *const line, size_t *lineFoldCnt, cli_ctx *ctx, bool *
         if ((*lineFoldCnt) >= HEURISTIC_EMAIL_MAX_LINE_FOLDS_PER_HEADER) {
             if (SCAN_HEURISTIC_EXCEEDS_MAX) {
                 cli_append_virus(ctx, "Heuristics.Limits.Exceeded.EmailLineFoldCnt");
-                *heuristicFound = TRUE;
+                *heuristicFound = true;
             }
 
-            return TRUE;
+            return true;
         }
     }
-    return FALSE;
+    return false;
 }
 
 static bool
@@ -769,12 +752,12 @@ haveTooManyHeaderBytes(size_t totalLen, cli_ctx *ctx, bool *heuristicFound)
     if (totalLen > HEURISTIC_EMAIL_MAX_HEADER_BYTES) {
         if (SCAN_HEURISTIC_EXCEEDS_MAX) {
             cli_append_virus(ctx, "Heuristics.Limits.Exceeded.EmailHeaderBytes");
-            *heuristicFound = TRUE;
+            *heuristicFound = true;
         }
 
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static bool
@@ -784,12 +767,12 @@ haveTooManyEmailHeaders(size_t totalHeaderCnt, cli_ctx *ctx, bool *heuristicFoun
     if (totalHeaderCnt > HEURISTIC_EMAIL_MAX_HEADERS) {
         if (SCAN_HEURISTIC_EXCEEDS_MAX) {
             cli_append_virus(ctx, "Heuristics.Limits.Exceeded.EmailHeaders");
-            *heuristicFound = TRUE;
+            *heuristicFound = true;
         }
 
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static bool
@@ -802,9 +785,9 @@ haveTooManyMIMEPartsPerMessage(size_t mimePartCnt, cli_ctx *ctx, mbox_status *rc
             *rc = VIRUS;
         }
 
-        return TRUE;
+        return true;
     }
-    return FALSE;
+    return false;
 }
 
 static bool
@@ -814,13 +797,13 @@ haveTooManyMIMEArguments(size_t argCnt, cli_ctx *ctx, bool *heuristicFound)
     if (argCnt >= HEURISTIC_EMAIL_MAX_ARGUMENTS_PER_HEADER) {
         if (SCAN_HEURISTIC_EXCEEDS_MAX) {
             cli_append_virus(ctx, "Heuristics.Limits.Exceeded.EmailMIMEArguments");
-            *heuristicFound = TRUE;
+            *heuristicFound = true;
         }
 
-        return TRUE;
+        return true;
     }
 
-    return FALSE;
+    return false;
 }
 
 /*
@@ -832,22 +815,22 @@ haveTooManyMIMEArguments(size_t argCnt, cli_ctx *ctx, bool *heuristicFound)
 static message *
 parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *firstLine, const char *dir, cli_ctx *ctx, bool *heuristicFound)
 {
-    bool inHeader     = TRUE;
-    bool bodyIsEmpty  = TRUE;
-    bool lastWasBlank = FALSE, lastBodyLineWasBlank = FALSE;
+    bool inHeader     = true;
+    bool bodyIsEmpty  = true;
+    bool lastWasBlank = false, lastBodyLineWasBlank = false;
     message *ret;
-    bool anyHeadersFound = FALSE;
+    bool anyHeadersFound = false;
     int commandNumber    = -1;
     char *boundary       = NULL;
     char buffer[RFC2821LENGTH + 1];
-    bool lastWasOnlySemi    = FALSE;
+    bool lastWasOnlySemi    = false;
     int err                 = 1;
     size_t totalHeaderBytes = 0;
     size_t totalHeaderCnt   = 0;
 
     size_t lineFoldCnt = 0;
 
-    *heuristicFound = FALSE;
+    *heuristicFound = false;
 
     ReadStruct *head = NULL;
     ReadStruct *curr = NULL;
@@ -884,10 +867,10 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
          * otherwise they'll be treated as the end of header marker
          */
         if (lastWasBlank) {
-            lastWasBlank = FALSE;
+            lastWasBlank = false;
             if (boundaryStart(buffer, boundary)) {
                 cli_dbgmsg("Found a header line with space that should be blank\n");
-                inHeader = FALSE;
+                inHeader = false;
             }
         }
         if (inHeader) {
@@ -942,7 +925,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
 
                     if (boundary ||
                         ((boundary = (char *)messageFindArgument(ret, "boundary")) != NULL)) {
-                        lastWasBlank = TRUE;
+                        lastWasBlank = true;
                         continue;
                     }
                 }
@@ -957,12 +940,12 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                     continue;
 
                 cli_dbgmsg("End of header information\n");
-                inHeader    = FALSE;
-                bodyIsEmpty = TRUE;
+                inHeader    = false;
+                bodyIsEmpty = true;
             } else {
                 char *ptr;
                 const char *lookahead;
-                bool lineAdded = TRUE;
+                bool lineAdded = true;
 
                 if (0 == head->bufferLen) {
                     char cmd[RFC2821LENGTH + 1], out[RFC2821LENGTH + 1];
@@ -979,7 +962,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                     if ((strchr(line, ':') == NULL) ||
                         (cli_strtokbuf(line, 0, ":", cmd) == NULL)) {
                         if (strncmp(line, "From ", 5) == 0)
-                            anyHeadersFound = TRUE;
+                            anyHeadersFound = true;
                         continue;
                     }
 
@@ -990,7 +973,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                         case CONTENT_TRANSFER_ENCODING:
                         case CONTENT_DISPOSITION:
                         case CONTENT_TYPE:
-                            anyHeadersFound = TRUE;
+                            anyHeadersFound = true;
                             break;
                         default:
                             if (!anyHeadersFound)
@@ -1000,14 +983,14 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                     curr = appendReadStruct(curr, line);
                     if (NULL == curr) {
                         if (ret) {
-                            ret->isTruncated = TRUE;
+                            ret->isTruncated = true;
                         }
                         break;
                     }
                 } else if (line != NULL) {
                     curr = appendReadStruct(curr, line);
                 } else {
-                    lineAdded = FALSE;
+                    lineAdded = false;
                 }
 
                 if (lineAdded) {
@@ -1069,7 +1052,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
              * Fast track visa to uudecode.
              * TODO: binhex, yenc
              */
-            bodyIsEmpty = FALSE;
+            bodyIsEmpty = false;
             if (uudecodeFile(ret, line, dir, map, at) < 0)
                 if (messageAddStr(ret, line) < 0)
                     break;
@@ -1085,7 +1068,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                     cli_dbgmsg("Ignoring consecutive blank lines in the body\n");
                     continue;
                 }
-                lastBodyLineWasBlank = TRUE;
+                lastBodyLineWasBlank = true;
             } else {
                 if (bodyIsEmpty) {
                     /*
@@ -1096,9 +1079,9 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
                      */
                     if (newline_in_header(line))
                         continue;
-                    bodyIsEmpty = FALSE;
+                    bodyIsEmpty = false;
                 }
-                lastBodyLineWasBlank = FALSE;
+                lastBodyLineWasBlank = false;
             }
 
             if (messageAddStr(ret, line) < 0)
@@ -1110,7 +1093,7 @@ parseEmailFile(fmap_t *map, size_t *at, const table_t *rfc821, const char *first
 done:
     if (err) {
         cli_errmsg("parseEmailFile: ERROR parsing file\n");
-        ret->isTruncated = TRUE;
+        ret->isTruncated = true;
     }
 
     FREE(boundary);
@@ -1148,21 +1131,21 @@ done:
 static message *
 parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
 {
-    bool inHeader    = TRUE;
-    bool bodyIsEmpty = TRUE;
+    bool inHeader    = true;
+    bool bodyIsEmpty = true;
     text *t;
     message *ret;
-    bool anyHeadersFound  = FALSE;
+    bool anyHeadersFound  = false;
     int commandNumber     = -1;
     char *fullline        = NULL;
     size_t fulllinelength = 0;
-    bool lastWasOnlySemi  = FALSE;
+    bool lastWasOnlySemi  = false;
     size_t lineFoldCnt    = 0;
     size_t totalHeaderCnt = 0;
 
     cli_dbgmsg("parseEmailHeaders\n");
 
-    *heuristicFound = FALSE;
+    *heuristicFound = false;
 
     if (m == NULL)
         return NULL;
@@ -1198,11 +1181,11 @@ parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
                     cli_dbgmsg("Nothing interesting in the header\n");
                     break;
                 }
-                inHeader    = FALSE;
-                bodyIsEmpty = TRUE;
+                inHeader    = false;
+                bodyIsEmpty = true;
             } else {
                 char *ptr;
-                bool lineAdded = TRUE;
+                bool lineAdded = true;
 
                 if (fullline == NULL) {
                     char cmd[RFC2821LENGTH + 1];
@@ -1219,7 +1202,7 @@ parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
                     if ((strchr(line, ':') == NULL) ||
                         (cli_strtokbuf(line, 0, ":", cmd) == NULL)) {
                         if (strncmp(line, "From ", 5) == 0)
-                            anyHeadersFound = TRUE;
+                            anyHeadersFound = true;
                         continue;
                     }
 
@@ -1232,7 +1215,7 @@ parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
                         case CONTENT_TRANSFER_ENCODING:
                         case CONTENT_DISPOSITION:
                         case CONTENT_TYPE:
-                            anyHeadersFound = TRUE;
+                            anyHeadersFound = true;
                             break;
                         default:
                             if (!anyHeadersFound)
@@ -1249,9 +1232,9 @@ parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
                     fullline = ptr;
                     cli_strlcat(fullline, line, fulllinelength);
                 } else {
-                    lineAdded = FALSE;
+                    lineAdded = false;
                 }
-                assert(fullline != NULL);
+
                 /*continue doesn't seem right here, but that is what is done everywhere else when a malloc fails.*/
                 if (NULL == fullline) {
                     continue;
@@ -1306,7 +1289,7 @@ parseEmailHeaders(message *m, const table_t *rfc821, bool *heuristicFound)
                  */
                 if (newline_in_header(line))
                     continue;
-                bodyIsEmpty = FALSE;
+                bodyIsEmpty = false;
             }
             /*if(t->t_line && isuuencodebegin(t->t_line))
                 puts("FIXME: add fast visa here");*/
@@ -1648,13 +1631,13 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
     text *aText          = textIn;
     message *mainMessage = messageIn;
     fileblob *fb;
-    bool infected                  = FALSE;
+    bool infected                  = false;
     const struct cl_engine *engine = mctx->ctx->engine;
     const int doPhishingScan       = engine->dboptions & CL_DB_PHISHING_URLS && (DCONF_PHISHING & PHISHING_CONF_ENGINE);
 #if HAVE_JSON
     json_object *saveobj = mctx->wrkobj;
 #endif
-    bool heuristicFound = FALSE;
+    bool heuristicFound = false;
 
     cli_dbgmsg("in parseEmailBody, %u files saved so far\n",
                mctx->files);
@@ -1704,7 +1687,13 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
             cli_jsonstr(mctx->wrkobj, "MimeSubtype", mimeSubtype);
             cli_jsonstr(mctx->wrkobj, "EncodingType", getEncTypeStr(messageGetEncoding(mainMessage)));
             cli_jsonstr(mctx->wrkobj, "Disposition", messageGetDispositionType(mainMessage));
-            cli_jsonstr(mctx->wrkobj, "Filename", messageHasFilename(mainMessage) ? messageGetFilename(mainMessage) : "(inline)");
+            if (messageHasFilename(mainMessage)) {
+                char *filename = messageGetFilename(mainMessage);
+                cli_jsonstr(mctx->wrkobj, "Filename", filename);
+                free(filename);
+            } else {
+                cli_jsonstr(mctx->wrkobj, "Filename", "(inline)");
+            }
         }
 #endif
 
@@ -1759,7 +1748,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                      * html too, so scan them for phishing
                      */
                     if (rc == VIRUS)
-                        infected = TRUE;
+                        infected = true;
                 }
                 break;
             case MULTIPART:
@@ -1817,7 +1806,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                             if (exportBinhexMessage(mctx, mainMessage)) {
                                 /* virus found */
                                 rc       = VIRUS;
-                                infected = TRUE;
+                                infected = true;
                                 break;
                             }
                         } else if (t_line->t_next &&
@@ -1968,7 +1957,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                                 inhead = inMimeHead = 0;
                                 continue;
                             }
-                            inMimeHead = FALSE;
+                            inMimeHead = false;
                             messageAddArgument(aMessage, line);
                         } else if (inhead) { /* handling normal headers */
                             /*int quotes;*/
@@ -2051,9 +2040,17 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                                 continue;
                             }
 
-                            inMimeHead = FALSE;
+                            inMimeHead = false;
 
-                            assert(strlen(line) <= RFC2821LENGTH);
+                            if (strlen(line) > RFC2821LENGTH) {
+                                cli_dbgmsg("parseEmailBody: line length exceds RFC2821 maximum length (1000)\n");
+                                // We must skip this line because functions like rfc822comments() may accept output buffers
+                                // that [RFC2821LENGTH + 1] in and don't have any length checks to prevent exceeding that max.
+                                // E.g. See `boundaryStart()`.
+                                // TODO: A larger audit would be needed to remove this limitation, though frankly I recommend
+                                // fully re-writing the email parser (in Rust).
+                                continue;
+                            }
 
                             fullline = rfc822comments(line, NULL);
                             if (fullline == NULL)
@@ -2085,7 +2082,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                                      */
                                     cli_dbgmsg("Multipart %d: headers not terminated by blank line\n",
                                                multiparts);
-                                    inhead = FALSE;
+                                    inhead = false;
                                     break;
                                 }
 
@@ -2160,7 +2157,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                             }
                             --multiparts;
                             if (rc == VIRUS)
-                                infected = TRUE;
+                                infected = true;
                             break;
 
                         case RELATED:
@@ -2271,8 +2268,8 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                          * Have a look to see if there's HTML code
                          * which will need scanning
                          */
-                        aMessage = NULL;
-                        assert(multiparts > 0);
+
+                        // It's okay if multiparts == 0
 
                         htmltextPart = getTextPart(messages, multiparts);
 
@@ -2289,7 +2286,6 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                              */
                             for (i = 0; i < multiparts; i++) {
                                 if (messageGetMimeType(messages[i]) == MULTIPART) {
-                                    aMessage     = messages[i];
                                     htmltextPart = i;
                                     break;
                                 }
@@ -2302,15 +2298,14 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
 #if HAVE_JSON
                             /* Send root HTML file for preclassification */
                             if (mctx->ctx->wrkproperty)
-                                (void)parseRootMHTML(mctx, aMessage, aText);
+                                (void)parseRootMHTML(mctx, messages[htmltextPart], aText);
 #endif
-                            rc = parseEmailBody(aMessage, aText, mctx, recursion_level + 1);
-                            if ((rc == OK) && aMessage) {
-                                assert(aMessage == messages[htmltextPart]);
-                                messageDestroy(aMessage);
+                            rc = parseEmailBody(messages[htmltextPart], aText, mctx, recursion_level + 1);
+                            if ((rc == OK) && messages[htmltextPart]) {
+                                messageDestroy(messages[htmltextPart]);
                                 messages[htmltextPart] = NULL;
                             } else if (rc == VIRUS) {
-                                infected = TRUE;
+                                infected = true;
                                 break;
                             }
                         }
@@ -2380,7 +2375,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                                                        messages, i, &rc, mctx,
                                                        messageIn, &aText, recursion_level + 1);
                             if (rc == VIRUS) {
-                                infected = TRUE;
+                                infected = true;
                                 break;
                             }
                             if (rc == MAXREC)
@@ -2569,7 +2564,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
         /* Look for a bounce in the text (non mime encoded) portion */
         const text *t;
         /* isBounceStart() is expensive, reduce the number of calls */
-        bool lookahead_definately_is_bounce = FALSE;
+        bool lookahead_definately_is_bounce = false;
 
         for (t = aText; t && (rc != VIRUS); t = t->t_next) {
             const line_t *l = t->t_line;
@@ -2578,19 +2573,18 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
             bool inheader;
 
             if (l == NULL) {
-                /* assert(lookahead_definately_is_bounce == FALSE) */
                 continue;
             }
 
             if (lookahead_definately_is_bounce)
-                lookahead_definately_is_bounce = FALSE;
+                lookahead_definately_is_bounce = false;
             else if (!isBounceStart(mctx, lineGetData(l)))
                 continue;
 
             lookahead = t->t_next;
             if (lookahead) {
                 if (isBounceStart(mctx, lineGetData(lookahead->t_line))) {
-                    lookahead_definately_is_bounce = TRUE;
+                    lookahead_definately_is_bounce = true;
                     /* don't save worthless header lines */
                     continue;
                 }
@@ -2671,14 +2665,14 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
             fileblobAddData(fb, (const unsigned char *)"Received: by clamd (bounce)\n", 28);
             fileblobSetCTX(fb, mctx->ctx);
 
-            inheader    = TRUE;
+            inheader    = true;
             topofbounce = NULL;
             do {
                 l = t->t_line;
 
                 if (l == NULL) {
                     if (inheader) {
-                        inheader    = FALSE;
+                        inheader    = false;
                         topofbounce = t;
                     }
                 } else {
@@ -2695,7 +2689,7 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                     s = lineGetData(l);
                     if (isBounceStart(mctx, s)) {
                         cli_dbgmsg("Found the start of another bounce candidate (%s)\n", s);
-                        lookahead_definately_is_bounce = TRUE;
+                        lookahead_definately_is_bounce = true;
                         break;
                     }
                 }
@@ -2758,14 +2752,14 @@ parseEmailBody(message *messageIn, text *textIn, mbox_ctx *mctx, unsigned int re
                         rc = VIRUS;
                     mctx->files++;
                 }
-                saveIt = FALSE;
+                saveIt = false;
             } else
                 /*
                  * Save the entire text portion,
                  * since it it may be an HTML file with
                  * a JavaScript virus or a phish
                  */
-                saveIt = TRUE;
+                saveIt = true;
 
             if (saveIt) {
                 cli_dbgmsg("Saving text part to scan, rc = %d\n",
@@ -3010,6 +3004,8 @@ boundaryEnd(const char *line, const char *boundary)
 
 /*
  * Initialise the various lookup tables
+ *
+ * Only initializes the tables if not already initialized.
  */
 static int
 initialiseTables(table_t **rfc821Table, table_t **subtypeTable)
@@ -3019,27 +3015,38 @@ initialiseTables(table_t **rfc821Table, table_t **subtypeTable)
     /*
      * Initialise the various look up tables
      */
-    *rfc821Table = tableCreate();
-    assert(*rfc821Table != NULL);
+    if (NULL == *rfc821Table) {
+        *rfc821Table = tableCreate();
+        if (*rfc821Table == NULL) {
+            return -1;
+        }
 
-    for (tableinit = rfc821headers; tableinit->key; tableinit++)
-        if (tableInsert(*rfc821Table, tableinit->key, tableinit->value) < 0) {
+        for (tableinit = rfc821headers; tableinit->key; tableinit++) {
+            if (tableInsert(*rfc821Table, tableinit->key, tableinit->value) < 0) {
+                tableDestroy(*rfc821Table);
+                *rfc821Table = NULL;
+                return -1;
+            }
+        }
+    }
+    if (NULL == *subtypeTable) {
+        *subtypeTable = tableCreate();
+        if (*subtypeTable == NULL) {
             tableDestroy(*rfc821Table);
             *rfc821Table = NULL;
             return -1;
         }
 
-    *subtypeTable = tableCreate();
-    assert(*subtypeTable != NULL);
-
-    for (tableinit = mimeSubtypes; tableinit->key; tableinit++)
-        if (tableInsert(*subtypeTable, tableinit->key, tableinit->value) < 0) {
-            tableDestroy(*rfc821Table);
-            tableDestroy(*subtypeTable);
-            *rfc821Table  = NULL;
-            *subtypeTable = NULL;
-            return -1;
+        for (tableinit = mimeSubtypes; tableinit->key; tableinit++) {
+            if (tableInsert(*subtypeTable, tableinit->key, tableinit->value) < 0) {
+                tableDestroy(*rfc821Table);
+                tableDestroy(*subtypeTable);
+                *rfc821Table  = NULL;
+                *subtypeTable = NULL;
+                return -1;
+            }
         }
+    }
 
     return 0;
 }
@@ -3136,7 +3143,7 @@ parseMimeHeader(message *m, const char *cmd, const table_t *rfc821Table, const c
     int commandNumber;
     size_t argCnt = 0;
 
-    *heuristicFound = FALSE;
+    *heuristicFound = false;
 
     cli_dbgmsg("parseMimeHeader: cmd='%s', arg='%s'\n", cmd, arg);
 
@@ -3367,16 +3374,18 @@ rfc822comments(const char *in, char *out)
     char *optr;
     int backslash, inquote, commentlevel;
 
-    if (in == NULL)
+    if (in == NULL || out == in) {
+        cli_errmsg("rfc822comments: Invalid parameters.n");
         return NULL;
+    }
 
-    if (strchr(in, '(') == NULL)
+    if (strchr(in, '(') == NULL) {
         return NULL;
+    }
 
-    assert(out != in);
-
-    while (isspace((const unsigned char)*in))
+    while (isspace((const unsigned char)*in)) {
         in++;
+    }
 
     if (out == NULL) {
         out = cli_malloc(strlen(in) + 1);
@@ -3503,7 +3512,10 @@ rfc2047(const char *in)
         }
         in += 2;
         ptr = strstr(enctext, "?=");
-        assert(ptr != NULL);
+        if (NULL == ptr) {
+            free(enctext);
+            break;
+        }
         *ptr = '\0';
         /*cli_dbgmsg("Need to decode '%s' with method '%c'\n", enctext, encoding);*/
 
@@ -3513,7 +3525,10 @@ rfc2047(const char *in)
             break;
         }
         messageAddStr(m, enctext);
+
         free(enctext);
+        enctext = NULL;
+
         switch (encoding) {
             case 'q':
                 messageSetEncoding(m, "quoted-printable");
@@ -3915,7 +3930,7 @@ checkURLs(message *mainMessage, mbox_ctx *mctx, mbox_status *rc, int is_html)
                  *    encapsulated so we should not access
                  *    the members directly
                  */
-                mainMessage->isInfected = TRUE;
+                mainMessage->isInfected = true;
                 *rc                     = VIRUS;
                 cli_dbgmsg("PH:Phishing found\n");
             }
@@ -3974,17 +3989,17 @@ usefulHeader(int commandNumber, const char *cmd)
         case CONTENT_TRANSFER_ENCODING:
         case CONTENT_DISPOSITION:
         case CONTENT_TYPE:
-            return TRUE;
+            return true;
         default:
             if (strcasecmp(cmd, "From") == 0)
-                return TRUE;
+                return true;
             if (strcasecmp(cmd, "Received") == 0)
-                return TRUE;
+                return true;
             if (strcasecmp(cmd, "De") == 0)
-                return TRUE;
+                return true;
     }
 
-    return FALSE;
+    return false;
 }
 
 /*
@@ -4062,17 +4077,17 @@ isBounceStart(mbox_ctx *mctx, const char *line)
     size_t len;
 
     if (line == NULL)
-        return FALSE;
+        return false;
     if (*line == '\0')
-        return FALSE;
+        return false;
     /*if((strncmp(line, "From ", 5) == 0) && !isalnum(line[5]))
-        return FALSE;
+        return false;
     if((strncmp(line, ">From ", 6) == 0) && !isalnum(line[6]))
-        return FALSE;*/
+        return false;*/
 
     len = strlen(line);
     if ((len < 6) || (len >= 72))
-        return FALSE;
+        return false;
 
     if ((memcmp(line, "From ", 5) == 0) ||
         (memcmp(line, ">From ", 6) == 0)) {
@@ -4088,10 +4103,10 @@ isBounceStart(mbox_ctx *mctx, const char *line)
         while (*++line != '\0');
 
         if (numSpaces < 6)
-            return FALSE;
+            return false;
         if (numDigits < 11)
-            return FALSE;
-        return TRUE;
+            return false;
+        return true;
     }
     return (bool)(cli_compare_ftm_file((const unsigned char *)line, len, mctx->ctx->engine) == CL_TYPE_MAIL);
 }
@@ -4103,7 +4118,7 @@ isBounceStart(mbox_ctx *mctx, const char *line)
 static bool
 exportBinhexMessage(mbox_ctx *mctx, message *m)
 {
-    bool infected = FALSE;
+    bool infected = false;
     fileblob *fb;
 
     if (messageGetEncoding(m) == NOENCODING)
@@ -4116,7 +4131,7 @@ exportBinhexMessage(mbox_ctx *mctx, message *m)
                    fileblobGetFilename(fb));
 
         if (fileblobScanAndDestroy(fb) == CL_VIRUS)
-            infected = TRUE;
+            infected = true;
         mctx->files++;
     } else
         cli_errmsg("Couldn't decode binhex file to %s\n", mctx->dir);
@@ -4237,7 +4252,7 @@ static const char *getEncTypeStr(encoding_type enctype)
 static message *
 do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, mbox_ctx *mctx, message *messageIn, text **tptr, unsigned int recursion_level)
 {
-    bool addToText = FALSE;
+    bool addToText = false;
     const char *dtype;
 #ifndef SAVE_TO_DISC
     message *body;
@@ -4251,20 +4266,10 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
         json_object *multiobj = cli_jsonarray(mctx->wrkobj, "Multipart");
         if (multiobj == NULL) {
             cli_errmsg("Cannot get multipart preclass array\n");
-            *rc = -1;
-            return mainMessage;
-        }
-
-        thisobj = messageGetJObj(aMessage);
-        if (thisobj == NULL) {
+        } else if (NULL == (thisobj = messageGetJObj(aMessage))) {
             cli_dbgmsg("Cannot get message preclass object\n");
-            *rc = -1;
-            return mainMessage;
-        }
-        if (cli_json_addowner(multiobj, thisobj, NULL, -1) != CL_SUCCESS) {
+        } else if (CL_SUCCESS != cli_json_addowner(multiobj, thisobj, NULL, -1)) {
             cli_errmsg("Cannot assign message preclass object to multipart preclass array\n");
-            *rc = -1;
-            return mainMessage;
         }
     }
 #endif
@@ -4289,7 +4294,13 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
         cli_jsonstr(thisobj, "MimeSubtype", messageGetMimeSubtype(aMessage));
         cli_jsonstr(thisobj, "EncodingType", getEncTypeStr(messageGetEncoding(aMessage)));
         cli_jsonstr(thisobj, "Disposition", messageGetDispositionType(aMessage));
-        cli_jsonstr(thisobj, "Filename", messageHasFilename(aMessage) ? messageGetFilename(aMessage) : "(inline)");
+        if (messageHasFilename(aMessage)) {
+            char *filename = messageGetFilename(aMessage);
+            cli_jsonstr(thisobj, "Filename", filename);
+            free(filename);
+        } else {
+            cli_jsonstr(thisobj, "Filename", "(inline)");
+        }
     }
 #endif
 
@@ -4316,11 +4327,10 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
                     cli_dbgmsg("Found binhex message in multipart/mixed non mime part\n");
                     if (exportBinhexMessage(mctx, aMessage))
                         *rc = VIRUS;
-                    assert(aMessage == messages[i]);
                     messageReset(messages[i]);
                 }
             }
-            addToText = TRUE;
+            addToText = true;
             if (messageGetBody(aMessage) == NULL)
                 /*
                  * No plain text version
@@ -4350,7 +4360,7 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
                      */
                     if (!messageHasFilename(aMessage)) {
                         cli_dbgmsg("Adding part to main message\n");
-                        addToText = TRUE;
+                        addToText = true;
                     } else
                         cli_dbgmsg("Treating inline as attachment\n");
                 } else {
@@ -4385,7 +4395,6 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
                          * itself has been encoded
                          */
                         cli_dbgmsg("Unencoded multipart/message will not be scanned\n");
-                        assert(aMessage == messages[i]);
                         messageDestroy(messages[i]);
                         messages[i] = NULL;
                         return mainMessage;
@@ -4395,10 +4404,7 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
                     cli_dbgmsg("Encoded multipart/message will be scanned\n");
             }
 #endif
-#if 0
-            messageAddStrAtTop(aMessage,
-                "Received: by clamd (message/rfc822)");
-#endif
+
 #ifdef SAVE_TO_DISC
             /*
              * Save this embedded message
@@ -4406,7 +4412,6 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
              */
             if (saveTextPart(mctx, aMessage, 1) == CL_VIRUS)
                 *rc = VIRUS;
-            assert(aMessage == messages[i]);
             messageDestroy(messages[i]);
             messages[i] = NULL;
 #else
@@ -4424,7 +4429,6 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
              * message as a message.
              * This can save a lot of memory
              */
-            assert(aMessage == messages[i]);
             messageDestroy(messages[i]);
             messages[i]  = NULL;
 #if HAVE_JSON
@@ -4459,7 +4463,6 @@ do_multipart(message *mainMessage, message **messages, int i, mbox_status *rc, m
                  */
                 *rc = parseEmailBody(aMessage, *tptr, mctx, recursion_level + 1);
                 cli_dbgmsg("Finished recursion, rc = %d\n", (int)*rc);
-                assert(aMessage == messages[i]);
                 messageDestroy(messages[i]);
                 messages[i] = NULL;
             } else {
@@ -4563,10 +4566,10 @@ next_is_folded_header(const text *t)
     const char *data, *ptr;
 
     if (next == NULL)
-        return FALSE;
+        return false;
 
     if (next->t_line == NULL)
-        return FALSE;
+        return false;
 
     data = lineGetData(next->t_line);
 
@@ -4575,7 +4578,7 @@ next_is_folded_header(const text *t)
      * previous entry.
      */
     if (isblank(data[0]))
-        return TRUE;
+        return true;
 
     if (strchr(data, '=') == NULL)
         /*
@@ -4583,7 +4586,7 @@ next_is_folded_header(const text *t)
          *    Content-Type: text/html;
          *    Content-Transfer-Encoding: quoted-printable
          */
-        return FALSE;
+        return false;
 
     /*
      * Some are broken and don't fold headers lines
@@ -4607,16 +4610,16 @@ next_is_folded_header(const text *t)
     while (--ptr > data)
         switch (*ptr) {
             case ';':
-                return TRUE;
+                return true;
             case '\n':
             case ' ':
             case '\r':
             case '\t':
                 continue; /* white space at end of line */
             default:
-                return FALSE;
+                return false;
         }
-    return FALSE;
+    return false;
 }
 
 /*
@@ -4630,11 +4633,11 @@ newline_in_header(const char *line)
     cli_dbgmsg("newline_in_header, check \"%s\"\n", line);
 
     if (strncmp(line, "Message-Id: ", 12) == 0)
-        return TRUE;
+        return true;
     if (strncmp(line, "Date: ", 6) == 0)
-        return TRUE;
+        return true;
 
     cli_dbgmsg("newline_in_header, returning \"%s\"\n", line);
 
-    return FALSE;
+    return false;
 }
diff --git a/libclamav/message.c b/libclamav/message.c
index 1518f6536..c9335bfbe 100644
--- a/libclamav/message.c
+++ b/libclamav/message.c
@@ -39,9 +39,9 @@
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
 #endif
-#include <assert.h>
 #include <ctype.h>
 #include <stdio.h>
+#include <stdbool.h>
 
 #ifdef CL_THREAD_SAFE
 #include <pthread.h>
@@ -61,17 +61,6 @@
 
 #define RFC2045LENGTH 76 /* maximum number of characters on a line */
 
-#ifdef HAVE_STDBOOL_H
-#include <stdbool.h>
-#else
-#ifdef FALSE
-typedef unsigned char bool;
-#else
-typedef enum { FALSE = 0,
-               TRUE  = 1 } bool;
-#endif
-#endif
-
 static int messageHasArgument(const message *m, const char *variable);
 static void messageIsEncoding(message *m);
 static unsigned char *decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(char), bool isFast);
@@ -85,8 +74,8 @@ static unsigned char hex(char c);
 static unsigned char base64(char c);
 static unsigned char uudecode(char c);
 #endif
-static const char *messageGetArgument(const message *m, int arg);
-static void *messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text);
+static const char *messageGetArgument(const message *m, size_t arg);
+static void *messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), int (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text);
 static int usefulArg(const char *arg);
 static void messageDedup(message *m);
 static char *rfc2231(const char *in);
@@ -161,7 +150,9 @@ messageCreate(void)
 
 void messageDestroy(message *m)
 {
-    assert(m != NULL);
+    if (NULL == m) {
+        return;
+    }
 
     messageReset(m);
 
@@ -170,9 +161,11 @@ void messageDestroy(message *m)
 
 void messageReset(message *m)
 {
-    int i;
+    size_t i;
 
-    assert(m != NULL);
+    if (NULL == m) {
+        return;
+    }
 
     if (m->mimeSubtype)
         free(m->mimeSubtype);
@@ -189,10 +182,15 @@ void messageReset(message *m)
     if (m->body_first)
         textDestroy(m->body_first);
 
-    assert(m->base64chars == 0);
+    if (0 != m->base64chars) {
+        cli_errmsg("Internal email parse error: message base64chars should be 0 when resetting the message\n");
+    }
 
     if (m->encodingTypes) {
-        assert(m->numberOfEncTypes > 0);
+        if (0 == m->numberOfEncTypes) {
+            cli_errmsg("Internal email parse error: message numberOfEncTypes should be 0 if encoding types are set\n");
+        }
+
         free(m->encodingTypes);
     }
 
@@ -220,9 +218,13 @@ int messageSetMimeType(message *mess, const char *type)
     int typeval;
     static table_t *mime_table;
 
-    assert(mess != NULL);
+    if (mess == NULL) {
+        cli_dbgmsg("messageSetMimeType: NULL message pointer\n");
+        return 0;
+    }
+
     if (type == NULL) {
-        cli_dbgmsg("Empty content-type field\n");
+        cli_dbgmsg("messageSetMimeType: Empty content-type field\n");
         return 0;
     }
 
@@ -270,19 +272,19 @@ int messageSetMimeType(message *mess, const char *type)
             mess->mimeType = MEXTENSION;
         else {
             /*
-			 * Force scanning of strange messages
-			 */
+             * Force scanning of strange messages
+             */
             if (strcasecmp(type, "plain") == 0) {
                 cli_dbgmsg("Incorrect MIME type: `plain', set to Text\n");
                 mess->mimeType = TEXT;
             } else {
                 /*
-				 * Don't handle broken e-mail probably sending
-				 *	Content-Type: plain/text
-				 * instead of
-				 *	Content-Type: text/plain
-				 * as an attachment
-				 */
+                 * Don't handle broken e-mail probably sending
+                 *    Content-Type: plain/text
+                 * instead of
+                 *    Content-Type: text/plain
+                 * as an attachment
+                 */
                 int highestSimil = 0, t = -1;
                 const char *closest = NULL;
 
@@ -314,20 +316,26 @@ int messageSetMimeType(message *mess, const char *type)
 mime_type
 messageGetMimeType(const message *m)
 {
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: message is pointer is NULL when trying to get MIME type\n");
+        return NOMIME;
+    }
 
     return m->mimeType;
 }
 
 void messageSetMimeSubtype(message *m, const char *subtype)
 {
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: message is pointer is NULL when trying to set MIME sub-type\n");
+        return;
+    }
 
     if (subtype == NULL) {
         /*
-		 * Handle broken content-type lines, e.g.
-		 *	Content-Type: text/
-		 */
+         * Handle broken content-type lines, e.g.
+         *    Content-Type: text/
+         */
         cli_dbgmsg("Empty content subtype\n");
         subtype = "";
     }
@@ -346,7 +354,10 @@ messageGetMimeSubtype(const message *m)
 
 void messageSetDispositionType(message *m, const char *disptype)
 {
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: message is pointer is NULL when trying to set disposition type\n");
+        return;
+    }
 
     if (m->mimeDispositionType)
         free(m->mimeDispositionType);
@@ -356,11 +367,11 @@ void messageSetDispositionType(message *m, const char *disptype)
     }
 
     /*
-	 * It's broken for there to be an entry such as "Content-Disposition:"
-	 * However some spam and viruses are rather broken, it's a sign
-	 * that something is wrong if we get that - maybe we should force a
-	 * scan of this part
-	 */
+     * It's broken for there to be an entry such as "Content-Disposition:"
+     * However some spam and viruses are rather broken, it's a sign
+     * that something is wrong if we get that - maybe we should force a
+     * scan of this part
+     */
     while (*disptype && isspace((int)*disptype))
         disptype++;
     if (*disptype) {
@@ -379,17 +390,20 @@ messageGetDispositionType(const message *m)
 
 /*
  * TODO:
- *	Arguments are held on a per message basis, they should be held on
+ *    Arguments are held on a per message basis, they should be held on
  * a per section basis. Otherwise what happens if two sections have two
  * different values for charset? Probably doesn't matter for the use this
  * code will be given, but will need fixing if this code is used elsewhere
  */
 void messageAddArgument(message *m, const char *arg)
 {
-    int offset;
+    size_t offset;
     char *p;
 
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: message is pointer is NULL when trying to add an argument\n");
+        return;
+    }
 
     if (arg == NULL)
         return; /* Note: this is not an error condition */
@@ -434,9 +448,9 @@ void messageAddArgument(message *m, const char *arg)
     if (strchr(p, '=') == NULL) {
         if (strncmp(p, "filename", 8) == 0) {
             /*
-			 * FIXME: Bounce message handling is corrupting the in
-			 * core copies of headers
-			 */
+             * FIXME: Bounce message handling is corrupting the in
+             * core copies of headers
+             */
             if (strlen(p) > 8) {
                 cli_dbgmsg("Possible data corruption fixed\n");
                 p[8] = '=';
@@ -453,11 +467,11 @@ void messageAddArgument(message *m, const char *arg)
     }
 
     /*
-	 * This is terribly broken from an RFC point of view but is useful
-	 * for catching viruses which have a filename but no type of
-	 * mime. By pretending defaulting to an application rather than
-	 * to nomime we can ensure they're saved and scanned
-	 */
+     * This is terribly broken from an RFC point of view but is useful
+     * for catching viruses which have a filename but no type of
+     * mime. By pretending defaulting to an application rather than
+     * to nomime we can ensure they're saved and scanned
+     */
     if ((strncasecmp(p, "filename=", 9) == 0) || (strncasecmp(p, "name=", 5) == 0))
         if (messageGetMimeType(m) == NOMIME) {
             cli_dbgmsg("Force mime encoding to application\n");
@@ -468,8 +482,8 @@ void messageAddArgument(message *m, const char *arg)
 /*
  * Add in all the arguments.
  * Cope with:
- *	name="foo bar.doc"
- *	charset=foo name=bar
+ *    name="foo bar.doc"
+ *    charset=foo name=bar
  */
 void messageAddArguments(message *m, const char *s)
 {
@@ -477,7 +491,10 @@ void messageAddArguments(message *m, const char *s)
 
     cli_dbgmsg("Add arguments '%s'\n", string);
 
-    assert(string != NULL);
+    if (string == NULL) {
+        cli_errmsg("Internal email parser error: message is pointer is NULL when trying to add message arguments\n");
+        return;
+    }
 
     while (*string) {
         const char *key, *cptr;
@@ -494,23 +511,23 @@ void messageAddArguments(message *m, const char *s)
         data = strchr(string, '=');
 
         /*
-		 * Some spam breaks RFC2045 by using ':' instead of '='
-		 * e.g.:
-		 *	Content-Type: text/html; charset:ISO-8859-1
-		 * should be:
-		 *	Content-type: text/html; charset=ISO-8859-1
-		 *
-		 * We give up with lines that are completely broken because
-		 * we don't have ESP and don't know what was meant to be there.
-		 * It's unlikely to really be a problem.
-		 */
+         * Some spam breaks RFC2045 by using ':' instead of '='
+         * e.g.:
+         *    Content-Type: text/html; charset:ISO-8859-1
+         * should be:
+         *    Content-type: text/html; charset=ISO-8859-1
+         *
+         * We give up with lines that are completely broken because
+         * we don't have ESP and don't know what was meant to be there.
+         * It's unlikely to really be a problem.
+         */
         if (data == NULL)
             data = strchr(string, ':');
 
         if (data == NULL) {
             /*
-			 * Completely broken, give up
-			 */
+             * Completely broken, give up
+             */
             cli_dbgmsg("Can't parse header \"%s\"\n", s);
             return;
         }
@@ -518,14 +535,14 @@ void messageAddArguments(message *m, const char *s)
         string = &data[1];
 
         /*
-		 * Handle white space to the right of the equals sign
-		 * This breaks RFC2045 which has:
-		 *	parameter := attribute "=" value
-		 *	attribute := token   ; case-insensitive
-		 *	token  :=  1*<any (ASCII) CHAR except SPACE, CTLs,
-		 *		or tspecials>
-		 * But too many MUAs ignore this
-		 */
+         * Handle white space to the right of the equals sign
+         * This breaks RFC2045 which has:
+         *    parameter := attribute "=" value
+         *    attribute := token   ; case-insensitive
+         *    token  :=  1*<any (ASCII) CHAR except SPACE, CTLs,
+         *        or tspecials>
+         * But too many MUAs ignore this
+         */
         while (isspace(*string) && (*string != '\0'))
             string++;
 
@@ -538,9 +555,9 @@ void messageAddArguments(message *m, const char *s)
             char *ptr, *kcopy;
 
             /*
-			 * The field is in quotes, so look for the
-			 * closing quotes
-			 */
+             * The field is in quotes, so look for the
+             * closing quotes
+             */
             kcopy = cli_strdup(key);
 
             if (kcopy == NULL)
@@ -583,15 +600,15 @@ void messageAddArguments(message *m, const char *s)
 
             if (ptr == NULL) {
                 /*
-				 * Weird e-mail header such as:
-				 * Content-Type: application/octet-stream; name="
-				 * "
-				 * Content-Transfer-Encoding: base64
-				 * Content-Disposition: attachment; filename="
-				 * "
-				 *
-				 * Use the end of line as data.
-				 */
+                 * Weird e-mail header such as:
+                 * Content-Type: application/octet-stream; name="
+                 * "
+                 * Content-Transfer-Encoding: base64
+                 * Content-Disposition: attachment; filename="
+                 * "
+                 *
+                 * Use the end of line as data.
+                 */
             } else
                 *ptr = '\0';
 
@@ -613,9 +630,9 @@ void messageAddArguments(message *m, const char *s)
             }
 
             /*
-			 * The field is not in quotes, so look for the closing
-			 * white space
-			 */
+             * The field is not in quotes, so look for the closing
+             * white space
+             */
             while ((*string != '\0') && !isspace(*string))
                 string++;
 
@@ -635,11 +652,16 @@ void messageAddArguments(message *m, const char *s)
 }
 
 static const char *
-messageGetArgument(const message *m, int arg)
+messageGetArgument(const message *m, size_t arg)
 {
-    assert(m != NULL);
-    assert(arg >= 0);
-    assert(arg < m->numberOfArguments);
+    if (m == NULL) {
+        cli_errmsg("Internal email parse error: message pointer is NULL when trying to get a message argument\n");
+        return "";
+    }
+
+    if (arg >= m->numberOfArguments) {
+        return "";
+    }
 
     return (m->mimeArguments[arg]) ? m->mimeArguments[arg] : "";
 }
@@ -651,11 +673,13 @@ messageGetArgument(const message *m, int arg)
 char *
 messageFindArgument(const message *m, const char *variable)
 {
-    int i;
+    size_t i;
     size_t len;
 
-    assert(m != NULL);
-    assert(variable != NULL);
+    if (m == NULL || variable == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when finding message arguments\n");
+        return NULL;
+    }
 
     len = strlen(variable);
 
@@ -687,14 +711,14 @@ messageFindArgument(const message *m, const char *variable)
                     return NULL;
 
                 /*
-				 * fix un-quoting of boundary strings from
-				 * header, occurs if boundary was given as
-				 *	'boundary="_Test_";'
-				 *
-				 * At least two quotes in string, assume
-				 * quoted argument
-				 * end string at next quote
-				 */
+                 * fix un-quoting of boundary strings from
+                 * header, occurs if boundary was given as
+                 *    'boundary="_Test_";'
+                 *
+                 * At least two quotes in string, assume
+                 * quoted argument
+                 * end string at next quote
+                 */
                 if ((p = strchr(ret, '"')) != NULL) {
                     ret[strlen(ret) - 1] = '\0';
                     *p                   = '\0';
@@ -722,11 +746,13 @@ messageGetFilename(const message *m)
 static int
 messageHasArgument(const message *m, const char *variable)
 {
-    int i;
+    size_t i;
     size_t len;
 
-    assert(m != NULL);
-    assert(variable != NULL);
+    if (m == NULL || variable == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when checking if message has arguments\n");
+        return 0;
+    }
 
     len = strlen(variable);
 
@@ -765,8 +791,10 @@ void messageSetEncoding(message *m, const char *enctype)
     int i;
     char *type;
 
-    assert(m != NULL);
-    assert(enctype != NULL);
+    if (m == NULL || enctype == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when setting message encoding type\n");
+        return;
+    }
 
     /*m->encodingType = EEXTENSION;*/
 
@@ -781,10 +809,10 @@ void messageSetEncoding(message *m, const char *enctype)
     }
 
     /*
-	 * Iterate through
-	 *	Content-Transfer-Encoding: base64 binary
-	 * cli_strtok's fieldno counts from 0
-	 */
+     * Iterate through
+     *    Content-Transfer-Encoding: base64 binary
+     * cli_strtok's fieldno counts from 0
+     */
     i = 0;
     while ((type = cli_strtok(enctype, i++, " \t")) != NULL) {
         int highestSimil    = 0;
@@ -796,21 +824,21 @@ void messageSetEncoding(message *m, const char *enctype)
 
             if ((lowertype != tolower(e->string[0])) && (lowertype != 'x'))
                 /*
-				 * simil is expensive, I'm yet to encounter only
-				 * one example of a missent encoding when the
-				 * first character was wrong, so lets assume no
-				 * match to save the call.
-				 *
-				 * That example was quoted-printable sent as
-				 * X-quoted-printable.
-				 */
+                 * simil is expensive, I'm yet to encounter only
+                 * one example of a missent encoding when the
+                 * first character was wrong, so lets assume no
+                 * match to save the call.
+                 *
+                 * That example was quoted-printable sent as
+                 * X-quoted-printable.
+                 */
                 continue;
 
             if (strcmp(e->string, "uuencode") == 0)
                 /*
-				 * No need to test here - fast track visa will have
-				 * handled uuencoded files
-				 */
+                 * No need to test here - fast track visa will have
+                 * handled uuencoded files
+                 */
                 continue;
 
             sim = simil(type, e->string);
@@ -846,12 +874,12 @@ void messageSetEncoding(message *m, const char *enctype)
 
         if (e->string == NULL) {
             /*
-			 * The stated encoding type is illegal, so we
-			 * use a best guess of what it should be.
-			 *
-			 * 50% is arbitrary. For example 7bi will match as
-			 * 66% certain to be 7bit
-			 */
+             * The stated encoding type is illegal, so we
+             * use a best guess of what it should be.
+             *
+             * 50% is arbitrary. For example 7bi will match as
+             * 66% certain to be 7bit
+             */
             if (highestSimil >= 50) {
                 cli_dbgmsg("Unknown encoding type \"%s\" - guessing as %s (%u%% certainty)\n",
                            type, closest, highestSimil);
@@ -859,9 +887,9 @@ void messageSetEncoding(message *m, const char *enctype)
             } else {
                 cli_dbgmsg("Unknown encoding type \"%s\" - if you believe this file contains a virus, submit it to www.clamav.net\n", type);
                 /*
-				 * Err on the side of safety, enable all
-				 * decoding modules
-				 */
+                 * Err on the side of safety, enable all
+                 * decoding modules
+                 */
                 messageSetEncoding(m, "base64");
                 messageSetEncoding(m, "quoted-printable");
             }
@@ -874,7 +902,10 @@ void messageSetEncoding(message *m, const char *enctype)
 encoding_type
 messageGetEncoding(const message *m)
 {
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when checking message encoding type\n");
+        return NOENCODING;
+    }
 
     if (m->numberOfEncTypes == 0)
         return NOENCODING;
@@ -883,7 +914,10 @@ messageGetEncoding(const message *m)
 
 int messageAddLine(message *m, line_t *line)
 {
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when adding line to message.\n");
+        return -1;
+    }
 
     if (m->body_first == NULL)
         m->body_last = m->body_first = (text *)cli_malloc(sizeof(text));
@@ -918,17 +952,20 @@ int messageAddStr(message *m, const char *data)
 {
     line_t *repeat = NULL;
 
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("messageAddStr: invalid arguments\n");
+        return -1;
+    }
 
     if (data) {
         if (*data == '\0')
             data = NULL;
         else {
             /*
-			 * If it's only white space, just store one space to
-			 * save memory. You must store something since it may
-			 * be a header line
-			 */
+             * If it's only white space, just store one space to
+             * save memory. You must store something since it may
+             * be a header line
+             */
             int iswhite = 1;
             const char *p;
 
@@ -947,30 +984,34 @@ int messageAddStr(message *m, const char *data)
     if (m->body_first == NULL)
         m->body_last = m->body_first = (text *)cli_malloc(sizeof(text));
     else {
-        assert(m->body_last != NULL);
-        if ((data == NULL) && (m->body_last->t_line == NULL))
-            /*
-			 * Although this would save time and RAM, some
-			 * phish signatures have been built which need the
-			 * blank lines
-			 */
-            if (messageGetMimeType(m) != TEXT)
-                /* don't save two blank lines in succession */
-                return 1;
+        if (m->body_last == NULL) {
+            cli_errmsg("Internal email parser error: message 'body_last' pointer should not be NULL if 'body_first' is set.\n");
+        } else {
+            if ((data == NULL) && (m->body_last->t_line == NULL))
+                /*
+                 * Although this would save time and RAM, some
+                 * phish signatures have been built which need the
+                 * blank lines
+                 */
+                if (messageGetMimeType(m) != TEXT)
+                    /* don't save two blank lines in succession */
+                    return 1;
 
-        m->body_last->t_next = (text *)cli_malloc(sizeof(text));
-        if (m->body_last->t_next == NULL) {
-            messageDedup(m);
             m->body_last->t_next = (text *)cli_malloc(sizeof(text));
             if (m->body_last->t_next == NULL) {
-                cli_errmsg("messageAddStr: out of memory\n");
-                return -1;
+                messageDedup(m);
+                m->body_last->t_next = (text *)cli_malloc(sizeof(text));
+                if (m->body_last->t_next == NULL) {
+                    cli_errmsg("messageAddStr: out of memory\n");
+                    return -1;
+                }
             }
-        }
 
-        if (data && m->body_last->t_line && (strcmp(data, lineGetData(m->body_last->t_line)) == 0))
-            repeat = m->body_last->t_line;
-        m->body_last = m->body_last->t_next;
+            if (data && m->body_last->t_line && (strcmp(data, lineGetData(m->body_last->t_line)) == 0))
+                repeat = m->body_last->t_line;
+
+            m->body_last = m->body_last->t_next;
+        }
     }
 
     if (m->body_last == NULL) {
@@ -1004,37 +1045,6 @@ int messageAddStr(message *m, const char *data)
     return 1;
 }
 
-/*
- * Add the given line to the start of the given message
- * A copy of the given line is taken which the caller must free
- * Line must not be terminated by a \n
- */
-int messageAddStrAtTop(message *m, const char *data)
-{
-    text *oldfirst;
-
-    assert(m != NULL);
-
-    if (m->body_first == NULL)
-        return messageAddLine(m, lineCreate(data));
-
-    oldfirst      = m->body_first;
-    m->body_first = (text *)cli_malloc(sizeof(text));
-    if (m->body_first == NULL) {
-        m->body_first = oldfirst;
-        return -1;
-    }
-
-    m->body_first->t_next = oldfirst;
-    m->body_first->t_line = lineCreate((data) ? data : "");
-
-    if (m->body_first->t_line == NULL) {
-        cli_errmsg("messageAddStrAtTop: out of memory\n");
-        return -1;
-    }
-    return 1;
-}
-
 /*
  * Put the contents of the given text at the end of the current object.
  * Can be used either to move a text object into a message, or to move a
@@ -1048,13 +1058,13 @@ int messageMoveText(message *m, text *t, message *old_message)
     int rc;
 
     if (m->body_first == NULL) {
-        if (old_message) {
+        if ((NULL != old_message) &&
+            (NULL != old_message->body_first)) {
             text *u;
             /*
-			 * t is within old_message which is about to be
-			 * destroyed
-			 */
-            assert(old_message->body_first != NULL);
+             * t is within old_message which is about to be
+             * destroyed
+             */
 
             m->body_first = t;
             for (u = old_message->body_first; u != t;) {
@@ -1074,7 +1084,6 @@ int messageMoveText(message *m, text *t, message *old_message)
                     return -1;
                 }
             }
-            assert(old_message->body_last->t_next == NULL);
 
             m->body_last            = old_message->body_last;
             old_message->body_first = old_message->body_last = NULL;
@@ -1125,7 +1134,7 @@ messageIsEncoding(message *m)
     const char *line             = lineGetData(m->body_last->t_line);
 
     /*if(m->ctx == NULL)
-		cli_dbgmsg("messageIsEncoding, ctx == NULL\n");*/
+        cli_dbgmsg("messageIsEncoding, ctx == NULL\n");*/
 
     if ((m->encoding == NULL) &&
         (strncasecmp(line, encoding, sizeof(encoding) - 1) == 0) &&
@@ -1137,15 +1146,15 @@ messageIsEncoding(message *m)
         m->bounce = m->body_last;
     /* Not needed with fast track visa technology */
     /*else if((m->uuencode == NULL) && isuuencodebegin(line))
-		m->uuencode = m->body_last;*/
+        m->uuencode = m->body_last;*/
     else if ((m->binhex == NULL) &&
              strstr(line, "BinHex") &&
              (simil(line, binhex) > 90))
         /*
-			 * Look for close matches for BinHex, but
-			 * simil() is expensive so only do it if it's
-			 * likely to be found
-			 */
+             * Look for close matches for BinHex, but
+             * simil() is expensive so only do it if it's
+             * likely to be found
+             */
         m->binhex = m->body_last;
     else if ((m->yenc == NULL) && (strncmp(line, "=ybegin line=", 13) == 0))
         m->yenc = m->body_last;
@@ -1158,7 +1167,9 @@ messageIsEncoding(message *m)
 text *
 messageGetBody(message *m)
 {
-    assert(m != NULL);
+    if (NULL == m)
+        return NULL;
+
     return m->body_first;
 }
 
@@ -1170,14 +1181,15 @@ messageGetBody(message *m)
  * last item that was exported. That's sufficient for now.
  */
 static void *
-messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text)
+messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), int (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text)
 {
     void *ret;
     text *t_line;
     char *filename;
     int i;
 
-    assert(m != NULL);
+    if (NULL == m)
+        return NULL;
 
     if (messageGetBody(m) == NULL)
         return NULL;
@@ -1191,22 +1203,22 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
 
     if (m->numberOfEncTypes == 0) {
         /*
-		 * Fast copy
-		 */
+         * Fast copy
+         */
         cli_dbgmsg("messageExport: Entering fast copy mode\n");
 
 #if 0
-		filename = messageGetFilename(m);
-
-		if(filename == NULL) {
-			cli_dbgmsg("Unencoded attachment sent with no filename\n");
-			messageAddArgument(m, "name=attachment");
-		} else if((strcmp(filename, "textportion") != 0) && (strcmp(filename, "mixedtextportion") != 0))
-			/*
-			 * Some virus attachments don't say how they've
-			 * been encoded. We assume base64
-			 */
-			messageSetEncoding(m, "base64");
+        filename = messageGetFilename(m);
+
+        if(filename == NULL) {
+            cli_dbgmsg("Unencoded attachment sent with no filename\n");
+            messageAddArgument(m, "name=attachment");
+        } else if((strcmp(filename, "textportion") != 0) && (strcmp(filename, "mixedtextportion") != 0))
+            /*
+             * Some virus attachments don't say how they've
+             * been encoded. We assume base64
+             */
+            messageSetEncoding(m, "base64");
 #else
         filename = (char *)messageFindArgument(m, "filename");
         if (filename == NULL) {
@@ -1217,10 +1229,10 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
                 messageAddArgument(m, "name=attachment");
             } else
                 /*
-				 * Some virus attachments don't say how they've
-				 * been encoded. We assume base64.
-				 * RFC says encoding should be 7-bit.
-				 */
+                 * Some virus attachments don't say how they've
+                 * been encoded. We assume base64.
+                 * RFC says encoding should be 7-bit.
+                 */
                 messageSetEncoding(m, "7-bit");
         }
 #endif
@@ -1254,14 +1266,14 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
         }
         cli_dbgmsg("messageExport: enctype %d is %d\n", i, (int)enctype);
         /*
-		 * Find the filename to decode
-		 */
+         * Find the filename to decode
+         */
         if (((enctype == YENCODE) || (i == 0)) && yEncBegin(m)) {
             const char *f;
 
             /*
-			 * TODO: handle multipart yEnc encoded files
-			 */
+             * TODO: handle multipart yEnc encoded files
+             */
             t_line = yEncBegin(m);
             f      = lineGetData(t_line->t_line);
 
@@ -1285,11 +1297,11 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
         } else {
             if (enctype == UUENCODE) {
                 /*
-				 * The body will have been stripped out by the
-				 * fast track visa system. Treat as plain/text,
-				 * which means we'll still scan for funnies
-				 * outside of the uuencoded portion.
-				 */
+                 * The body will have been stripped out by the
+                 * fast track visa system. Treat as plain/text,
+                 * which means we'll still scan for funnies
+                 * outside of the uuencoded portion.
+                 */
                 cli_dbgmsg("messageExport: treat uuencode as text/plain\n");
                 enctype = m->encodingTypes[i] = NOENCODING;
             }
@@ -1300,13 +1312,13 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
                 messageAddArgument(m, "name=attachment");
             } else if (enctype == NOENCODING)
                 /*
-				 * Some virus attachments don't say how
-				 * they've been encoded. We assume
-				 * base64.
-				 *
-				 * FIXME: don't do this if it's a fall
-				 * through from uuencode
-				 */
+                 * Some virus attachments don't say how
+                 * they've been encoded. We assume
+                 * base64.
+                 *
+                 * FIXME: don't do this if it's a fall
+                 * through from uuencode
+                 */
                 messageSetEncoding(m, "base64");
 
             (*setFilename)(ret, dir, (filename && *filename) ? filename : "attachment");
@@ -1318,9 +1330,9 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
             free((char *)filename);
 
         /*
-		 * t_line should now point to the first (encoded) line of the
-		 * message
-		 */
+         * t_line should now point to the first (encoded) line of the
+         * message
+         */
         if (t_line == NULL) {
             cli_dbgmsg("Empty attachment not saved\n");
             (*destroy)(ret);
@@ -1329,8 +1341,8 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
 
         if (enctype == NOENCODING) {
             /*
-			 * Fast copy
-			 */
+             * Fast copy
+             */
             if (i == m->numberOfEncTypes - 1) {
                 /* last one */
                 (void)exportText(t_line, ret, destroy_text);
@@ -1349,20 +1361,26 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
             size_t datasize;
 
             if (enctype == YENCODE) {
-                if (line == NULL)
+                if (line == NULL) {
                     continue;
-                if (strncmp(line, "=yend ", 6) == 0)
+                }
+                if (strncmp(line, "=yend ", 6) == 0) {
                     break;
+                }
             }
 
             /*
-			 * Add two bytes for '\n' and '\0'
-			 */
+             * Add two bytes for '\n' and '\0'
+             */
             datasize = (line) ? strlen(line) + 2 : 0;
 
-            if (datasize >= sizeof(smallbuf))
+            if (datasize >= sizeof(smallbuf)) {
                 data = bigbuf = (unsigned char *)cli_malloc(datasize);
-            else {
+                if (NULL == data) {
+                    cli_dbgmsg("Failed to allocate data buffer of size %z\n", datasize);
+                    break;
+                }
+            } else {
                 bigbuf   = NULL;
                 data     = smallbuf;
                 datasize = sizeof(smallbuf);
@@ -1370,30 +1388,31 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
 
             uptr = decodeLine(m, enctype, line, data, datasize);
             if (uptr == NULL) {
-                if (data == bigbuf)
+                if (data == bigbuf) {
                     free(data);
+                }
                 break;
             }
 
             if (uptr != data) {
-                assert((size_t)(uptr - data) < datasize);
                 (*addData)(ret, data, (size_t)(uptr - data));
                 size += (size_t)(uptr - data);
             }
 
-            if (data == bigbuf)
+            if (data == bigbuf) {
                 free(data);
+            }
 
             /*
-			 * According to RFC2045, '=' is used to pad out
-			 * the last byte and should be used as evidence
-			 * of the end of the data. Some mail clients
-			 * annoyingly then put plain text after the '='
-			 * byte and viruses exploit this bug. Sigh
-			 */
+             * According to RFC2045, '=' is used to pad out
+             * the last byte and should be used as evidence
+             * of the end of the data. Some mail clients
+             * annoyingly then put plain text after the '='
+             * byte and viruses exploit this bug. Sigh
+             */
             /*if(enctype == BASE64)
-				if(strchr(line, '='))
-					break;*/
+                if(strchr(line, '='))
+                    break;*/
             if (line && destroy_text && (i == m->numberOfEncTypes - 1)) {
                 lineUnlink(t_line->t_line);
                 t_line->t_line = NULL;
@@ -1409,8 +1428,9 @@ messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy
             unsigned char *ptr;
 
             ptr = base64Flush(m, data);
-            if (ptr)
+            if (ptr) {
                 (*addData)(ret, data, (size_t)(ptr - data));
+            }
         }
     }
 
@@ -1423,7 +1443,7 @@ base64Flush(message *m, unsigned char *buf)
     cli_dbgmsg("%d trailing bytes to export\n", m->base64chars);
 
     if (m->base64chars) {
-        unsigned char *ret = decode(m, NULL, buf, base64, FALSE);
+        unsigned char *ret = decode(m, NULL, buf, base64, false);
 
         m->base64chars = 0;
 
@@ -1446,7 +1466,7 @@ int messageSavePartial(message *m, const char *dir, const char *md5id, unsigned
                        (void *(*)(void))fileblobCreate,
                        (void (*)(void *))fileblobDestroy,
                        (void (*)(void *, const char *, const char *))fileblobPartialSet,
-                       (void (*)(void *, const unsigned char *, size_t))fileblobAddData,
+                       (int (*)(void *, const unsigned char *, size_t))fileblobAddData,
                        (void *(*)(text *, void *, int))textToFileblob,
                        (void (*)(void *, cli_ctx *))fileblobSetCTX,
                        0);
@@ -1470,7 +1490,7 @@ messageToFileblob(message *m, const char *dir, int destroy)
                        (void *(*)(void))fileblobCreate,
                        (void (*)(void *))fileblobDestroy,
                        (void (*)(void *, const char *, const char *))fileblobSetFilename,
-                       (void (*)(void *, const unsigned char *, size_t))fileblobAddData,
+                       (int (*)(void *, const unsigned char *, size_t))fileblobAddData,
                        (void *(*)(text *, void *, int))textToFileblob,
                        (void (*)(void *, cli_ctx *))fileblobSetCTX,
                        destroy);
@@ -1496,7 +1516,7 @@ messageToBlob(message *m, int destroy)
                       (void *(*)(void))blobCreate,
                       (void (*)(void *))blobDestroy,
                       (void (*)(void *, const char *, const char *))blobSetFilename,
-                      (void (*)(void *, const unsigned char *, size_t))blobAddData,
+                      (int (*)(void *, const unsigned char *, size_t))blobAddData,
                       (void *(*)(text *, void *, int))textToBlob,
                       (void (*)(void *, cli_ctx *))NULL,
                       destroy);
@@ -1519,12 +1539,15 @@ messageToText(message *m)
     text *first = NULL, *last = NULL;
     const text *t_line;
 
-    assert(m != NULL);
+    if (m == NULL) {
+        cli_errmsg("Internal email parser error: invalid arguments when converting message to text.\n");
+        return NULL;
+    }
 
     if (m->numberOfEncTypes == 0) {
         /*
-		 * Fast copy
-		 */
+         * Fast copy
+         */
         for (t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {
             if (first == NULL)
                 first = last = cli_malloc(sizeof(text));
@@ -1549,9 +1572,9 @@ messageToText(message *m)
         return first;
     }
     /*
-	 * Scan over the data a number of times once for each claimed encoding
-	 * type
-	 */
+     * Scan over the data a number of times once for each claimed encoding
+     * type
+     */
     for (i = 0; i < m->numberOfEncTypes; i++) {
         const encoding_type enctype = m->encodingTypes[i];
 
@@ -1563,8 +1586,8 @@ messageToText(message *m)
             case BINARY:
             case EIGHTBIT:
                 /*
-				 * Fast copy
-				 */
+                 * Fast copy
+                 */
                 for (t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {
                     if (first == NULL)
                         first = last = cli_malloc(sizeof(text));
@@ -1606,6 +1629,7 @@ messageToText(message *m)
                     return NULL;
                 }
                 t_line = t_line->t_next;
+                /* fall-through */
             default:
                 if ((i == 0) && binhexBegin(m))
                     cli_warnmsg("Binhex messages not supported yet.\n");
@@ -1619,20 +1643,26 @@ messageToText(message *m)
 
             if (enctype == BASE64)
                 /*
-				 * ignore blanks - breaks RFC which is
-				 * probably the point!
-				 */
+                 * ignore blanks - breaks RFC which is
+                 * probably the point!
+                 */
                 if (line == NULL)
                     continue;
 
-            assert((line == NULL) || (strlen(line) <= sizeof(data)));
+            if ((line != NULL) && (strlen(line) > sizeof(data))) {
+                cli_errmsg("Internal email parser error: line size greater than size of receiving data buffer\n");
+                break;
+            }
 
             uptr = decodeLine(m, enctype, line, data, sizeof(data));
 
             if (uptr == NULL)
                 break;
 
-            assert(uptr <= &data[sizeof(data)]);
+            if ((size_t)(uptr - data) > sizeof(data)) {
+                cli_errmsg("Internal email parser error: line size greater than size of receiving data buffer\n");
+                break;
+            }
 
             if (first == NULL)
                 first = last = cli_malloc(sizeof(text));
@@ -1645,14 +1675,14 @@ messageToText(message *m)
                 break;
 
             /*
-			 * If the decoded line is the same as the encoded
-			 * there's no need to take a copy, just link it.
-			 * Note that the comparison is done without the
-			 * trailing newline that the decoding routine may have
-			 * added - that's why there's a strncmp rather than a
-			 * strcmp - that'd be bad for MIME decoders, but is OK
-			 * for AV software
-			 */
+             * If the decoded line is the same as the encoded
+             * there's no need to take a copy, just link it.
+             * Note that the comparison is done without the
+             * trailing newline that the decoding routine may have
+             * added - that's why there's a strncmp rather than a
+             * strcmp - that'd be bad for MIME decoders, but is OK
+             * for AV software
+             */
             if ((data[0] == '\n') || (data[0] == '\0'))
                 last->t_line = NULL;
             else if (line && (strncmp((const char *)data, line, strlen(line)) == 0)) {
@@ -1671,7 +1701,7 @@ messageToText(message *m)
             unsigned char data[4];
 
             memset(data, '\0', sizeof(data));
-            if (decode(m, NULL, data, base64, FALSE) && data[0]) {
+            if (decode(m, NULL, data, base64, false) && data[0]) {
                 if (first == NULL)
                     first = last = cli_malloc(sizeof(text));
                 else if (last) {
@@ -1705,13 +1735,13 @@ yEncBegin(message *m)
 const text *
 binhexBegin(message *m)
 {
-	const text *t_line;
+    const text *t_line;
 
-	for(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)
-		if(strcasecmp(t_line->t_text, "(This file must be converted with BinHex 4.0)") == 0)
-			return t_line;
+    for(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)
+        if(strcasecmp(t_line->t_text, "(This file must be converted with BinHex 4.0)") == 0)
+            return t_line;
 
-	return NULL;
+    return NULL;
 }
 #else
 text *
@@ -1729,13 +1759,13 @@ binhexBegin(message *m)
 text *
 bounceBegin(message *m)
 {
-	const text *t_line;
+    const text *t_line;
 
-	for(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)
-		if(cli_compare_ftm_file(t_line->t_text, strlen(t_line->t_text)) == CL_TYPE_MAIL)
-			return t_line;
+    for(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)
+        if(cli_compare_ftm_file(t_line->t_text, strlen(t_line->t_text)) == CL_TYPE_MAIL)
+            return t_line;
 
-	return NULL;
+    return NULL;
 }
 #else
 text *
@@ -1759,15 +1789,15 @@ bounceBegin(message *m)
 int
 messageIsAllText(const message *m)
 {
-	const text *t;
+    const text *t;
 
-	for(t = messageGetBody(m); t; t = t->t_next)
-		if(strncasecmp(t->t_text,
-			"Content-Transfer-Encoding",
-			strlen("Content-Transfer-Encoding")) == 0)
-				return 0;
+    for(t = messageGetBody(m); t; t = t->t_next)
+        if(strncasecmp(t->t_text,
+            "Content-Transfer-Encoding",
+            strlen("Content-Transfer-Encoding")) == 0)
+                return 0;
 
-	return 1;
+    return 1;
 }
 #else
 text *
@@ -1792,15 +1822,16 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
     char base64buf[RFC2045LENGTH + 1];
 
     /*cli_dbgmsg("decodeLine(et = %d buflen = %u)\n", (int)et, buflen);*/
-
-    assert(m != NULL);
-    assert(buf != NULL);
+    if (NULL == m || NULL == buf) {
+        cli_dbgmsg("decodeLine: invalid parameters\n");
+        return NULL;
+    }
 
     switch (et) {
         case BINARY:
             /*
-			 * TODO: find out what this is, encoded as binary??
-			 */
+             * TODO: find out what this is, encoded as binary??
+             */
             /* fall through */
         case NOENCODING:
         case EIGHTBIT:
@@ -1816,13 +1847,13 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
                 break;
             }
 
-            softbreak = FALSE;
+            softbreak = false;
             while (buflen && *line) {
                 if (*line == '=') {
                     unsigned char byte;
 
                     if ((*++line == '\0') || (*line == '\n')) {
-                        softbreak = TRUE;
+                        softbreak = true;
                         /* soft line break */
                         break;
                     }
@@ -1831,41 +1862,43 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
 
                     if ((*++line == '\0') || (*line == '\n')) {
                         /*
-						 * broken e-mail, not
-						 * adhering to RFC2045
-						 */
+                         * broken e-mail, not
+                         * adhering to RFC2045
+                         */
                         *buf++ = byte;
                         break;
                     }
 
                     /*
-					 * Handle messages that use a broken
-					 * quoted-printable encoding of
-					 * href=\"http://, instead of =3D
-					 */
+                     * Handle messages that use a broken
+                     * quoted-printable encoding of
+                     * href=\"http://, instead of =3D
+                     */
                     if (byte != '=')
                         byte = (byte << 4) | hex(*line);
                     else
                         line -= 2;
 
                     *buf++ = byte;
-                } else
+                } else {
                     *buf++ = *line;
+                }
                 ++line;
                 --buflen;
             }
-            if (!softbreak)
+            if (!softbreak) {
                 /* Put the new line back in */
                 *buf++ = '\n';
+            }
             break;
 
         case BASE64:
             if (line == NULL)
                 break;
             /*
-			 * RFC2045 sets the maximum length to 76 bytes
-			 * but many e-mail clients ignore that
-			 */
+             * RFC2045 sets the maximum length to 76 bytes
+             * but many e-mail clients ignore that
+             */
             if (strlen(line) < sizeof(base64buf)) {
                 strcpy(base64buf, line);
                 copy = base64buf;
@@ -1882,8 +1915,8 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
             sanitiseBase64(copy);
 
             /*
-			 * Klez doesn't always put "=" on the last line
-			 */
+             * Klez doesn't always put "=" on the last line
+             */
             buf = decode(m, copy, buf, base64, (p2 == NULL) && ((strlen(copy) & 3) == 0));
 
             if (copy != base64buf)
@@ -1891,7 +1924,8 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
             break;
 
         case UUENCODE:
-            assert(m->base64chars == 0);
+            if (0 != m->base64chars)
+                break;
 
             if ((line == NULL) || (*line == '\0')) /* empty line */
                 break;
@@ -1904,9 +1938,9 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
                 break;
 
             /*
-			 * reallen contains the number of bytes that were
-			 *	encoded
-			 */
+             * reallen contains the number of bytes that were
+             *    encoded
+             */
             reallen = (size_t)uudecode(*line++);
             if (reallen <= 0)
                 break;
@@ -1916,10 +1950,10 @@ decodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, s
 
             if ((len > buflen) || (reallen > len))
                 /*
-				 * In practice this should never occur since
-				 * the maximum length of a uuencoded line is
-				 * 62 characters
-				 */
+                 * In practice this should never occur since
+                 * the maximum length of a uuencoded line is
+                 * 62 characters
+                 */
                 cli_dbgmsg("uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\n");
             else {
                 (void)decode(m, line, buf, uudecode, (len & 3) == 0);
@@ -1981,8 +2015,8 @@ decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(
     unsigned char cb1, cb2, cb3; /* carried over from last line */
 
     /*cli_dbgmsg("decode %s (len %d isFast %d base64chars %d)\n", in,
-		in ? strlen(in) : 0,
-		isFast, m->base64chars);*/
+        in ? strlen(in) : 0,
+        isFast, m->base64chars);*/
 
     cb1 = cb2 = cb3 = '\0';
 
@@ -1995,10 +2029,13 @@ decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(
             /* FALLTHROUGH */
         case 1:
             cb1    = m->base64_1;
-            isFast = FALSE;
+            isFast = false;
             break;
         default:
-            assert(m->base64chars <= 3);
+            if (3 < m->base64chars) {
+                cli_errmsg("email message decode error: invalid base64chars value: %d\n", m->base64chars);
+                return out;
+            }
     }
 
     if (isFast)
@@ -2008,13 +2045,13 @@ decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(
             b2 = (*decoder)(*in++);
             b3 = (*decoder)(*in++);
             /*
-			 * Put this line here to help on some compilers which
-			 * can make use of some architecture's ability to
-			 * multiprocess when different variables can be
-			 * updated at the same time - here b3 is used in
-			 * one line, b1/b2 in the next and b4 in the next after
-			 * that, b3 and b4 rely on in but b1/b2 don't
-			 */
+             * Put this line here to help on some compilers which
+             * can make use of some architecture's ability to
+             * multiprocess when different variables can be
+             * updated at the same time - here b3 is used in
+             * one line, b1/b2 in the next and b4 in the next after
+             * that, b3 and b4 rely on in but b1/b2 don't
+             */
             *out++ = (b1 << 2) | ((b2 >> 4) & 0x3);
             b4     = (*decoder)(*in++);
             *out++ = (b2 << 4) | ((b3 >> 2) & 0xF);
@@ -2067,7 +2104,8 @@ decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(
                 *out++ = b1 << 2;
                 break;
             default:
-                assert(0);
+                cli_errmsg("email message decode error: invalid nbytes value: %d\n", nbytes);
+                return out;
         }
     } else
         while (*in) {
@@ -2117,14 +2155,17 @@ decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(
                     continue;
                 case 3:
                     m->base64_3 = b3;
+                    /* fall-through */
                 case 2:
                     m->base64_2 = b2;
+                    /* fall-through */
                 case 1:
                     m->base64_1    = b1;
                     m->base64chars = nbytes;
                     break;
                 default:
-                    assert(0);
+                    cli_errmsg("email message decode error: invalid nbytes value: %d\n", nbytes);
+                    return out;
             }
             break; /* nbytes != 4 => EOL */
         }
@@ -2143,9 +2184,9 @@ hex(char c)
     cli_dbgmsg("Illegal hex character '%c'\n", c);
 
     /*
-	 * Some mails (notably some spam) break RFC2045 by failing to encode
-	 * the '=' character
-	 */
+     * Some mails (notably some spam) break RFC2045 by failing to encode
+     * the '=' character
+     */
     return '=';
 }
 
@@ -2198,7 +2239,7 @@ void messageSetCTX(message *m, cli_ctx *ctx)
 
 int messageContainsVirus(const message *m)
 {
-    return m->isInfected ? TRUE : FALSE;
+    return m->isInfected ? true : false;
 }
 
 /*
@@ -2206,8 +2247,8 @@ int messageContainsVirus(const message *m)
  * deduping the message
  *
  * FIXME: this can take a long time. The real solution is for system admins
- *	to refrain from setting ulimits too low, then this routine won't be
- *	called
+ *    to refrain from setting ulimits too low, then this routine won't be
+ *    called
  */
 static void
 messageDedup(message *m)
@@ -2238,8 +2279,8 @@ messageDedup(message *m)
         if (r1 == 255)
             continue;
         /*
-		 * We don't want to foul up any pointers
-		 */
+         * We don't want to foul up any pointers
+         */
         if (t1 == m->encoding)
             continue;
         if (t1 == m->bounce)
@@ -2282,7 +2323,7 @@ messageDedup(message *m)
  * free, or NULL on error.
  *
  * TODO: Currently only handles paragraph 4 of RFC2231 e.g.
- *	 protocol*=ansi-x3.4-1968''application%2Fpgp-signature;
+ *     protocol*=ansi-x3.4-1968''application%2Fpgp-signature;
  */
 static char *
 rfc2231(const char *in)
@@ -2335,9 +2376,9 @@ rfc2231(const char *in)
     ptr = strstr(in, "*0=");
     if (ptr != NULL)
         /*
-		 * Parameter continuation, with no continuation
-		 * Thunderbird 1.5 (and possibly other versions) does this
-		 */
+         * Parameter continuation, with no continuation
+         * Thunderbird 1.5 (and possibly other versions) does this
+         */
         field = CONTENTS;
     else {
         ptr   = strstr(in, "*=");
@@ -2361,10 +2402,10 @@ rfc2231(const char *in)
     }
 
     /*
-	 * memcpy(out, in, (ptr - in));
-	 * out = &out[ptr - in];
-	 * in = ptr;
-	 */
+     * memcpy(out, in, (ptr - in));
+     * out = &out[ptr - in];
+     * in = ptr;
+     */
     out = ret;
     while (in != ptr)
         *out++ = *in++;
@@ -2374,9 +2415,9 @@ rfc2231(const char *in)
     while (*ptr++ != '=') continue;
 
     /*
-	 * We don't do anything with the language and character set, just skip
-	 * over them!
-	 */
+     * We don't do anything with the language and character set, just skip
+     * over them!
+     */
     while (*ptr) {
         switch (field) {
             case LANGUAGE:
@@ -2409,11 +2450,11 @@ rfc2231(const char *in)
         }
         if (*ptr++ == '\0')
             /*
-			 * Incorrect message that has just one character after
-			 * a '%'.
-			 * FIXME: stash something in out that would, for example
-			 *	treat %2 as %02, assuming field == CONTENTS
-			 */
+             * Incorrect message that has just one character after
+             * a '%'.
+             * FIXME: stash something in out that would, for example
+             *    treat %2 as %02, assuming field == CONTENTS
+             */
             break;
     }
 
@@ -2432,7 +2473,7 @@ rfc2231(const char *in)
 
 /*
  * common/simil:
- *	From Computing Magazine 20/8/92
+ *    From Computing Magazine 20/8/92
  * Returns %ge number from 0 to 100 - how similar are 2 strings?
  * 100 for exact match, < for error
  */
@@ -2524,7 +2565,7 @@ static unsigned int
 compare(char *ls1, char **rs1, char *ls2, char **rs2)
 {
     unsigned int common, maxchars = 0;
-    bool some_similarity = FALSE;
+    bool some_similarity = false;
     char *s1, *s2;
     char *maxs1 = NULL, *maxs2 = NULL, *maxe1 = NULL, *maxe2 = NULL;
     char *cs1, *cs2, *start1, *end1, *end2;
@@ -2540,7 +2581,7 @@ compare(char *ls1, char **rs1, char *ls2, char **rs2)
         if (s1 < end1) {
             while (s1 < end1 && s2 < end2) {
                 if (tolower(*s1) == tolower(*s2)) {
-                    some_similarity = TRUE;
+                    some_similarity = true;
                     cs1             = s1;
                     cs2             = s2;
                     common          = 0;
diff --git a/libclamav/message.h b/libclamav/message.h
index dd5052bda..a42e0aae0 100644
--- a/libclamav/message.h
+++ b/libclamav/message.h
@@ -33,8 +33,8 @@ typedef struct message {
     char **mimeArguments;
     char *mimeDispositionType; /* probably attachment */
     text *body_first, *body_last;
-    cli_ctx *ctx;          /* When set we can scan the message, otherwise NULL */
-    int numberOfArguments; /* count of mimeArguments */
+    cli_ctx *ctx;             /* When set we can scan the message, otherwise NULL */
+    size_t numberOfArguments; /* count of mimeArguments */
     int base64chars;
 
     /*
@@ -74,7 +74,6 @@ void messageSetEncoding(message *m, const char *enctype);
 encoding_type messageGetEncoding(const message *m);
 int messageAddLine(message *m, line_t *line);
 int messageAddStr(message *m, const char *data);
-int messageAddStrAtTop(message *m, const char *data);
 int messageMoveText(message *m, text *t, message *old_message);
 text *messageGetBody(message *m);
 unsigned char *base64Flush(message *m, unsigned char *buf);
