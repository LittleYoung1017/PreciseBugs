ae26dddc1	28ed63e2c	Thu Jun 29 09:52:49 2023 +0100	oss-fuzz 60203/60204/60207: Fix mistakes in glyph_lenths table copying	commit ae26dddc15c9869864839853e87482468cab3db7Author: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Jun 29 09:48:35 2023 +0100    oss-fuzz 60203/60204/60207: Fix mistakes in glyph_lenths table copying        Two mistakes: I used TrueNumGlyphs when it should have been numGlyphs - the    former is the value read from the font, the latter is the value derived from    the size of the loca table, and loca table is where the glyph_lenths table is    derived from.        Secondly, the glyph_lengths table is actually one entry larger than the loca    table.
19d241ddb	4c3575346	Fri Nov 25 09:23:19 2022 +0000	oss-fuzz 53711: Fix thinko in pdfi cmap code	commit 19d241ddb9aa65370bd176522e6c3317bd3be64dAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Nov 24 17:38:29 2022 +0000    oss-fuzz 53711: Fix thinko in pdfi cmap code        When adding a range, copy the previous number of ranges multiplied by the size    of a range structure, rather than the previous number ranges bytes.
81c55ab19	361febcf9	Fri Sep 2 11:31:55 2022 +0100	oss-fuzz 50893: xpswrite: Fix order of operations freeing TIFF object	commit 81c55ab199af28abf7e405f1e3ab2e76608b116bAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Fri Sep 2 10:55:52 2022 +0100    oss-fuzz 50893: xpswrite: Fix order of operations freeing TIFF object        We can't free our libtiff "client data) until we've completed writing the TIFF    (which also frees the libtiff context), but having completed writing the TIFF,    we can no longer access our client data through the libtiff context.        We have to retrieve a pointer to our client data, complete the TIFF writing    process, then free our client data using the pointer we previously retrieved.
f522a50e6	fa1a910da	Tue Aug 23 09:26:02 2022 +0100	oss-fuzz 50527: Fix CIDtoGIDMap bounds check for CIDType2 fonts	commit f522a50e61c756930cd135116648b3b82baa33c9Author: Chris Liddell <chris.liddell@artifex.com>Date:   Tue Aug 23 09:05:51 2022 +0100    oss-fuzz 50527: Fix CIDtoGIDMap bounds check for CIDType2 fonts        in pdfi_cidtype2_get_glyph_index()
eba337936	71484d897	Fri Aug 19 15:06:13 2022 +0100	oss-fuzz 50326: Fix and use bounds check	commit eba3379360caec1d881d96c5d51ed4282278cd1fAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Aug 18 17:14:22 2022 +0100    oss-fuzz 50326: Fix and use bounds check        for Type 1/2 charstring executaion state stack. The bounds checking macro was    incorrect, and wasn't being used in the minimal CharString interpreter used    by pdfwrite and co.
2b3b754fe	be2dd7803	Mon Aug 15 15:40:06 2022 +0100	oss-fuzz 50099: Fix mistake in setting CFF data buffer limit	commit 2b3b754fe12591dc26309fc92fcefac12ca5a6afAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Aug 15 14:13:26 2022 +0100    oss-fuzz 50099: Fix mistake in setting CFF data buffer limit        for fdarray subfonts
941c74b06	4eaefcce1	Wed Aug 10 08:45:16 2022 +0100	Fonts - fix cleanup of copied fonts on error	commit 941c74b068dc50c89881f1092b409f8dbd7f583bAuthor: Ken Sharp <ken.sharp@artifex.com>Date:   Wed Aug 10 08:19:15 2022 +0100    Fonts - fix cleanup of copied fonts on error        Showed up with some of the OSS-fuzz tests which exhaust memory, when    run with pdfwrite. Example command line:        -K1048576 -r200x200 -sBandListStorage=memory -dMaxBitmap=0 -dBufferSpace=450k -dMediaPosition=1 -dcupsColorSpace=1 -dSAFER -dNOPAUSE -dBATCH -dNOINTERPOLATE -dNOMEDIAATTRS -sOutputFile=/temp/out.pdf -sDEVICE=pdfwrite D:\bugs\oss-fuzz\49803.pdf        The problem is that after we allocate the font structure for the copy    of the font, it will be finalized if we free it, so we need to set up    enough of the font immediately, in case we do free it, as noted in the    comment. But we were copying the UID from the source font and not    replacing it until much later.        If we were able to allocate the 'copied' font, but not able to allocate    one of the other structures (glyphs or cfdata) we would goto the fail    condition where we would try to free the 'copied' font. Because we had    not updated the UID this would then crash.        Fix it by moving the UID setup into the section where we initialise    'just enough' of the new font. If setting up the UID fails, then set    the UID to 'invalid' instead.
a94bc4791	d7ce0ca73	Mon Aug 8 14:33:10 2022 +0100	oss-fuzz 49719: Fix clist copy mono case where "source" wasn't set	commit a94bc479111782659c4f1d164d49f68863cee383Author: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Aug 8 12:22:33 2022 +0100    oss-fuzz 49719: Fix clist copy mono case where "source" wasn't set        by the reading code, so when the actual copy_mono device call happened, it    segfaulted.
e950d1fa3	e784b3314	Tue Jul 5 10:50:18 2022 +0100	oss-fuzz 48547/48528/48526: Various TTF hinter fixes	commit e950d1fa30cda37cae4cc0553a4d24135fc09695Author: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Jul 4 14:02:54 2022 +0100    oss-fuzz 48547/48528/48526: Various TTF hinter fixes        A couple of opcode functions in the bytecode interpreter were not bounds    checking the values they used.        If a bytcode execution context initialisation encountered an out of memory    error part way through, the remainder of the context would be left    uninitialised which could then lead to a later crash when cleaning up the    partially initialised context.
12532548a	a8a209fce	Tue May 3 11:48:29 2022 +0100	oss-fuzz 47157: Fix buffer limit for decoding pfb font streams	commit 12532548a94c94821da0238b84c04b918659eb4aAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Tue May 3 10:34:13 2022 +0100    oss-fuzz 47157: Fix buffer limit for decoding pfb font streams
479649281	7286646af	Tue Apr 19 10:32:43 2022 +0100	Bug 705221(redux): "Reverse" original fix	commit 479649281467ca84a220873d51c7a461b5a78104Author: Chris Liddell <chris.liddell@artifex.com>Date:   Tue Apr 19 10:32:43 2022 +0100    Bug 705221(redux): "Reverse" original fix        Original fix was to make the chunk freeing code to identify single object    chunks match the allocating code - i.e. both using the "padded" size.        This appears to cause confusion with other areas in the code, leading to    potential segfaults.        This reverses that change, so both the allocating and freeing code use the    unpadded size.        This still solves the memory explosion bug, but doesn't cause the issues    identified by oss-fuzz 46830 and 46734.        Ultimately it may be preferable to revise the rest of the code to avoid the    confusion, but this avoids a flood of issues from oss-fuzz.
dc67c64d6	eee28843b	Mon Mar 21 15:36:23 2022 -0700	Bug 705090 oss-fuzz #45892  Bug 705092 oss-fuzz #45823	commit dc67c64d6d61f5fa9b065c03cabd237d67158802Author: Michael Vrhel <michael.vrhel@artifex.com>Date:   Mon Mar 21 12:42:54 2022 -0700    Bug 705090 oss-fuzz #45892  Bug 705092 oss-fuzz #45823        If begin transparency group returns an error, do not set the    GroupPushed state variable to true.  Otherwise we will end    up doing an unmatched end group command later, leading to    the seg fault.
2345f9004	edb022508	Mon Mar 7 11:40:27 2022 +0000	Fix the VM attributes flags for the new PS device containers	commit 2345f9004657b76db451d3e814a9776c603ee62cAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Mar 7 10:57:44 2022 +0000    Fix the VM attributes flags for the new PS device containers        When PS refs referenced devices directly, for the prototype devices (which are    not allocated on the heap) the object was marked as VM mode "avm_foreign", thus    the garbager and save/restore would not attempt to do anything it.        Now the refs reference a container, which is always allocated on the heap, that    attribute flag always needs to be the prevailing PS VM mode.        Discovered while investigating oss-fuzz: 45320
b1b4e7de1	f9e58379f	Wed Jan 19 11:02:00 2022 +0000	pdfi: Fix font memory leak with "internall" set font	commit b1b4e7de1823e46df6f49a11856595bf313637f2Author: Chris Liddell <chris.liddell@artifex.com>Date:   Wed Jan 19 11:02:00 2022 +0000    pdfi: Fix font memory leak with "internall" set font        For annotations, we may load and set a font via a different code path than the    normal, input file driven path. That needed updated to not leak now the font    is tracked directly by the graphics state.        Noticed when debugging oss-fuzz issue 43565.
f4f1797aa	7b13094ee	Tue Jan 18 11:09:09 2022 +0000	GhostPDF - Fix PostScript cleanup on error in showpage	commit f4f1797aabba7c931903eacbd78003d006770c7dAuthor: Ken Sharp <ken.sharp@artifex.com>Date:   Tue Jan 18 11:07:59 2022 +0000    GhostPDF - Fix PostScript cleanup on error in showpage        Michael ran across this under a different set of conditions. For me        -K1048576 -r200x200 -sBandListStorage=memory -dMaxBitmap=0 -dBufferSpace=450k -dMediaPosition=1 -dcupsColorSpace=1 -dSAFER -dNOPAUSE -dBATCH -dNOINTERPOLATE -dNOMEDIAATTRS -sOutputFile=/temp/out.tif -sDEVICE=tiff24nc /bugs/oss-fuzz/42920.pdf        Using the file from OSS-fuzz bug 42920.pdf, with a 64-bit debug build    on Windows led to an error on closing the interpreter because we were    finalizing the input file twice. I'm not entirely certain why, but    putting the showpage in a stopped context so that if it fails we carry    on and clean up properly resolves it for me.
77a0642a5	d77057eb8	Thu Jan 13 13:34:48 2022 +0000	Fix error code propagation from CMap reading code	commit 77a0642a5a3b07f864109e1d1b2718403e7e2ae3Author: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Jan 13 13:29:41 2022 +0000    Fix error code propagation from CMap reading code        Arose from oss-fuzz issue 43147, but exhibits differently, so may not be the    same issue.
f7dc95261	8bd3f7dba	Mon Jan 10 14:42:32 2022 +0000	oss-fuzz 43156: ensure CMap prefix and key values fit before writing	commit f7dc952613f4e614fae5fe859a5b6a90e3e17bf7Author: Chris Liddell <chris.liddell@artifex.com>Date:   Fri Jan 7 14:29:43 2022 +0000    oss-fuzz 43156: ensure CMap prefix and key values fit before writing        the graphics lib uses a hard coded limit for the size of the prefix and key    values, so check we don't overflow them.
a78a6db2d	1a3c64e7a	Thu Dec 16 15:14:28 2021 +0000	oss-fuzz 42310: Fix validation of CFF CIDFont charstring length	commit a78a6db2d1f411c2aa76ea3c0f025cc31f117469Author: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Dec 16 15:14:28 2021 +0000    oss-fuzz 42310: Fix validation of CFF CIDFont charstring length
1a3c64e7a	2bb92f8d5	Thu Dec 16 15:13:53 2021 +0000	oss-fuzz 42444: Fix broken stack indexing	commit 1a3c64e7a65025ea024bd65cc726b6ec5dd0e172Author: Chris Liddell <chris.liddell@artifex.com>Date:   Thu Dec 16 15:06:23 2021 +0000    oss-fuzz 42444: Fix broken stack indexing        when creating a code space range
a5dd7e733	a7f2474c5	Tue Dec 14 15:33:09 2021 +0000	oss-fuzz 42372: Fix validation of number of d1 operands	commit a5dd7e7333eddef2fa41bf317edd54d15936c342Author: Chris Liddell <chris.liddell@artifex.com>Date:   Tue Dec 14 14:24:52 2021 +0000    oss-fuzz 42372: Fix validation of number of d1 operands
82b097fe8	991a95ff4	Tue Dec 14 13:24:20 2021 +0000	oss-fuzz 42266: Fix number of entries when searching a table	commit 82b097fe8e76ea92f69ef483f45c0cf491a98d43Author: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Dec 13 13:30:52 2021 +0000    oss-fuzz 42266: Fix number of entries when searching a table
bd56e2ddd	a67318453	Thu Jun 10 11:01:51 2021 +0100	Bug 703911: Erroneous freeing of stream string buffer	commit bd56e2ddd62e5706dfafdfe817d71e6d27a7fe49Author: Chris Liddell <chris.liddell@artifex.com>Date:   Fri Jun 4 16:45:56 2021 +0100    Bug 703911: Erroneous freeing of stream string buffer        Previously, s_close_filters() would close and free all the streams    in a chain, including the lowest level source stream. If that stream    was a string object based stream, s_close_filters() would also free    that string buffer.        On the other hand, it is far from obvious to calling code that    the lowest level stream was memory buffer based, and equally difficult    for the calling code to retrieve that buffer for itself.        So, make two cases:    sread_string(): This sets up the stream for cases where the caller    retains ownership of the buffer - as in the case where the buffer    comes from a Postscript string object (where ownership is retained    by Postscript VM). Thus s_close_filters() will not free the buffer.        and:        sread_transient_string(): This sets up the stream, transferring    ownership of the buffer to stream. In which case s_close_filters()    will free the buffer.        Comes from:    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=34459&q=ghostscript&can=2
7e1687689	2a3129365	Thu Jun 3 13:19:09 2021 +0100	Fix uses of pop() vs ref_stack_pop(()	commit 7e1687689389b053ec762ac8c41fe79775537256Author: Chris Liddell <chris.liddell@artifex.com>Date:   Wed Jun 2 10:10:05 2021 +0100    Fix uses of pop() vs ref_stack_pop(()        The pop() macro is very simple: all it does is decrement the pointer for top    of the operand stack - it does no stack limit checking and, more importantly,    it has no capability to cope with stack extension blocks.        Since the main interpreter loop has to do its own stack limit checking, and    handle the extension blocks, it would be wasteful for each operator to do so,    too. So the intention is that pop() is only called immediately before returning    to the interpreter loop, setting the point, but leaving the interpreter loop to    cope with error conditions or extension blocks.        Over the years, various cases have crept in with pop() being used in places    that are not immediately before a return to the interpreter loop and, in    several cases, are before other code that also accesses the stack, causing    potential problems - not least, two (so far) oss-fuzz issues.        So review uses of pop() and change the bad ones to ref_stack_pop() (which does    bounds checking and extension block handling). Also change a few uses of    ref_stack_pop() to pop().        There are a couple of exceptions: one in the inner tokenizing code, where    a) performance is important, and b) (I think!) the use of the stack is a    "closed system" - it only pushes or pops for it's own purpose, so should be    safe.        And at least one place where we use pop() in the middle of a function, but we    can safely do so because before anything else happens that might access the    stack, it's been changed to call ref_stack_pop() or ref_stack_push(), which will    take care of any mess left by pop().        This review was "inspired" by:    https://bugs.ghostscript.com/show_bug.cgi?id=703902        but is not directly fixing that bug.
2a3129365	25b8457be	Thu Jun 3 13:19:09 2021 +0100	Bug 703902: Fix op stack management in sampled_data_continue()	commit 2a3129365d3bc0d4a41f107ef175920d1505d1f7Author: Chris Liddell <chris.liddell@artifex.com>Date:   Tue Jun 1 19:57:16 2021 +0100    Bug 703902: Fix op stack management in sampled_data_continue()        Replace pop() (which does no checking, and doesn't handle stack extension    blocks) with ref_stack_pop() which does do all that.        We still use pop() in one case (it's faster), but we have to later use    ref_stack_pop() before calling sampled_data_sample() which also accesses the    op stack.        Fixes:    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=34675
9c7347c8e	2c7a78d3e	Mon Feb 22 10:00:22 2021 +0000	Bug 703326: Create a new clip path for clist typed image handling	commit 9c7347c8e1bb146b9ae27b35b8207e10a7c5dc43Author: Chris Liddell <chris.liddell@artifex.com>Date:   Wed Feb 10 09:35:39 2021 +0000    Bug 703326: Create a new clip path for clist typed image handling        Stupid fuzzing file uses a Type 3 font with a sampled image in the glyph    proc. The image uses a procedure as a data source. The glyph proc does    gsave, and the image data source procedure does a grestore. So by the time we    clean up the image "samples", the gstate and the clip path it contains have    gone. So the image enumerator's reference to the clip path is left dangling.        Copying, rather than referencing, that clip path solves the crash.        Fixes oss-fuzz issue: 26987
bbd106e8f	42480ab92	Mon Sep 21 22:16:34 2020 +0100	oss-fuzz 23637: Fix error code confusion	commit bbd106e8f9345296cb5b5a452487bda603d54173Author: Chris Liddell <chris.liddell@artifex.com>Date:   Mon Sep 21 22:16:34 2020 +0100    oss-fuzz 23637: Fix error code confusion        Confusion of error codes meant we were allocating space for glyph data,    but never copying the data into it. Thus the memory sanitizer error.
560ff82b0	7502a26f0	Fri Jun 5 14:52:57 2020 +0100	Fix a bounds check in FAPI	commit 560ff82b0bc782465aa4591b2953954d7cf5608cAuthor: Chris Liddell <chris.liddell@artifex.com>Date:   Fri Jun 5 14:51:00 2020 +0100    Fix a bounds check in FAPI        Using less than or equal to should have been less than.        Found while investigating an oss-fuzz issue.
6238141c4	a0421f035	Sat Feb 9 01:27:44 2019 +0100	Bug 700384: Indicate error upon error, do not just warn.	commit 6238141c4564df091515fac92e3c35275d5ce26fAuthor: Sebastian Rasmussen <sebras@gmail.com>Date:   Fri Dec 7 18:12:23 2018 +0100    Bug 700384: Indicate error upon error, do not just warn.        Building a Huffman table failed, this was correctly detected,    but success was indicated to the caller causing a reference    template to be left uninitialized, which later on caused the    generic refinement region decoder attempt to use this    uninitialized data. This was reported by MSAN.        Thanks to oss-fuzz for reporting.
032603f3c	343366cf2	Tue Aug 28 23:32:46 2018 +0800	Bug 699673: jbig2dec: Initialize return code for all cases.	commit 032603f3c5448fc32609c51c932d11529eb6b581Author: Sebastian Rasmussen <sebras@gmail.com>Date:   Sun Aug 26 15:16:46 2018 +0800    Bug 699673: jbig2dec: Initialize return code for all cases.        Thanks to oss-fuzz for reporting.
