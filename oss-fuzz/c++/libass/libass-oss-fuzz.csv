libass-20201027-0171374	0171374	d149636	Tue Oct 27 15:50:23 2020 +0200	decode_font: fix subtraction broken by change to unsigned type	commit 017137471d0043e0321e377ed8da48e45a3ec632Author: Oleg Oshmyan <chortos@inbox.lv>Date:   Tue Oct 27 15:46:04 2020 +0200    decode_font: fix subtraction broken by change to unsigned type        This caused a one-byte buffer overwrite and an assertion failure.        Regression in commit 910211f1c0078e37546f73e95306724358b89be2.        Discovered by OSS-Fuzz.        Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26674.    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26678.	26674	libass/ass.c	857;871
libass-20201018-b06e297	b06e297	84928b1	Sun Oct 18 05:01:31 2020 +0300	Fix integer overflow while parsing \\fad(arg, large negative number)	commit b06e2975240de9aca03dd6af5c45bee964678ec4Author: Oleg Oshmyan <chortos@inbox.lv>Date:   Sat Feb 4 01:05:29 2017 +0200    Fix integer overflow while parsing \fad(arg, large negative number)        If t3 is initially negative, it should be set to a value larger    than the duration of the event. This triggers the `now < t3` branch    in interpolate_alpha (if none of the earlier branches are taken).    The same effect can be achieved by setting t3 to the duration itself.        Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=531.    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3905.    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11736.	531	libass/ass_parse.c	603
libass-20170510-4cf8d6b	4cf8d6b	f2832a0	Wed May 10 13:45:31 2017 +0200	Fix PlayResX/Y calculations	commit 4cf8d6bb3e6b75f8215b69f697b6b5c05b1c1dd2Author: Grigori Goronzy <greg@chown.ath.cx>Date:   Wed May 10 13:39:57 2017 +0200    Fix PlayResX/Y calculations        Avoid that PlayResY is set to 0 when only PlayResX is specified and    set to 1. Setting PlayResY to 0 results in divide-by-zero errors.    Also fix PlayResX calculations in case only PlayResY is specified,    for completeness.        Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1474.	1474	libass/ass.c	1345;1353
libass-20170214-c946ae4	c946ae4	92c3597	Tue Feb 14 19:43:41 2017 +0200	Fix decode_font when size % 4 != 0 or data contains illegal bytes	commit c946ae4fba7fd2215470991de060ddfb08bcb856Author: Oleg Oshmyan <chortos@inbox.lv>Date:   Sat Feb 4 04:02:50 2017 +0200    Fix decode_font when size % 4 != 0 or data contains illegal bytes        When given a byte c, decode_chars expects that 0 <= c - 33 <= 63,    i. e. that only the six lowest bits of c - 33 are possibly set.    With this assumption, it shifts and adds together multiple c - 33 values.        When c > 96, c - 33 has high nonzero bits, which interferes with other    shifted terms. c < 33 is even worse: c - 33 is negative (if unsigned char    fits in int), and left-shifting negative numbers has undefined behavior.    Even before the shift, on common platforms with a two's complement    representation of negative integers (or if unsigned char does not fit in    int and is promoted to unsigned int), c - 33 has high nonzero bits, which    again interfere with other shifted terms.        To make matters worse, even perfectly valid encoded data is affected when    size % 4 != 0, as decode_font calls decode_chars with '\0', which leads    decode_chars to shift and add -33, causing undefined behavior and/or    incorrect output.        Take our cue from VSFilter and bit-mask c - 33 to keep only the six    relevant bits. To ensure that we get the same bits as VSFilter when    c < 33 and to avoid the undefined behavior of left-shifting negative    numbers, convert the number to unsigned before masking and shifting.        While we are at it, rewrite decode_chars entirely    to get rid of any GPL code from mkvtoolnix.        Related mkvtoolnix bug: https://github.com/mbunkus/mkvtoolnix/issues/1003        Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=516.        Also allocate exactly the right amount of memory for the font,    because why not.	516	libass/ass.c	659;696
libass-20170214-81ba39f	81ba39f	08092bd	Tue Feb 14 19:43:04 2017 +0200	Fix parsing of unusual Alignment values in ASS style definitions	commit 81ba39f0d28a9ea9d284b031517ebd0f2684d4ffAuthor: Oleg Oshmyan <chortos@inbox.lv>Date:   Fri Feb 3 21:34:13 2017 +0200    Fix parsing of unusual Alignment values in ASS style definitions        Handle large and negative values except INT32_MIN like VSFilter.    This avoids both overflow and inconsistent internal state.        This fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=523.        VSFilter handles INT32_MIN like a mix of \an1, \an2 and \an3:          * Vertical alignment is bottom.      * Lines within the event are center-aligned.      * Without \pos or \move, the center of the event is aligned        with the right edge of the screen minus MarginR.      * With \pos or \move, the left edge of the event is aligned        with the position point.      * Without \org, the rotation origin is aligned        with the horizontal center of the event.      * (With \org, the rotation origin is as specified.)        If we wanted to emulate this in libass, the cleanest way would be to    introduce a new horizontal alignment constant for this purpose that    would be used only for ASS style definitions with Alignment INT32_MIN.    This commit makes no attempt to do this and instead arbitrarily picks    \an2 for style definitions with Alignment -INT_MAX-1, which equals    INT32_MIN if int is int32_t. The fact that int is platform-dependent    is one of the reasons for this. We could change Alignment to be int32_t    instead of int for perfect VSFilter compatibility, but the same applies    to many other fields that currently use platform-dependent types.	523	libass/ass.c	24;241
libass-20161229-53fee08	53fee08	f221205	Thu Dec 29 00:37:38 2016 +0200	Fix memory leak when Language header is defined more than once	commit 53fee0874ab43ec53c62b3d5455a812b6d346506Author: Oleg Oshmyan <chortos@inbox.lv>Date:   Wed Dec 28 22:19:51 2016 +0200    Fix memory leak when Language header is defined more than once        Discovered by OSS-Fuzz.    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=229.	229	libass/ass.c	622
libass-20161229-3ebd194	3ebd194	ca0ea14	Thu Dec 29 00:36:38 2016 +0200	Fix buffer overread in parse_tag when end points to a space	commit 3ebd1945b44327450fec3fdd164f591921c3f281Author: Oleg Oshmyan <chortos@inbox.lv>Date:   Wed Dec 28 21:14:21 2016 +0200    Fix buffer overread in parse_tag when end points to a space        When parse_tag is invoked recursively to handle the animated tags inside    a \t tag, the `end` argument is taken from the `end` field of a struct arg    in the enclosing parse_tag. When struct arg is filled by push_arg, this    field is always right-trimmed using rskip_spaces. Ultimately, the inner    parse_tag invokation sees its `end` argument point not to the ')' or '}'    of the \t as it expects but rather to the spaces preceding the ')' or '}'.        At this point, when parse_tag calls skip_spaces, which is ignorant of the    end pointer, it happily skips over the spaces preceding the ')', moving the    pointer past `end`. Subsequent `pointer != end` comparisons in parse_tag    fail (as in fact `pointer > end`), and parse_tag thinks it is still inside    the substring to be parsed.        This is harmless in many cases, but given either of the following inputs,    parse_tag reads past the end of the actual buffer that stores the string:            {\t(\ }        {\t(\ )(}        After this commit, parse_tag knows that `end` can point to a sequence of    spaces and avoids calling skip_spaces on `end`, thus avoiding the overread.        Discovered by OSS-Fuzz.    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=194.	194	libass/ass_parse.c	262;272;293
