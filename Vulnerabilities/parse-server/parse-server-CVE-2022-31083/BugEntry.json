{"buggy_code": ["/**\n * Semantic Release Config\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Get env vars\nconst ref = process.env.GITHUB_REF;\nconst serverUrl = process.env.GITHUB_SERVER_URL;\nconst repository = process.env.GITHUB_REPOSITORY;\nconst repositoryUrl = serverUrl + '/' + repository;\n\n// Declare params\nconst resourcePath = './.releaserc/';\nconst templates = {\n  main: { file: 'template.hbs', text: undefined },\n  header: { file: 'header.hbs', text: undefined },\n  commit: { file: 'commit.hbs', text: undefined },\n  footer: { file: 'footer.hbs', text: undefined },\n};\n\n// Declare semantic config\nasync function config() {\n\n  // Get branch\n  const branch = ref.split('/').pop();\n  console.log(`Running on branch: ${branch}`);\n\n  // Set changelog file\n  const changelogFile = `./changelogs/CHANGELOG_${branch}.md`;\n  console.log(`Changelog file output to: ${changelogFile}`);\n\n  // Load template file contents\n  await loadTemplates();\n\n  const config = {\n    branches: [\n      'release',\n      { name: 'alpha', prerelease: true },\n      { name: 'beta', prerelease: true },\n      'next-major',\n      // Long-Term-Support branches\n      // { name: 'release-1', range: '1.x.x', channel: '1.x' },\n      // { name: 'release-2', range: '2.x.x', channel: '2.x' },\n      // { name: 'release-3', range: '3.x.x', channel: '3.x' },\n      // { name: 'release-4', range: '4.x.x', channel: '4.x' },\n    ],\n    dryRun: false,\n    debug: true,\n    ci: true,\n    tagFormat: '${version}',\n    plugins: [\n      ['@semantic-release/commit-analyzer', {\n        preset: 'angular',\n        releaseRules: [\n          { type: 'docs', scope: 'README', release: 'patch' },\n          { scope: 'no-release', release: false },\n        ],\n        parserOpts: {\n          noteKeywords: [ 'BREAKING CHANGE', 'BREAKING CHANGES', 'BREAKING' ],\n        },\n      }],\n      ['@semantic-release/release-notes-generator', {\n        preset: 'angular',\n        parserOpts: {\n          noteKeywords: ['BREAKING CHANGE', 'BREAKING CHANGES', 'BREAKING']\n        },\n        writerOpts: {\n          commitsSort: ['subject', 'scope'],\n          mainTemplate: templates.main.text,\n          headerPartial: templates.header.text,\n          commitPartial: templates.commit.text,\n          footerPartial: templates.footer.text,\n        },\n      }],\n      ['@semantic-release/changelog', {\n        'changelogFile': changelogFile,\n      }],\n      ['@semantic-release/npm', {\n        'npmPublish': true,\n      }],\n      ['@semantic-release/git', {\n        assets: [changelogFile, 'package.json', 'package-lock.json', 'npm-shrinkwrap.json'],\n      }],\n      [\n        \"@saithodev/semantic-release-backmerge\",\n        {\n          \"branches\": [\n            { from: \"beta\", to: \"alpha\" },\n            { from: \"release\", to: \"beta\" },\n            { from: \"release\", to: \"alpha\" },\n          ]\n        }\n      ],\n      ['@semantic-release/github', {\n        successComment: getReleaseComment(),\n        labels: ['type:ci'],\n        releasedLabels: ['state:released<%= nextRelease.channel ? `-\\${nextRelease.channel}` : \"\" %>']\n      }],\n    ],\n  };\n\n  return config;\n}\n\nasync function loadTemplates() {\n  for (const template of Object.keys(templates)) {\n    const text = await readFile(path.resolve(__dirname, resourcePath, templates[template].file));\n    templates[template].text = text;\n  }\n}\n\nasync function readFile(filePath) {\n  return await fs.readFile(filePath, 'utf-8');\n}\n\nfunction getReleaseComment() {\n  const url = repositoryUrl + '/releases/tag/${nextRelease.gitTag}';\n  const comment = '\ud83c\udf89 This change has been released in version [${nextRelease.version}](' + url + ')';\n  return comment;\n}\n\nmodule.exports = config();\n", "const request = require('../lib/request');\nconst Config = require('../lib/Config');\nconst defaultColumns = require('../lib/Controllers/SchemaController').defaultColumns;\nconst authenticationLoader = require('../lib/Adapters/Auth');\nconst path = require('path');\nconst responses = {\n  gpgames: { playerId: 'userId' },\n  instagram: { id: 'userId' },\n  janrainengage: { stat: 'ok', profile: { identifier: 'userId' } },\n  janraincapture: { stat: 'ok', result: 'userId' },\n  line: { userId: 'userId' },\n  vkontakte: { response: [{ id: 'userId' }] },\n  google: { sub: 'userId' },\n  wechat: { errcode: 0 },\n  weibo: { uid: 'userId' },\n  qq: 'callback( {\"openid\":\"userId\"} );', // yes it's like that, run eval in the client :P\n  phantauth: { sub: 'userId' },\n  microsoft: { id: 'userId', mail: 'userMail' },\n};\n\ndescribe('AuthenticationProviders', function () {\n  [\n    'apple',\n    'gcenter',\n    'gpgames',\n    'facebook',\n    'github',\n    'instagram',\n    'google',\n    'linkedin',\n    'meetup',\n    'twitter',\n    'janrainengage',\n    'janraincapture',\n    'line',\n    'vkontakte',\n    'qq',\n    'spotify',\n    'wechat',\n    'weibo',\n    'phantauth',\n    'microsoft',\n    'keycloak',\n  ].map(function (providerName) {\n    it('Should validate structure of ' + providerName, done => {\n      const provider = require('../lib/Adapters/Auth/' + providerName);\n      jequal(typeof provider.validateAuthData, 'function');\n      jequal(typeof provider.validateAppId, 'function');\n      const validateAuthDataPromise = provider.validateAuthData({}, {});\n      const validateAppIdPromise = provider.validateAppId('app', 'key', {});\n      jequal(validateAuthDataPromise.constructor, Promise.prototype.constructor);\n      jequal(validateAppIdPromise.constructor, Promise.prototype.constructor);\n      validateAuthDataPromise.then(\n        () => {},\n        () => {}\n      );\n      validateAppIdPromise.then(\n        () => {},\n        () => {}\n      );\n      done();\n    });\n\n    it(`should provide the right responses for adapter ${providerName}`, async () => {\n      const noResponse = ['twitter', 'apple', 'gcenter', 'google', 'keycloak'];\n      if (noResponse.includes(providerName)) {\n        return;\n      }\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'get').and.callFake(options => {\n        if (\n          options ===\n            'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.123&grant_type=client_credentials' ||\n          options ===\n            'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.124&grant_type=client_credentials'\n        ) {\n          return {\n            access_token: 'access_token',\n          };\n        }\n        return Promise.resolve(responses[providerName] || { id: 'userId' });\n      });\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'request').and.callFake(() => {\n        return Promise.resolve(responses[providerName] || { id: 'userId' });\n      });\n      const provider = require('../lib/Adapters/Auth/' + providerName);\n      let params = {};\n      if (providerName === 'vkontakte') {\n        params = {\n          appIds: 'appId',\n          appSecret: 'appSecret',\n        };\n        await provider.validateAuthData({ id: 'userId' }, params);\n        params.appVersion = '5.123';\n      }\n      await provider.validateAuthData({ id: 'userId' }, params);\n    });\n  });\n\n  const getMockMyOauthProvider = function () {\n    return {\n      authData: {\n        id: '12345',\n        access_token: '12345',\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'myoauth';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  Parse.User.extend({\n    extended: function () {\n      return true;\n    },\n  });\n\n  const createOAuthUser = function (callback) {\n    return createOAuthUserWithSessionToken(undefined, callback);\n  };\n\n  const createOAuthUserWithSessionToken = function (token, callback) {\n    const jsonBody = {\n      authData: {\n        myoauth: getMockMyOauthProvider().authData,\n      },\n    };\n\n    const options = {\n      method: 'POST',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Installation-Id': 'yolo',\n        'X-Parse-Session-Token': token,\n        'Content-Type': 'application/json',\n      },\n      url: 'http://localhost:8378/1/users',\n      body: jsonBody,\n    };\n    return request(options)\n      .then(response => {\n        if (callback) {\n          callback(null, response, response.data);\n        }\n        return {\n          res: response,\n          body: response.data,\n        };\n      })\n      .catch(error => {\n        if (callback) {\n          callback(error);\n        }\n        throw error;\n      });\n  };\n\n  it('should create user with REST API', done => {\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      ok(b.sessionToken);\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      const sessionToken = b.sessionToken;\n      const q = new Parse.Query('_Session');\n      q.equalTo('sessionToken', sessionToken);\n      q.first({ useMasterKey: true })\n        .then(res => {\n          if (!res) {\n            fail('should not fail fetching the session');\n            done();\n            return;\n          }\n          expect(res.get('installationId')).toEqual('yolo');\n          done();\n        })\n        .catch(() => {\n          fail('should not fail fetching the session');\n          done();\n        });\n    });\n  });\n\n  it('should only create a single user with REST API', done => {\n    let objectId;\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      objectId = b.objectId;\n\n      createOAuthUser((error, response, body) => {\n        expect(error).toBe(null);\n        const b = body;\n        expect(b.objectId).not.toBeNull();\n        expect(b.objectId).not.toBeUndefined();\n        expect(b.objectId).toBe(objectId);\n        done();\n      });\n    });\n  });\n\n  it(\"should fail to link if session token don't match user\", done => {\n    Parse.User.signUp('myUser', 'password')\n      .then(user => {\n        return createOAuthUserWithSessionToken(user.getSessionToken());\n      })\n      .then(() => {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.signUp('myUser2', 'password');\n      })\n      .then(user => {\n        return createOAuthUserWithSessionToken(user.getSessionToken());\n      })\n      .then(fail, ({ data }) => {\n        expect(data.code).toBe(208);\n        expect(data.error).toBe('this auth is already used');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('unlink and link with custom provider', async () => {\n    const provider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('myoauth');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n\n    await model._unlinkFrom('myoauth');\n    ok(!model._isLinked('myoauth'), 'User should not be linked to myoauth');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n    // make sure the auth data is properly deleted\n    const config = Config.get(Parse.applicationId);\n    const res = await config.database.adapter.find(\n      '_User',\n      {\n        fields: Object.assign({}, defaultColumns._Default, defaultColumns._Installation),\n      },\n      { objectId: model.id },\n      {}\n    );\n    expect(res.length).toBe(1);\n    expect(res[0]._auth_data_myoauth).toBeUndefined();\n    expect(res[0]._auth_data_myoauth).not.toBeNull();\n\n    await model._linkWith('myoauth');\n\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n  });\n\n  function validateValidator(validator) {\n    expect(typeof validator).toBe('function');\n  }\n\n  function validateAuthenticationHandler(authenticationHandler) {\n    expect(authenticationHandler).not.toBeUndefined();\n    expect(typeof authenticationHandler.getValidatorForProvider).toBe('function');\n    expect(typeof authenticationHandler.getValidatorForProvider).toBe('function');\n  }\n\n  function validateAuthenticationAdapter(authAdapter) {\n    expect(authAdapter).not.toBeUndefined();\n    if (!authAdapter) {\n      return;\n    }\n    expect(typeof authAdapter.validateAuthData).toBe('function');\n    expect(typeof authAdapter.validateAppId).toBe('function');\n  }\n\n  it('properly loads custom adapter', done => {\n    const validAuthData = {\n      id: 'hello',\n      token: 'world',\n    };\n    const adapter = {\n      validateAppId: function () {\n        return Promise.resolve();\n      },\n      validateAuthData: function (authData) {\n        if (authData.id == validAuthData.id && authData.token == validAuthData.token) {\n          return Promise.resolve();\n        }\n        return Promise.reject();\n      },\n    };\n\n    const authDataSpy = spyOn(adapter, 'validateAuthData').and.callThrough();\n    const appIdSpy = spyOn(adapter, 'validateAppId').and.callThrough();\n\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: adapter,\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator(validAuthData).then(\n      () => {\n        expect(authDataSpy).toHaveBeenCalled();\n        // AppIds are not provided in the adapter, should not be called\n        expect(appIdSpy).not.toHaveBeenCalled();\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads custom adapter module object', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: path.resolve('./spec/support/CustomAuth.js'),\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator({\n      token: 'my-token',\n    }).then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads custom adapter module object (again)', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: {\n        module: path.resolve('./spec/support/CustomAuthFunction.js'),\n        options: { token: 'valid-token' },\n      },\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator({\n      token: 'valid-token',\n    }).then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads a default adapter with options', () => {\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'facebook',\n      options\n    );\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.facebook);\n  });\n\n  it('should handle Facebook appSecret for validating appIds', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'a' });\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce',\n      },\n    };\n    const authData = {\n      access_token: 'badtoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'facebook',\n      options\n    );\n    await adapter.validateAppId(appIds, authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });\n\n  it('should handle Facebook appSecret for validating auth data', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve();\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce',\n      },\n    };\n    const authData = {\n      id: 'test',\n      access_token: 'test',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('facebook', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });\n\n  it('properly loads a custom adapter with options', () => {\n    const options = {\n      custom: {\n        validateAppId: () => {},\n        validateAuthData: () => {},\n        appIds: ['a', 'b'],\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'custom',\n      options\n    );\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.custom);\n  });\n});\n\ndescribe('instagram auth adapter', () => {\n  const instagram = require('../lib/Adapters/Auth/instagram');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('should use default api', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ data: { id: 'userId' } });\n    });\n    await instagram.validateAuthData({ id: 'userId', access_token: 'the_token' }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://graph.instagram.com/me?fields=id&access_token=the_token'\n    );\n  });\n  it('response object without data child', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'userId' });\n    });\n    await instagram.validateAuthData({ id: 'userId', access_token: 'the_token' }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://graph.instagram.com/me?fields=id&access_token=the_token'\n    );\n  });\n  it('should pass in api url', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ data: { id: 'userId' } });\n    });\n    await instagram.validateAuthData(\n      {\n        id: 'userId',\n        access_token: 'the_token',\n        apiURL: 'https://new-api.instagram.com/v1/',\n      },\n      {}\n    );\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://new-api.instagram.com/v1/me?fields=id&access_token=the_token'\n    );\n  });\n});\n\ndescribe('google auth adapter', () => {\n  const google = require('../lib/Adapters/Auth/google');\n  const jwt = require('jsonwebtoken');\n\n  it('should throw error with missing id_token', async () => {\n    try {\n      await google.validateAuthData({}, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await google.validateAuthData({ id: 'the_user_id', id_token: 'the_token' }, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  // it('should throw error if public key used to encode token is not available', async () => {\n  //   const fakeDecodedToken = { header: { kid: '789', alg: 'RS256' } };\n  //   try {\n  //     spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n  //     await google.validateAuthData({ id: 'the_user_id', id_token: 'the_token' }, {});\n  //     fail();\n  //   } catch (e) {\n  //     expect(e.message).toBe(\n  //       `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n  //     );\n  //   }\n  // });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await google.validateAuthData(\n      { id: 'the_user_id', id_token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.google.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'the_user_id', id_token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct provider - expected: accounts.google.com or https://accounts.google.com | from: https://not.google.com'\n      );\n    }\n  });\n\n  xit('(using client id as string) should throw error with invalid jwt client_id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  xit('should throw error with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'invalid user', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n\ndescribe('google play games service auth', () => {\n  const gpgames = require('../lib/Adapters/Auth/gpgames');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should pass validation', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ playerId: 'userId' });\n    });\n    await gpgames.validateAuthData({\n      id: 'userId',\n      access_token: 'access_token',\n    });\n  });\n\n  it('validateAuthData should throw error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ playerId: 'invalid' });\n    });\n    try {\n      await gpgames.validateAuthData({\n        id: 'userId',\n        access_token: 'access_token',\n      });\n    } catch (e) {\n      expect(e.message).toBe('Google Play Games Services - authData is invalid for this user.');\n    }\n  });\n});\n\ndescribe('keycloak auth adapter', () => {\n  const keycloak = require('../lib/Adapters/Auth/keycloak');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should fail without access token', async () => {\n    const authData = {\n      id: 'fakeid',\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });\n\n  it('validateAuthData should fail without user id', async () => {\n    const authData = {\n      access_token: 'sometoken',\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });\n\n  it('validateAuthData should fail without config', async () => {\n    const options = {\n      keycloak: {\n        config: null,\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing keycloak configuration');\n    }\n  });\n\n  it('validateAuthData should fail connect error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({ error: 'hosting_error' }),\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Could not connect to the authentication server');\n    }\n  });\n\n  it('validateAuthData should fail with error description', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({ error_description: 'custom error message' }),\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('custom error message');\n    }\n  });\n\n  it('validateAuthData should fail with invalid auth', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should fail with invalid groups', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['unknown'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should fail with invalid roles', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: 'unknown',\n          groups: ['group1'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should handle authentication', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['group1'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get).toHaveBeenCalledWith({\n      host: 'http://example.com',\n      path: '/realms/new/protocol/openid-connect/userinfo',\n      headers: {\n        Authorization: 'Bearer sometoken',\n      },\n    });\n  });\n});\n\ndescribe('oauth2 auth adapter', () => {\n  const oauth2 = require('../lib/Adapters/Auth/oauth2');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('properly loads OAuth2 adapter via the \"oauth2\" option', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n      },\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    expect(loadedAuthAdapter.adapter).toEqual(oauth2);\n  });\n\n  it('properly loads OAuth2 adapter with options', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n        debug: true,\n      },\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    const appIds = loadedAuthAdapter.appIds;\n    const providerOptions = loadedAuthAdapter.providerOptions;\n    expect(providerOptions.tokenIntrospectionEndpointUrl).toEqual('https://example.com/introspect');\n    expect(providerOptions.useridField).toEqual('sub');\n    expect(providerOptions.appidField).toEqual('appId');\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions.authorizationHeader).toEqual('Basic dXNlcm5hbWU6cGFzc3dvcmQ=');\n    expect(providerOptions.debug).toEqual(true);\n  });\n\n  it('validateAppId should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        appIds: ['a', 'b'],\n        appidField: 'appId',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 token introspection endpoint URL is missing from configuration!'\n      );\n    }\n  });\n\n  it('validateAppId appidField optional', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not reach here\n      fail(e);\n    }\n  });\n\n  it('validateAppId should fail without appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).'\n      );\n    }\n  });\n\n  it('validateAppId should fail empty appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: [],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).'\n      );\n    }\n  });\n\n  it('validateAppId invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n  });\n\n  it('validateAppId invalid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({ active: true });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        \"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\"\n      );\n    }\n  });\n\n  it('validateAppId valid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'a',\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n\n  it('validateAppId valid accessToken appId array', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: ['a'],\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n\n  it('validateAppId valid accessToken invalid appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'unknown',\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        \"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\"\n      );\n    }\n  });\n\n  it('validateAuthData should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 token introspection endpoint URL is missing from configuration!'\n      );\n    }\n  });\n\n  it('validateAuthData invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith(\n      {\n        hostname: 'example.com',\n        path: '/introspect',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': 15,\n          Authorization: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n        },\n      },\n      'token=sometoken'\n    );\n  });\n\n  it('validateAuthData valid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid',\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith(\n      {\n        hostname: 'example.com',\n        path: '/introspect',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': 15,\n        },\n      },\n      'token=sometoken'\n    );\n  });\n\n  it('validateAuthData valid accessToken without useridField', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid',\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n});\n\ndescribe('apple signin auth adapter', () => {\n  const apple = require('../lib/Adapters/Auth/apple');\n  const jwt = require('jsonwebtoken');\n  const util = require('util');\n\n  it('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, { clientId: 'secret' });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, { clientId: ['secret'] });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = { header: { kid: '789', alg: 'RS256' } };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n      );\n    }\n  });\n\n  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });\n\n  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });\n\n  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret', 'secret 123'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: ['INSERT CLIENT ID HERE'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('should throw error with invalid user id', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'invalid user', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n\n  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n\ndescribe('Apple Game Center Auth adapter', () => {\n  const gcenter = require('../lib/Adapters/Auth/gcenter');\n\n  it('validateAuthData should validate', async () => {\n    // real token is used\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer',\n      timestamp: 1565257031287,\n      signature:\n        'uqLBTr9Uex8zCpc1UQ1MIDMitb+HUat2Mah4Kw6AVLSGe0gGNJXlih2i5X+0ZwVY0S9zY2NHWi2gFjmhjt/4kxWGMkupqXX5H/qhE2m7hzox6lZJpH98ZEUbouWRfZX2ZhUlCkAX09oRNi7fI7mWL1/o88MaI/y6k6tLr14JTzmlxgdyhw+QRLxRPA6NuvUlRSJpyJ4aGtNH5/wHdKQWL8nUnFYiYmaY8R7IjzNxPfy8UJTUWmeZvMSgND4u8EjADPsz7ZtZyWAPi8kYcAb6M8k0jwLD3vrYCB8XXyO2RQb/FY2TM4zJuI7PzLlvvgOJXbbfVtHx7Evnm5NYoyzgzw==',\n      salt: 'DzqqrQ==',\n      bundleId: 'cloud.xtralife.gamecenterauth',\n    };\n\n    await gcenter.validateAuthData(authData);\n  });\n\n  it('validateAuthData invalid signature id', async () => {\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer',\n      timestamp: 1565257031287,\n      signature: '1234',\n      salt: 'DzqqrQ==',\n      bundleId: 'cloud.xtralife.gamecenterauth',\n    };\n\n    try {\n      await gcenter.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Apple Game Center - invalid signature');\n    }\n  });\n\n  it('validateAuthData invalid public key http url', async () => {\n    const publicKeyUrls = [\n      'example.com',\n      'http://static.gc.apple.com/public-key/gc-prod-4.cer',\n      'https://developer.apple.com/assets/elements/badges/download-on-the-app-store.svg',\n      'https://example.com/ \\\\.apple.com/public_key.cer',\n      'https://example.com/ &.apple.com/public_key.cer',\n    ];\n    await Promise.all(\n      publicKeyUrls.map(publicKeyUrl =>\n        expectAsync(\n          gcenter.validateAuthData({\n            id: 'G:1965586982',\n            timestamp: 1565257031287,\n            publicKeyUrl,\n            signature: '1234',\n            salt: 'DzqqrQ==',\n            bundleId: 'com.example.com',\n          })\n        ).toBeRejectedWith(\n          new Parse.Error(\n            Parse.Error.SCRIPT_FAILED,\n            `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n          )\n        )\n      )\n    );\n  });\n});\n\ndescribe('phant auth adapter', () => {\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should throw for invalid auth', async () => {\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter } = authenticationLoader.loadAuthAdapter('phantauth', {});\n\n    spyOn(httpsRequest, 'get').and.callFake(() => Promise.resolve({ sub: 'invalidID' }));\n    try {\n      await adapter.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('PhantAuth auth is invalid for this user.');\n    }\n  });\n});\n\ndescribe('microsoft graph auth adapter', () => {\n  const microsoft = require('../lib/Adapters/Auth/microsoft');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('should use access_token for validation is passed and responds with id and mail', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'userId', mail: 'userMail' });\n    });\n    await microsoft.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token',\n    });\n  });\n\n  it('should fail to validate Microsoft Graph auth with bad token', done => {\n    const authData = {\n      id: 'fake-id',\n      mail: 'fake@mail.com',\n      access_token: 'very.long.bad.token',\n    };\n    microsoft.validateAuthData(authData).then(done.fail, err => {\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(err.message).toBe('Microsoft Graph auth is invalid for this user.');\n      done();\n    });\n  });\n});\n\ndescribe('facebook limited auth adapter', () => {\n  const facebook = require('../lib/Adapters/Auth/facebook');\n  const jwt = require('jsonwebtoken');\n  const util = require('util');\n\n  // TODO: figure out a way to run this test alongside facebook classic tests\n  xit('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, { clientId: 'secret' });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });\n\n  // TODO: figure out a way to run this test alongside facebook classic tests\n  xit('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, { clientId: ['secret'] });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = {\n      header: { kid: '789', alg: 'RS256' },\n    };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n      );\n    }\n  });\n\n  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });\n\n  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });\n\n  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret', 'secret 123'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: ['INSERT CLIENT ID HERE'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('should throw error with invalid user id', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'invalid user',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n\n  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n", "Couldn't find the requested file /spec/support/cert/game_center.pem in parse-community/parse-server.", "/* Apple Game Center Auth\nhttps://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign#discussion\n\nconst authData = {\n  publicKeyUrl: 'https://valid.apple.com/public/timeout.cer',\n  timestamp: 1460981421303,\n  signature: 'PoDwf39DCN464B49jJCU0d9Y0J',\n  salt: 'saltST==',\n  bundleId: 'com.valid.app'\n  id: 'playerId',\n};\n*/\n\nconst { Parse } = require('parse/node');\nconst crypto = require('crypto');\nconst https = require('https');\n\nconst cache = {}; // (publicKey -> cert) cache\n\nfunction verifyPublicKeyUrl(publicKeyUrl) {\n  try {\n    const regex = /^https:\\/\\/(?:[-_A-Za-z0-9]+\\.){0,}apple\\.com\\/.*\\.cer$/;\n    return regex.test(publicKeyUrl);\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction convertX509CertToPEM(X509Cert) {\n  const pemPreFix = '-----BEGIN CERTIFICATE-----\\n';\n  const pemPostFix = '-----END CERTIFICATE-----';\n\n  const base64 = X509Cert;\n  const certBody = base64.match(new RegExp('.{0,64}', 'g')).join('\\n');\n\n  return pemPreFix + certBody + pemPostFix;\n}\n\nasync function getAppleCertificate(publicKeyUrl) {\n  if (!verifyPublicKeyUrl(publicKeyUrl)) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n    );\n  }\n  if (cache[publicKeyUrl]) {\n    return cache[publicKeyUrl];\n  }\n  const url = new URL(publicKeyUrl);\n  const headOptions = {\n    hostname: url.hostname,\n    path: url.pathname,\n    method: 'HEAD',\n  };\n  const headers = await new Promise((resolve, reject) =>\n    https.get(headOptions, res => resolve(res.headers)).on('error', reject)\n  );\n  if (\n    headers['content-type'] !== 'application/pkix-cert' ||\n    headers['content-length'] == null ||\n    headers['content-length'] > 10000\n  ) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n    );\n  }\n  return new Promise((resolve, reject) => {\n    https\n      .get(publicKeyUrl, res => {\n        let data = '';\n        res.on('data', chunk => {\n          data += chunk.toString('base64');\n        });\n        res.on('end', () => {\n          const cert = convertX509CertToPEM(data);\n          if (res.headers['cache-control']) {\n            var expire = res.headers['cache-control'].match(/max-age=([0-9]+)/);\n            if (expire) {\n              cache[publicKeyUrl] = cert;\n              // we'll expire the cache entry later, as per max-age\n              setTimeout(() => {\n                delete cache[publicKeyUrl];\n              }, parseInt(expire[1], 10) * 1000);\n            }\n          }\n          resolve(cert);\n        });\n      })\n      .on('error', reject);\n  });\n}\n\nfunction convertTimestampToBigEndian(timestamp) {\n  const buffer = Buffer.alloc(8);\n\n  const high = ~~(timestamp / 0xffffffff);\n  const low = timestamp % (0xffffffff + 0x1);\n\n  buffer.writeUInt32BE(parseInt(high, 10), 0);\n  buffer.writeUInt32BE(parseInt(low, 10), 4);\n\n  return buffer;\n}\n\nfunction verifySignature(publicKey, authData) {\n  const verifier = crypto.createVerify('sha256');\n  verifier.update(authData.playerId, 'utf8');\n  verifier.update(authData.bundleId, 'utf8');\n  verifier.update(convertTimestampToBigEndian(authData.timestamp));\n  verifier.update(authData.salt, 'base64');\n\n  if (!verifier.verify(publicKey, authData.signature, 'base64')) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Apple Game Center - invalid signature');\n  }\n}\n\n// Returns a promise that fulfills if this user id is valid.\nasync function validateAuthData(authData) {\n  if (!authData.id) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Apple Game Center - authData id missing');\n  }\n  authData.playerId = authData.id;\n  const publicKey = await getAppleCertificate(authData.publicKeyUrl);\n  return verifySignature(publicKey, authData);\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\nmodule.exports = {\n  validateAppId,\n  validateAuthData,\n};\n"], "fixing_code": ["/**\n * Semantic Release Config\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Get env vars\nconst ref = process.env.GITHUB_REF;\nconst serverUrl = process.env.GITHUB_SERVER_URL;\nconst repository = process.env.GITHUB_REPOSITORY;\nconst repositoryUrl = serverUrl + '/' + repository;\n\n// Declare params\nconst resourcePath = './.releaserc/';\nconst templates = {\n  main: { file: 'template.hbs', text: undefined },\n  header: { file: 'header.hbs', text: undefined },\n  commit: { file: 'commit.hbs', text: undefined },\n  footer: { file: 'footer.hbs', text: undefined },\n};\n\n// Declare semantic config\nasync function config() {\n\n  // Get branch\n  const branch = ref.split('/').pop();\n  console.log(`Running on branch: ${branch}`);\n\n  // Set changelog file\n  const changelogFile = `./changelogs/CHANGELOG_${branch}.md`;\n  console.log(`Changelog file output to: ${changelogFile}`);\n\n  // Load template file contents\n  await loadTemplates();\n\n  const config = {\n    branches: [\n      'release',\n      { name: 'alpha', prerelease: true },\n      { name: 'beta', prerelease: true },\n      'next-major',\n      // Long-Term-Support branches\n      // { name: 'release-1', range: '1.x.x', channel: '1.x' },\n      // { name: 'release-2', range: '2.x.x', channel: '2.x' },\n      // { name: 'release-3', range: '3.x.x', channel: '3.x' },\n      // { name: 'release-4', range: '4.x.x', channel: '4.x' },\n    ],\n    dryRun: false,\n    debug: true,\n    ci: true,\n    tagFormat: '${version}',\n    plugins: [\n      ['@semantic-release/commit-analyzer', {\n        preset: 'angular',\n        releaseRules: [\n          { type: 'docs', scope: 'README', release: 'patch' },\n          { scope: 'no-release', release: false },\n        ],\n        parserOpts: {\n          noteKeywords: [ 'BREAKING CHANGE', 'BREAKING CHANGES', 'BREAKING' ],\n        },\n      }],\n      ['@semantic-release/release-notes-generator', {\n        preset: 'angular',\n        parserOpts: {\n          noteKeywords: ['BREAKING CHANGE', 'BREAKING CHANGES', 'BREAKING']\n        },\n        writerOpts: {\n          commitsSort: ['subject', 'scope'],\n          mainTemplate: templates.main.text,\n          headerPartial: templates.header.text,\n          commitPartial: templates.commit.text,\n          footerPartial: templates.footer.text,\n        },\n      }],\n      ['@semantic-release/changelog', {\n        'changelogFile': changelogFile,\n      }],\n      ['@semantic-release/npm', {\n        'npmPublish': true,\n      }],\n      ['@semantic-release/git', {\n        assets: [changelogFile, 'package.json', 'package-lock.json', 'npm-shrinkwrap.json'],\n      }],\n      ['@semantic-release/github', {\n        successComment: getReleaseComment(),\n        labels: ['type:ci'],\n        releasedLabels: ['state:released<%= nextRelease.channel ? `-\\${nextRelease.channel}` : \"\" %>']\n      }],\n      [\n        \"@saithodev/semantic-release-backmerge\",\n        {\n          \"branches\": [\n            { from: \"beta\", to: \"alpha\" },\n            { from: \"release\", to: \"beta\" },\n          ]\n        }\n      ],\n    ],\n  };\n\n  return config;\n}\n\nasync function loadTemplates() {\n  for (const template of Object.keys(templates)) {\n    const text = await readFile(path.resolve(__dirname, resourcePath, templates[template].file));\n    templates[template].text = text;\n  }\n}\n\nasync function readFile(filePath) {\n  return await fs.readFile(filePath, 'utf-8');\n}\n\nfunction getReleaseComment() {\n  const url = repositoryUrl + '/releases/tag/${nextRelease.gitTag}';\n  const comment = '\ud83c\udf89 This change has been released in version [${nextRelease.version}](' + url + ')';\n  return comment;\n}\n\nmodule.exports = config();\n", "const request = require('../lib/request');\nconst Config = require('../lib/Config');\nconst defaultColumns = require('../lib/Controllers/SchemaController').defaultColumns;\nconst authenticationLoader = require('../lib/Adapters/Auth');\nconst path = require('path');\nconst responses = {\n  gpgames: { playerId: 'userId' },\n  instagram: { id: 'userId' },\n  janrainengage: { stat: 'ok', profile: { identifier: 'userId' } },\n  janraincapture: { stat: 'ok', result: 'userId' },\n  line: { userId: 'userId' },\n  vkontakte: { response: [{ id: 'userId' }] },\n  google: { sub: 'userId' },\n  wechat: { errcode: 0 },\n  weibo: { uid: 'userId' },\n  qq: 'callback( {\"openid\":\"userId\"} );', // yes it's like that, run eval in the client :P\n  phantauth: { sub: 'userId' },\n  microsoft: { id: 'userId', mail: 'userMail' },\n};\n\ndescribe('AuthenticationProviders', function () {\n  [\n    'apple',\n    'gcenter',\n    'gpgames',\n    'facebook',\n    'github',\n    'instagram',\n    'google',\n    'linkedin',\n    'meetup',\n    'twitter',\n    'janrainengage',\n    'janraincapture',\n    'line',\n    'vkontakte',\n    'qq',\n    'spotify',\n    'wechat',\n    'weibo',\n    'phantauth',\n    'microsoft',\n    'keycloak',\n  ].map(function (providerName) {\n    it('Should validate structure of ' + providerName, done => {\n      const provider = require('../lib/Adapters/Auth/' + providerName);\n      jequal(typeof provider.validateAuthData, 'function');\n      jequal(typeof provider.validateAppId, 'function');\n      const validateAuthDataPromise = provider.validateAuthData({}, {});\n      const validateAppIdPromise = provider.validateAppId('app', 'key', {});\n      jequal(validateAuthDataPromise.constructor, Promise.prototype.constructor);\n      jequal(validateAppIdPromise.constructor, Promise.prototype.constructor);\n      validateAuthDataPromise.then(\n        () => {},\n        () => {}\n      );\n      validateAppIdPromise.then(\n        () => {},\n        () => {}\n      );\n      done();\n    });\n\n    it(`should provide the right responses for adapter ${providerName}`, async () => {\n      const noResponse = ['twitter', 'apple', 'gcenter', 'google', 'keycloak'];\n      if (noResponse.includes(providerName)) {\n        return;\n      }\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'get').and.callFake(options => {\n        if (\n          options ===\n            'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.123&grant_type=client_credentials' ||\n          options ===\n            'https://oauth.vk.com/access_token?client_id=appId&client_secret=appSecret&v=5.124&grant_type=client_credentials'\n        ) {\n          return {\n            access_token: 'access_token',\n          };\n        }\n        return Promise.resolve(responses[providerName] || { id: 'userId' });\n      });\n      spyOn(require('../lib/Adapters/Auth/httpsRequest'), 'request').and.callFake(() => {\n        return Promise.resolve(responses[providerName] || { id: 'userId' });\n      });\n      const provider = require('../lib/Adapters/Auth/' + providerName);\n      let params = {};\n      if (providerName === 'vkontakte') {\n        params = {\n          appIds: 'appId',\n          appSecret: 'appSecret',\n        };\n        await provider.validateAuthData({ id: 'userId' }, params);\n        params.appVersion = '5.123';\n      }\n      await provider.validateAuthData({ id: 'userId' }, params);\n    });\n  });\n\n  const getMockMyOauthProvider = function () {\n    return {\n      authData: {\n        id: '12345',\n        access_token: '12345',\n        expiration_date: new Date().toJSON(),\n      },\n      shouldError: false,\n      loggedOut: false,\n      synchronizedUserId: null,\n      synchronizedAuthToken: null,\n      synchronizedExpiration: null,\n\n      authenticate: function (options) {\n        if (this.shouldError) {\n          options.error(this, 'An error occurred');\n        } else if (this.shouldCancel) {\n          options.error(this, null);\n        } else {\n          options.success(this, this.authData);\n        }\n      },\n      restoreAuthentication: function (authData) {\n        if (!authData) {\n          this.synchronizedUserId = null;\n          this.synchronizedAuthToken = null;\n          this.synchronizedExpiration = null;\n          return true;\n        }\n        this.synchronizedUserId = authData.id;\n        this.synchronizedAuthToken = authData.access_token;\n        this.synchronizedExpiration = authData.expiration_date;\n        return true;\n      },\n      getAuthType: function () {\n        return 'myoauth';\n      },\n      deauthenticate: function () {\n        this.loggedOut = true;\n        this.restoreAuthentication(null);\n      },\n    };\n  };\n\n  Parse.User.extend({\n    extended: function () {\n      return true;\n    },\n  });\n\n  const createOAuthUser = function (callback) {\n    return createOAuthUserWithSessionToken(undefined, callback);\n  };\n\n  const createOAuthUserWithSessionToken = function (token, callback) {\n    const jsonBody = {\n      authData: {\n        myoauth: getMockMyOauthProvider().authData,\n      },\n    };\n\n    const options = {\n      method: 'POST',\n      headers: {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Installation-Id': 'yolo',\n        'X-Parse-Session-Token': token,\n        'Content-Type': 'application/json',\n      },\n      url: 'http://localhost:8378/1/users',\n      body: jsonBody,\n    };\n    return request(options)\n      .then(response => {\n        if (callback) {\n          callback(null, response, response.data);\n        }\n        return {\n          res: response,\n          body: response.data,\n        };\n      })\n      .catch(error => {\n        if (callback) {\n          callback(error);\n        }\n        throw error;\n      });\n  };\n\n  it('should create user with REST API', done => {\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      ok(b.sessionToken);\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      const sessionToken = b.sessionToken;\n      const q = new Parse.Query('_Session');\n      q.equalTo('sessionToken', sessionToken);\n      q.first({ useMasterKey: true })\n        .then(res => {\n          if (!res) {\n            fail('should not fail fetching the session');\n            done();\n            return;\n          }\n          expect(res.get('installationId')).toEqual('yolo');\n          done();\n        })\n        .catch(() => {\n          fail('should not fail fetching the session');\n          done();\n        });\n    });\n  });\n\n  it('should only create a single user with REST API', done => {\n    let objectId;\n    createOAuthUser((error, response, body) => {\n      expect(error).toBe(null);\n      const b = body;\n      expect(b.objectId).not.toBeNull();\n      expect(b.objectId).not.toBeUndefined();\n      objectId = b.objectId;\n\n      createOAuthUser((error, response, body) => {\n        expect(error).toBe(null);\n        const b = body;\n        expect(b.objectId).not.toBeNull();\n        expect(b.objectId).not.toBeUndefined();\n        expect(b.objectId).toBe(objectId);\n        done();\n      });\n    });\n  });\n\n  it(\"should fail to link if session token don't match user\", done => {\n    Parse.User.signUp('myUser', 'password')\n      .then(user => {\n        return createOAuthUserWithSessionToken(user.getSessionToken());\n      })\n      .then(() => {\n        return Parse.User.logOut();\n      })\n      .then(() => {\n        return Parse.User.signUp('myUser2', 'password');\n      })\n      .then(user => {\n        return createOAuthUserWithSessionToken(user.getSessionToken());\n      })\n      .then(fail, ({ data }) => {\n        expect(data.code).toBe(208);\n        expect(data.error).toBe('this auth is already used');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('unlink and link with custom provider', async () => {\n    const provider = getMockMyOauthProvider();\n    Parse.User._registerAuthenticationProvider(provider);\n    const model = await Parse.User._logInWith('myoauth');\n    ok(model instanceof Parse.User, 'Model should be a Parse.User');\n    strictEqual(Parse.User.current(), model);\n    ok(model.extended(), 'Should have used the subclass.');\n    strictEqual(provider.authData.id, provider.synchronizedUserId);\n    strictEqual(provider.authData.access_token, provider.synchronizedAuthToken);\n    strictEqual(provider.authData.expiration_date, provider.synchronizedExpiration);\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n\n    await model._unlinkFrom('myoauth');\n    ok(!model._isLinked('myoauth'), 'User should not be linked to myoauth');\n    ok(!provider.synchronizedUserId, 'User id should be cleared');\n    ok(!provider.synchronizedAuthToken, 'Auth token should be cleared');\n    ok(!provider.synchronizedExpiration, 'Expiration should be cleared');\n    // make sure the auth data is properly deleted\n    const config = Config.get(Parse.applicationId);\n    const res = await config.database.adapter.find(\n      '_User',\n      {\n        fields: Object.assign({}, defaultColumns._Default, defaultColumns._Installation),\n      },\n      { objectId: model.id },\n      {}\n    );\n    expect(res.length).toBe(1);\n    expect(res[0]._auth_data_myoauth).toBeUndefined();\n    expect(res[0]._auth_data_myoauth).not.toBeNull();\n\n    await model._linkWith('myoauth');\n\n    ok(provider.synchronizedUserId, 'User id should have a value');\n    ok(provider.synchronizedAuthToken, 'Auth token should have a value');\n    ok(provider.synchronizedExpiration, 'Expiration should have a value');\n    ok(model._isLinked('myoauth'), 'User should be linked to myoauth');\n  });\n\n  function validateValidator(validator) {\n    expect(typeof validator).toBe('function');\n  }\n\n  function validateAuthenticationHandler(authenticationHandler) {\n    expect(authenticationHandler).not.toBeUndefined();\n    expect(typeof authenticationHandler.getValidatorForProvider).toBe('function');\n    expect(typeof authenticationHandler.getValidatorForProvider).toBe('function');\n  }\n\n  function validateAuthenticationAdapter(authAdapter) {\n    expect(authAdapter).not.toBeUndefined();\n    if (!authAdapter) {\n      return;\n    }\n    expect(typeof authAdapter.validateAuthData).toBe('function');\n    expect(typeof authAdapter.validateAppId).toBe('function');\n  }\n\n  it('properly loads custom adapter', done => {\n    const validAuthData = {\n      id: 'hello',\n      token: 'world',\n    };\n    const adapter = {\n      validateAppId: function () {\n        return Promise.resolve();\n      },\n      validateAuthData: function (authData) {\n        if (authData.id == validAuthData.id && authData.token == validAuthData.token) {\n          return Promise.resolve();\n        }\n        return Promise.reject();\n      },\n    };\n\n    const authDataSpy = spyOn(adapter, 'validateAuthData').and.callThrough();\n    const appIdSpy = spyOn(adapter, 'validateAppId').and.callThrough();\n\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: adapter,\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator(validAuthData).then(\n      () => {\n        expect(authDataSpy).toHaveBeenCalled();\n        // AppIds are not provided in the adapter, should not be called\n        expect(appIdSpy).not.toHaveBeenCalled();\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads custom adapter module object', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: path.resolve('./spec/support/CustomAuth.js'),\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator({\n      token: 'my-token',\n    }).then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads custom adapter module object (again)', done => {\n    const authenticationHandler = authenticationLoader({\n      customAuthentication: {\n        module: path.resolve('./spec/support/CustomAuthFunction.js'),\n        options: { token: 'valid-token' },\n      },\n    });\n\n    validateAuthenticationHandler(authenticationHandler);\n    const validator = authenticationHandler.getValidatorForProvider('customAuthentication');\n    validateValidator(validator);\n\n    validator({\n      token: 'valid-token',\n    }).then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('properly loads a default adapter with options', () => {\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'facebook',\n      options\n    );\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.facebook);\n  });\n\n  it('should handle Facebook appSecret for validating appIds', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'a' });\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce',\n      },\n    };\n    const authData = {\n      access_token: 'badtoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'facebook',\n      options\n    );\n    await adapter.validateAppId(appIds, authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });\n\n  it('should handle Facebook appSecret for validating auth data', async () => {\n    const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve();\n    });\n    const options = {\n      facebook: {\n        appIds: ['a', 'b'],\n        appSecret: 'secret_sauce',\n      },\n    };\n    const authData = {\n      id: 'test',\n      access_token: 'test',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('facebook', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get.calls.first().args[0].includes('appsecret_proof')).toBe(true);\n  });\n\n  it('properly loads a custom adapter with options', () => {\n    const options = {\n      custom: {\n        validateAppId: () => {},\n        validateAuthData: () => {},\n        appIds: ['a', 'b'],\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'custom',\n      options\n    );\n    validateAuthenticationAdapter(adapter);\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions).toEqual(options.custom);\n  });\n});\n\ndescribe('instagram auth adapter', () => {\n  const instagram = require('../lib/Adapters/Auth/instagram');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('should use default api', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ data: { id: 'userId' } });\n    });\n    await instagram.validateAuthData({ id: 'userId', access_token: 'the_token' }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://graph.instagram.com/me?fields=id&access_token=the_token'\n    );\n  });\n  it('response object without data child', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'userId' });\n    });\n    await instagram.validateAuthData({ id: 'userId', access_token: 'the_token' }, {});\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://graph.instagram.com/me?fields=id&access_token=the_token'\n    );\n  });\n  it('should pass in api url', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ data: { id: 'userId' } });\n    });\n    await instagram.validateAuthData(\n      {\n        id: 'userId',\n        access_token: 'the_token',\n        apiURL: 'https://new-api.instagram.com/v1/',\n      },\n      {}\n    );\n    expect(httpsRequest.get).toHaveBeenCalledWith(\n      'https://new-api.instagram.com/v1/me?fields=id&access_token=the_token'\n    );\n  });\n});\n\ndescribe('google auth adapter', () => {\n  const google = require('../lib/Adapters/Auth/google');\n  const jwt = require('jsonwebtoken');\n\n  it('should throw error with missing id_token', async () => {\n    try {\n      await google.validateAuthData({}, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await google.validateAuthData({ id: 'the_user_id', id_token: 'the_token' }, {});\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  // it('should throw error if public key used to encode token is not available', async () => {\n  //   const fakeDecodedToken = { header: { kid: '789', alg: 'RS256' } };\n  //   try {\n  //     spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n  //     await google.validateAuthData({ id: 'the_user_id', id_token: 'the_token' }, {});\n  //     fail();\n  //   } catch (e) {\n  //     expect(e.message).toBe(\n  //       `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n  //     );\n  //   }\n  // });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await google.validateAuthData(\n      { id: 'the_user_id', id_token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.google.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'the_user_id', id_token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct provider - expected: accounts.google.com or https://accounts.google.com | from: https://not.google.com'\n      );\n    }\n  });\n\n  xit('(using client id as string) should throw error with invalid jwt client_id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  xit('should throw error with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://accounts.google.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await google.validateAuthData(\n        { id: 'invalid user', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n\ndescribe('google play games service auth', () => {\n  const gpgames = require('../lib/Adapters/Auth/gpgames');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should pass validation', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ playerId: 'userId' });\n    });\n    await gpgames.validateAuthData({\n      id: 'userId',\n      access_token: 'access_token',\n    });\n  });\n\n  it('validateAuthData should throw error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ playerId: 'invalid' });\n    });\n    try {\n      await gpgames.validateAuthData({\n        id: 'userId',\n        access_token: 'access_token',\n      });\n    } catch (e) {\n      expect(e.message).toBe('Google Play Games Services - authData is invalid for this user.');\n    }\n  });\n});\n\ndescribe('keycloak auth adapter', () => {\n  const keycloak = require('../lib/Adapters/Auth/keycloak');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should fail without access token', async () => {\n    const authData = {\n      id: 'fakeid',\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });\n\n  it('validateAuthData should fail without user id', async () => {\n    const authData = {\n      access_token: 'sometoken',\n    };\n    try {\n      await keycloak.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing access token and/or User id');\n    }\n  });\n\n  it('validateAuthData should fail without config', async () => {\n    const options = {\n      keycloak: {\n        config: null,\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Missing keycloak configuration');\n    }\n  });\n\n  it('validateAuthData should fail connect error', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({ error: 'hosting_error' }),\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Could not connect to the authentication server');\n    }\n  });\n\n  it('validateAuthData should fail with error description', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.reject({\n        text: JSON.stringify({ error_description: 'custom error message' }),\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('custom error message');\n    }\n  });\n\n  it('validateAuthData should fail with invalid auth', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should fail with invalid groups', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['unknown'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should fail with invalid roles', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: 'unknown',\n          groups: ['group1'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Invalid authentication');\n    }\n  });\n\n  it('validateAuthData should handle authentication', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({\n        data: {\n          sub: 'fakeid',\n          roles: ['role1'],\n          groups: ['group1'],\n        },\n      });\n    });\n    const options = {\n      keycloak: {\n        config: {\n          'auth-server-url': 'http://example.com',\n          realm: 'new',\n        },\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n      roles: ['role1'],\n      groups: ['group1'],\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter('keycloak', options);\n    await adapter.validateAuthData(authData, providerOptions);\n    expect(httpsRequest.get).toHaveBeenCalledWith({\n      host: 'http://example.com',\n      path: '/realms/new/protocol/openid-connect/userinfo',\n      headers: {\n        Authorization: 'Bearer sometoken',\n      },\n    });\n  });\n});\n\ndescribe('oauth2 auth adapter', () => {\n  const oauth2 = require('../lib/Adapters/Auth/oauth2');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('properly loads OAuth2 adapter via the \"oauth2\" option', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n      },\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    expect(loadedAuthAdapter.adapter).toEqual(oauth2);\n  });\n\n  it('properly loads OAuth2 adapter with options', () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n        debug: true,\n      },\n    };\n    const loadedAuthAdapter = authenticationLoader.loadAuthAdapter('oauth2Authentication', options);\n    const appIds = loadedAuthAdapter.appIds;\n    const providerOptions = loadedAuthAdapter.providerOptions;\n    expect(providerOptions.tokenIntrospectionEndpointUrl).toEqual('https://example.com/introspect');\n    expect(providerOptions.useridField).toEqual('sub');\n    expect(providerOptions.appidField).toEqual('appId');\n    expect(appIds).toEqual(['a', 'b']);\n    expect(providerOptions.authorizationHeader).toEqual('Basic dXNlcm5hbWU6cGFzc3dvcmQ=');\n    expect(providerOptions.debug).toEqual(true);\n  });\n\n  it('validateAppId should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        appIds: ['a', 'b'],\n        appidField: 'appId',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 token introspection endpoint URL is missing from configuration!'\n      );\n    }\n  });\n\n  it('validateAppId appidField optional', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not reach here\n      fail(e);\n    }\n  });\n\n  it('validateAppId should fail without appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).'\n      );\n    }\n  });\n\n  it('validateAppId should fail empty appIds', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: [],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).'\n      );\n    }\n  });\n\n  it('validateAppId invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n  });\n\n  it('validateAppId invalid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({ active: true });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        \"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\"\n      );\n    }\n  });\n\n  it('validateAppId valid accessToken appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'a',\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n\n  it('validateAppId valid accessToken appId array', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: ['a'],\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n\n  it('validateAppId valid accessToken invalid appId', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        appId: 'unknown',\n      });\n    });\n    try {\n      await adapter.validateAppId(appIds, authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        \"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\"\n      );\n    }\n  });\n\n  it('validateAuthData should fail if OAuth2 tokenIntrospectionEndpointUrl is not configured properly', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe(\n        'OAuth2 token introspection endpoint URL is missing from configuration!'\n      );\n    }\n  });\n\n  it('validateAuthData invalid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n        authorizationHeader: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({});\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      expect(e.message).toBe('OAuth2 access token is invalid for this user.');\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith(\n      {\n        hostname: 'example.com',\n        path: '/introspect',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': 15,\n          Authorization: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=',\n        },\n      },\n      'token=sometoken'\n    );\n  });\n\n  it('validateAuthData valid accessToken', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        useridField: 'sub',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid',\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n    expect(httpsRequest.request).toHaveBeenCalledWith(\n      {\n        hostname: 'example.com',\n        path: '/introspect',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': 15,\n        },\n      },\n      'token=sometoken'\n    );\n  });\n\n  it('validateAuthData valid accessToken without useridField', async () => {\n    const options = {\n      oauth2Authentication: {\n        oauth2: true,\n        tokenIntrospectionEndpointUrl: 'https://example.com/introspect',\n        appidField: 'appId',\n        appIds: ['a', 'b'],\n      },\n    };\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'oauth2Authentication',\n      options\n    );\n    spyOn(httpsRequest, 'request').and.callFake(() => {\n      return Promise.resolve({\n        active: true,\n        sub: 'fakeid',\n      });\n    });\n    try {\n      await adapter.validateAuthData(authData, providerOptions);\n    } catch (e) {\n      // Should not enter here\n      fail(e);\n    }\n  });\n});\n\ndescribe('apple signin auth adapter', () => {\n  const apple = require('../lib/Adapters/Auth/apple');\n  const jwt = require('jsonwebtoken');\n  const util = require('util');\n\n  it('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, { clientId: 'secret' });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await apple.validateAuthData({}, { clientId: ['secret'] });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('id token is invalid for this user.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = { header: { kid: '789', alg: 'RS256' } };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n      );\n    }\n  });\n\n  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });\n\n  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });\n\n  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await apple.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret', 'secret 123'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: ['INSERT CLIENT ID HERE'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.apple.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT APPLE TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://appleid.apple.com | from: https://not.apple.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'INSERT ID HERE', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own apple signed tokens, perhaps with a parse apple account\n  // and a private key\n  xit('should throw error with invalid user id', async () => {\n    try {\n      await apple.validateAuthData(\n        { id: 'invalid user', token: 'INSERT APPLE TOKEN HERE' },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n\n  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://appleid.apple.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id',\n    };\n    const fakeDecodedToken = { header: { kid: '123', alg: 'RS256' } };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return { kid: '123', rsaPublicKey: 'the_rsa_public_key' };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await apple.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n\ndescribe('Apple Game Center Auth adapter', () => {\n  const gcenter = require('../lib/Adapters/Auth/gcenter');\n  const fs = require('fs');\n  const testCert = fs.readFileSync(__dirname + '/support/cert/game_center.pem');\n  it('can load adapter', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl:\n          'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n  });\n  it('validateAuthData should validate', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl:\n          'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n    // real token is used\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer',\n      timestamp: 1565257031287,\n      signature:\n        'uqLBTr9Uex8zCpc1UQ1MIDMitb+HUat2Mah4Kw6AVLSGe0gGNJXlih2i5X+0ZwVY0S9zY2NHWi2gFjmhjt/4kxWGMkupqXX5H/qhE2m7hzox6lZJpH98ZEUbouWRfZX2ZhUlCkAX09oRNi7fI7mWL1/o88MaI/y6k6tLr14JTzmlxgdyhw+QRLxRPA6NuvUlRSJpyJ4aGtNH5/wHdKQWL8nUnFYiYmaY8R7IjzNxPfy8UJTUWmeZvMSgND4u8EjADPsz7ZtZyWAPi8kYcAb6M8k0jwLD3vrYCB8XXyO2RQb/FY2TM4zJuI7PzLlvvgOJXbbfVtHx7Evnm5NYoyzgzw==',\n      salt: 'DzqqrQ==',\n      bundleId: 'cloud.xtralife.gamecenterauth',\n    };\n    gcenter.cache['https://static.gc.apple.com/public-key/gc-prod-4.cer'] = testCert;\n    await gcenter.validateAuthData(authData);\n  });\n\n  it('validateAuthData invalid signature id', async () => {\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      {}\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n    const authData = {\n      id: 'G:1965586982',\n      publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-6.cer',\n      timestamp: 1565257031287,\n      signature: '1234',\n      salt: 'DzqqrQ==',\n      bundleId: 'com.example.com',\n    };\n    await expectAsync(gcenter.validateAuthData(authData)).toBeRejectedWith(\n      new Parse.Error(Parse.Error.SCRIPT_FAILED, 'Apple Game Center - invalid signature')\n    );\n  });\n\n  it('validateAuthData invalid public key http url', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl:\n          'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n    const publicKeyUrls = [\n      'example.com',\n      'http://static.gc.apple.com/public-key/gc-prod-4.cer',\n      'https://developer.apple.com/assets/elements/badges/download-on-the-app-store.svg',\n      'https://example.com/ \\\\.apple.com/public_key.cer',\n      'https://example.com/ &.apple.com/public_key.cer',\n    ];\n    await Promise.all(\n      publicKeyUrls.map(publicKeyUrl =>\n        expectAsync(\n          gcenter.validateAuthData({\n            id: 'G:1965586982',\n            timestamp: 1565257031287,\n            publicKeyUrl,\n            signature: '1234',\n            salt: 'DzqqrQ==',\n            bundleId: 'com.example.com',\n          })\n        ).toBeRejectedWith(\n          new Parse.Error(\n            Parse.Error.SCRIPT_FAILED,\n            `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n          )\n        )\n      )\n    );\n  });\n\n  it('should not validate Symantec Cert', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl:\n          'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n    expect(() =>\n      gcenter.verifyPublicKeyIssuer(\n        testCert,\n        'https://static.gc.apple.com/public-key/gc-prod-4.cer'\n      )\n    );\n  });\n\n  it('adapter should load default cert', async () => {\n    const options = {\n      gcenter: {},\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n    const previous = new Date();\n    await adapter.validateAppId(\n      appIds,\n      { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n      providerOptions\n    );\n\n    const duration = new Date().getTime() - previous.getTime();\n    expect(duration).toEqual(0);\n  });\n\n  it('adapter should throw', async () => {\n    const options = {\n      gcenter: {\n        rootCertificateUrl: 'https://example.com',\n      },\n    };\n    const { adapter, appIds, providerOptions } = authenticationLoader.loadAuthAdapter(\n      'gcenter',\n      options\n    );\n    await expectAsync(\n      adapter.validateAppId(\n        appIds,\n        { publicKeyUrl: 'https://static.gc.apple.com/public-key/gc-prod-4.cer' },\n        providerOptions\n      )\n    ).toBeRejectedWith(\n      new Parse.Error(\n        Parse.Error.OBJECT_NOT_FOUND,\n        'Apple Game Center auth adapter parameter `rootCertificateURL` is invalid.'\n      )\n    );\n  });\n});\n\ndescribe('phant auth adapter', () => {\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('validateAuthData should throw for invalid auth', async () => {\n    const authData = {\n      id: 'fakeid',\n      access_token: 'sometoken',\n    };\n    const { adapter } = authenticationLoader.loadAuthAdapter('phantauth', {});\n\n    spyOn(httpsRequest, 'get').and.callFake(() => Promise.resolve({ sub: 'invalidID' }));\n    try {\n      await adapter.validateAuthData(authData);\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('PhantAuth auth is invalid for this user.');\n    }\n  });\n});\n\ndescribe('microsoft graph auth adapter', () => {\n  const microsoft = require('../lib/Adapters/Auth/microsoft');\n  const httpsRequest = require('../lib/Adapters/Auth/httpsRequest');\n\n  it('should use access_token for validation is passed and responds with id and mail', async () => {\n    spyOn(httpsRequest, 'get').and.callFake(() => {\n      return Promise.resolve({ id: 'userId', mail: 'userMail' });\n    });\n    await microsoft.validateAuthData({\n      id: 'userId',\n      access_token: 'the_token',\n    });\n  });\n\n  it('should fail to validate Microsoft Graph auth with bad token', done => {\n    const authData = {\n      id: 'fake-id',\n      mail: 'fake@mail.com',\n      access_token: 'very.long.bad.token',\n    };\n    microsoft.validateAuthData(authData).then(done.fail, err => {\n      expect(err.code).toBe(Parse.Error.OBJECT_NOT_FOUND);\n      expect(err.message).toBe('Microsoft Graph auth is invalid for this user.');\n      done();\n    });\n  });\n});\n\ndescribe('facebook limited auth adapter', () => {\n  const facebook = require('../lib/Adapters/Auth/facebook');\n  const jwt = require('jsonwebtoken');\n  const util = require('util');\n\n  // TODO: figure out a way to run this test alongside facebook classic tests\n  xit('(using client id as string) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, { clientId: 'secret' });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });\n\n  // TODO: figure out a way to run this test alongside facebook classic tests\n  xit('(using client id as array) should throw error with missing id_token', async () => {\n    try {\n      await facebook.validateAuthData({}, { clientId: ['secret'] });\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('Facebook auth is not configured.');\n    }\n  });\n\n  it('should not decode invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('should throw error if public key used to encode token is not available', async () => {\n    const fakeDecodedToken = {\n      header: { kid: '789', alg: 'RS256' },\n    };\n    try {\n      spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        `Unable to find matching key for Key ID: ${fakeDecodedToken.header.kid}`\n      );\n    }\n  });\n\n  it('should use algorithm from key header to verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n    expect(jwt.verify.calls.first().args[2].algorithms).toEqual(fakeDecodedToken.header.alg);\n  });\n\n  it('should not verify invalid id_token', async () => {\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt malformed');\n    }\n  });\n\n  it('(using client id as array) should not verify invalid id_token', async () => {\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('provided token does not decode as JWT');\n    }\n  });\n\n  it('(using client id as string) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: 'secret' }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as array with multiple items) should verify id_token', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'secret',\n      exp: Date.now(),\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    const result = await facebook.validateAuthData(\n      { id: 'the_user_id', token: 'the_token' },\n      { clientId: ['secret', 'secret 123'] }\n    );\n    expect(result).toEqual(fakeClaim);\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as array) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: ['INSERT CLIENT ID HERE'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  it('(using client id as string) should throw error with with invalid jwt issuer', async () => {\n    const fakeClaim = {\n      iss: 'https://not.facebook.com',\n      sub: 'the_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE WITH INVALID JWT ISSUER',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe(\n        'id token not issued by correct OpenID provider - expected: https://facebook.com | from: https://not.facebook.com'\n      );\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as string) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('(using client id as array) should throw error with invalid jwt clientId', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'INSERT ID HERE',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: ['secret'] }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('jwt audience invalid. expected: secret');\n    }\n  });\n\n  // TODO: figure out a way to generate our own facebook signed tokens, perhaps with a parse facebook account\n  // and a private key\n  xit('should throw error with invalid user id', async () => {\n    try {\n      await facebook.validateAuthData(\n        {\n          id: 'invalid user',\n          token: 'INSERT FACEBOOK TOKEN HERE',\n        },\n        { clientId: 'INSERT CLIENT ID HERE' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n\n  it('should throw error with with invalid user id', async () => {\n    const fakeClaim = {\n      iss: 'https://facebook.com',\n      aud: 'invalid_client_id',\n      sub: 'a_different_user_id',\n    };\n    const fakeDecodedToken = {\n      header: { kid: '123', alg: 'RS256' },\n    };\n    spyOn(jwt, 'decode').and.callFake(() => fakeDecodedToken);\n    const fakeGetSigningKeyAsyncFunction = () => {\n      return {\n        kid: '123',\n        rsaPublicKey: 'the_rsa_public_key',\n      };\n    };\n    spyOn(util, 'promisify').and.callFake(() => fakeGetSigningKeyAsyncFunction);\n    spyOn(jwt, 'verify').and.callFake(() => fakeClaim);\n\n    try {\n      await facebook.validateAuthData(\n        { id: 'the_user_id', token: 'the_token' },\n        { clientId: 'secret' }\n      );\n      fail();\n    } catch (e) {\n      expect(e.message).toBe('auth data is invalid for this user.');\n    }\n  });\n});\n", "-----BEGIN CERTIFICATE-----\nMIIEvDCCA6SgAwIBAgIQXRHxNXkw1L9z5/3EZ/T/hDANBgkqhkiG9w0BAQsFADB/\nMQswCQYDVQQGEwJVUzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9yYXRpb24xHzAd\nBgNVBAsTFlN5bWFudGVjIFRydXN0IE5ldHdvcmsxMDAuBgNVBAMTJ1N5bWFudGVj\nIENsYXNzIDMgU0hBMjU2IENvZGUgU2lnbmluZyBDQTAeFw0xODA5MTcwMDAwMDBa\nFw0xOTA5MTcyMzU5NTlaMHMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9y\nbmlhMRIwEAYDVQQHDAlDdXBlcnRpbm8xFDASBgNVBAoMC0FwcGxlLCBJbmMuMQ8w\nDQYDVQQLDAZHQyBTUkUxFDASBgNVBAMMC0FwcGxlLCBJbmMuMIIBIjANBgkqhkiG\n9w0BAQEFAAOCAQ8AMIIBCgKCAQEA06fwIi8fgKrTQu7cBcFkJVF6+Tqvkg7MKJTM\nIOYPPQtPF3AZYPsbUoRKAD7/JXrxxOSVJ7vU1mP77tYG8TcUteZ3sAwvt2dkRbm7\nZO6DcmSggv1Dg4k3goNw4GYyCY4Z2/8JSmsQ80Iv/UOOwynpBziEeZmJ4uck6zlA\n17cDkH48LBpKylaqthym5bFs9gj11pto7mvyb5BTcVuohwi6qosvbs/4VGbC2Nsz\nie416nUZfv+xxoXH995gxR2mw5cDdeCew7pSKxEhvYjT2nVdQF0q/hnPMFnOaEyT\nq79n3gwFXyt0dy8eP6KBF7EW9J6b7ubu/j7h+tQfxPM+gTXOBQIDAQABo4IBPjCC\nATowCQYDVR0TBAIwADAOBgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUH\nAwMwYQYDVR0gBFowWDBWBgZngQwBBAEwTDAjBggrBgEFBQcCARYXaHR0cHM6Ly9k\nLnN5bWNiLmNvbS9jcHMwJQYIKwYBBQUHAgIwGQwXaHR0cHM6Ly9kLnN5bWNiLmNv\nbS9ycGEwHwYDVR0jBBgwFoAUljtT8Hkzl699g+8uK8zKt4YecmYwKwYDVR0fBCQw\nIjAgoB6gHIYaaHR0cDovL3N2LnN5bWNiLmNvbS9zdi5jcmwwVwYIKwYBBQUHAQEE\nSzBJMB8GCCsGAQUFBzABhhNodHRwOi8vc3Yuc3ltY2QuY29tMCYGCCsGAQUFBzAC\nhhpodHRwOi8vc3Yuc3ltY2IuY29tL3N2LmNydDANBgkqhkiG9w0BAQsFAAOCAQEA\nI/j/PcCNPebSAGrcqSFBSa2mmbusOX01eVBg8X0G/z8Z+ZWUfGFzDG0GQf89MPxV\nwoec+nZuqui7o9Bg8s8JbHV0TC52X14CbTj9w/qBF748WbH9gAaTkrJYPm+MlNhu\ntjEuQdNl/YXVMvQW4O8UMHTi09GyJQ0NC4q92Wxvx1m/qzjvTLvrXHGQ9pEHhPyz\nvfBLxQkWpNoCNKU7UeESyH06XOrGc9MsII9deeKsDJp9a0jtx+pP4MFVtFME9SSQ\ntMBs0It7WwEf7qcRLpialxKwY2EzQ9g4WnANHqo18PrDBE10TFpZPzUh7JhMViVr\nEEbl0YdElmF8Hlamah/yNw==\n-----END CERTIFICATE-----\n", "/* Apple Game Center Auth\nhttps://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign#discussion\n\nconst authData = {\n  publicKeyUrl: 'https://valid.apple.com/public/timeout.cer',\n  timestamp: 1460981421303,\n  signature: 'PoDwf39DCN464B49jJCU0d9Y0J',\n  salt: 'saltST==',\n  bundleId: 'com.valid.app'\n  id: 'playerId',\n};\n*/\n\nconst { Parse } = require('parse/node');\nconst crypto = require('crypto');\nconst https = require('https');\nconst { pki } = require('node-forge');\nconst ca = { cert: null, url: null };\nconst cache = {}; // (publicKey -> cert) cache\n\nfunction verifyPublicKeyUrl(publicKeyUrl) {\n  try {\n    const regex = /^https:\\/\\/(?:[-_A-Za-z0-9]+\\.){0,}apple\\.com\\/.*\\.cer$/;\n    return regex.test(publicKeyUrl);\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction convertX509CertToPEM(X509Cert) {\n  const pemPreFix = '-----BEGIN CERTIFICATE-----\\n';\n  const pemPostFix = '-----END CERTIFICATE-----';\n\n  const base64 = X509Cert;\n  const certBody = base64.match(new RegExp('.{0,64}', 'g')).join('\\n');\n\n  return pemPreFix + certBody + pemPostFix;\n}\n\nasync function getAppleCertificate(publicKeyUrl) {\n  if (!verifyPublicKeyUrl(publicKeyUrl)) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n    );\n  }\n  if (cache[publicKeyUrl]) {\n    return cache[publicKeyUrl];\n  }\n  const url = new URL(publicKeyUrl);\n  const headOptions = {\n    hostname: url.hostname,\n    path: url.pathname,\n    method: 'HEAD',\n  };\n  const cert_headers = await new Promise((resolve, reject) =>\n    https.get(headOptions, res => resolve(res.headers)).on('error', reject)\n  );\n  const validContentTypes = ['application/x-x509-ca-cert', 'application/pkix-cert'];\n  if (\n    !validContentTypes.includes(cert_headers['content-type']) ||\n    cert_headers['content-length'] == null ||\n    cert_headers['content-length'] > 10000\n  ) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n    );\n  }\n  const { certificate, headers } = await getCertificate(publicKeyUrl);\n  if (headers['cache-control']) {\n    const expire = headers['cache-control'].match(/max-age=([0-9]+)/);\n    if (expire) {\n      cache[publicKeyUrl] = certificate;\n      // we'll expire the cache entry later, as per max-age\n      setTimeout(() => {\n        delete cache[publicKeyUrl];\n      }, parseInt(expire[1], 10) * 1000);\n    }\n  }\n  return verifyPublicKeyIssuer(certificate, publicKeyUrl);\n}\n\nfunction getCertificate(url, buffer) {\n  return new Promise((resolve, reject) => {\n    https\n      .get(url, res => {\n        const data = [];\n        res.on('data', chunk => {\n          data.push(chunk);\n        });\n        res.on('end', () => {\n          if (buffer) {\n            resolve({ certificate: Buffer.concat(data), headers: res.headers });\n            return;\n          }\n          let cert = '';\n          for (const chunk of data) {\n            cert += chunk.toString('base64');\n          }\n          const certificate = convertX509CertToPEM(cert);\n          resolve({ certificate, headers: res.headers });\n        });\n      })\n      .on('error', reject);\n  });\n}\n\nfunction convertTimestampToBigEndian(timestamp) {\n  const buffer = Buffer.alloc(8);\n\n  const high = ~~(timestamp / 0xffffffff);\n  const low = timestamp % (0xffffffff + 0x1);\n\n  buffer.writeUInt32BE(parseInt(high, 10), 0);\n  buffer.writeUInt32BE(parseInt(low, 10), 4);\n\n  return buffer;\n}\n\nfunction verifySignature(publicKey, authData) {\n  const verifier = crypto.createVerify('sha256');\n  verifier.update(authData.playerId, 'utf8');\n  verifier.update(authData.bundleId, 'utf8');\n  verifier.update(convertTimestampToBigEndian(authData.timestamp));\n  verifier.update(authData.salt, 'base64');\n\n  if (!verifier.verify(publicKey, authData.signature, 'base64')) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Apple Game Center - invalid signature');\n  }\n}\n\nfunction verifyPublicKeyIssuer(cert, publicKeyUrl) {\n  const publicKeyCert = pki.certificateFromPem(cert);\n  if (!ca.cert) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      'Apple Game Center auth adapter parameter `rootCertificateURL` is invalid.'\n    );\n  }\n  try {\n    if (!ca.cert.verify(publicKeyCert)) {\n      throw new Parse.Error(\n        Parse.Error.OBJECT_NOT_FOUND,\n        `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n      );\n    }\n  } catch (e) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      `Apple Game Center - invalid publicKeyUrl: ${publicKeyUrl}`\n    );\n  }\n  return cert;\n}\n\n// Returns a promise that fulfills if this user id is valid.\nasync function validateAuthData(authData) {\n  if (!authData.id) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Apple Game Center - authData id missing');\n  }\n  authData.playerId = authData.id;\n  const publicKey = await getAppleCertificate(authData.publicKeyUrl);\n  return verifySignature(publicKey, authData);\n}\n\n// Returns a promise that fulfills if this app id is valid.\nasync function validateAppId(appIds, authData, options = {}) {\n  if (!options.rootCertificateUrl) {\n    options.rootCertificateUrl =\n      'https://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt.pem';\n  }\n  if (ca.url === options.rootCertificateUrl) {\n    return;\n  }\n  const { certificate, headers } = await getCertificate(options.rootCertificateUrl, true);\n  if (\n    headers['content-type'] !== 'application/x-pem-file' ||\n    headers['content-length'] == null ||\n    headers['content-length'] > 10000\n  ) {\n    throw new Parse.Error(\n      Parse.Error.OBJECT_NOT_FOUND,\n      'Apple Game Center auth adapter parameter `rootCertificateURL` is invalid.'\n    );\n  }\n  ca.cert = pki.certificateFromPem(certificate);\n  ca.url = options.rootCertificateUrl;\n}\n\nmodule.exports = {\n  validateAppId,\n  validateAuthData,\n  cache,\n};\n"], "buggy_code_start_loc": [85, 1655, 1, 17], "buggy_code_end_loc": [101, 1716, 2, 135], "fixing_code_start_loc": [86, 1655, 1, 17], "fixing_code_end_loc": [99, 1842, 29, 195], "type": "CWE-287", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to versions 4.10.11 and 5.2.2, the certificate in the Parse Server Apple Game Center auth adapter not validated. As a result, authentication could potentially be bypassed by making a fake certificate accessible via certain Apple domains and providing the URL to that certificate in an authData object. Versions 4.0.11 and 5.2.2 prevent this by introducing a new `rootCertificateUrl` property to the Parse Server Apple Game Center auth adapter which takes the URL to the root certificate of Apple's Game Center authentication certificate. If no value is set, the `rootCertificateUrl` property defaults to the URL of the current root certificate as of May 27, 2022. Keep in mind that the root certificate can change at any time and that it is the developer's responsibility to keep the root certificate URL up-to-date when using the Parse Server Apple Game Center auth adapter. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31083", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-17T19:15:09.267", "lastModified": "2022-06-29T14:02:32.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to versions 4.10.11 and 5.2.2, the certificate in the Parse Server Apple Game Center auth adapter not validated. As a result, authentication could potentially be bypassed by making a fake certificate accessible via certain Apple domains and providing the URL to that certificate in an authData object. Versions 4.0.11 and 5.2.2 prevent this by introducing a new `rootCertificateUrl` property to the Parse Server Apple Game Center auth adapter which takes the URL to the root certificate of Apple's Game Center authentication certificate. If no value is set, the `rootCertificateUrl` property defaults to the URL of the current root certificate as of May 27, 2022. Keep in mind that the root certificate can change at any time and that it is the developer's responsibility to keep the root certificate URL up-to-date when using the Parse Server Apple Game Center auth adapter. There are no known workarounds for this issue."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede desplegarse en cualquier infraestructura que pueda ejecutar Node.js. En versiones anteriores a 4.10.11 y 5.2.2, el certificado en el adaptador de autenticaci\u00f3n de Apple Game Center de Parse Server no es comprobado. Como resultado, la autenticaci\u00f3n pod\u00eda ser potencialmente omitida al hacer un certificado falso accesible por medio de determinados dominios de Apple y proporcionando la URL a ese certificado en un objeto authData. Las versiones 4.0.11 y 5.2.2 evitan esto introduciendo una nueva propiedad \"rootCertificateUrl\" en el adaptador de autenticaci\u00f3n de Apple Game Center de Parse Server que toma la URL del certificado root del certificado de autenticaci\u00f3n de Apple Game Center. Si no es establecido ning\u00fan valor, la propiedad \"rootCertificateUrl\" toma por defecto la URL del certificado root actual a fecha de 27 de mayo de 2022. Ten en cuenta que el certificado root puede cambiar en cualquier momento y que es responsabilidad del desarrollador mantener actualizada la URL del certificado root cuando es usado el adaptador de autenticaci\u00f3n de Game Center de Parse Server. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.10.11", "matchCriteriaId": "E5C77674-CD0D-4D34-843C-AA2BB7EC8A45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.2", "matchCriteriaId": "CFB93627-80F2-437C-B1F3-1C80903D1E01"}]}]}], "references": [{"url": "https://developer.apple.com/news/?id=stttq465", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/commit/ba2b0a9cb9a568817a114b132a4c2e0911d76df1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/pull/8054", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-rh9j-f5f8-rvgc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/ba2b0a9cb9a568817a114b132a4c2e0911d76df1"}}